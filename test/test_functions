# By default, this script runs in testing mode
# Although it allows for a server debugging mode, which attaches gdb to
# the `cvmfs_server publish` process and allows for both online and
# failure debugging.
#
# To allow for online debugging, export CVMFS_TEST_SRVDEBUG like so:
#
# `export CVMFS_TEST_SRVDEBUG=fail`    - for crash debugging with gdb
# `export CVMFS_TEST_SRVDEBUG=startup` - for interactive debugging with gdb


CVMFS_TEST_DEBUGLOG=${CVMFS_TEST_DEBUGLOG:=}
CVMFS_TEST_PROXY=${CVMFS_TEST_PROXY:=http://ca-proxy.cern.ch:3128}
CVMFS_TEST_SCRATCH=${CVMFS_TEST_SCRATCH:=/tmp/cvmfs-test}
CVMFS_TEST_EXCLUDE=${CVMFS_TEST_EXCLUDE:=}
CVMFS_TEST_SYSLOG_FACILITY=${CVMFS_TEST_SYSLOG_FACILITY:=5}
CVMFS_TEST_SYSLOG_TARGET=${CVMFS_TEST_SYSLOG_TARGET:=/var/log/cvmfs-testing.log}

CVMFS_TEST_REPO=${CVMFS_TEST_REPO:=test.cern.ch}
CVMFS_TEST_REPO_MORE=${CVMFS_TEST_REPO_MORE:=test-more.cern.ch}
CVMFS_TEST_USER=${CVMFS_TEST_USER:=sftnight}   # user and group are used to over-
CVMFS_TEST_GROUP=${CVMFS_TEST_GROUP:=sftnight} # write the owner of files for testing

CVMFS_TEST_UNIONFS=${CVMFS_TEST_UNIONFS:=} # union filesystem type to test
CVMFS_TEST_SRVDEBUG=${CVMFS_TEST_SRVDEBUG:=}
CVMFS_TEST_HASHALGO=${CVMFS_TEST_HASHALGO:=sha1}
CVMFS_TEST_S3_CONFIG=${CVMFS_TEST_S3_CONFIG:=}
CVMFS_TEST_STRATUM0=${CVMFS_TEST_STRATUM0:=}
CVMFS_TEST_SERVER_CACHE=${CVMFS_TEST_SERVER_CACHE:=}

# These OPT variables are for the benchmark options under the benchmarks folder
CVMFS_OPT_WARM_CACHE=${CVMFS_OPT_WARM_CACHE:=yes}
CVMFS_OPT_ITERATIONS=${CVMFS_OPT_ITERATIONS:=1}
CVMFS_OPT_TEST_TYPE=${CVMFS_OPT_TEST_TYPE:=callgrind} # callgrind / memcheck
CVMFS_OPT_CONFIG_FILE=${CVMFS_OPT_CONFIG_FILE:=}
CVMFS_OPT_OUTPUT_DIR=${CVMFS_OPT_OUTPUT_DIR:=/tmp/cvmfs_benchmarks}
CVMFS_OPT_CACHEDIR=${CVMFS_OPT_CACHEDIR:=/var/lib/cvmfs/benchmark}
CVMFS_OPT_MTAB_MODIFIED="false"

die() {
  echo -e $1 >&2
  exit 1
}


# Find the service binary (or detect systemd)
SERVICE_BIN="false"
if ! pidof systemd > /dev/null 2>&1 || [ $(pidof systemd) -ne 1 ]; then
  if [ -x /sbin/service ]; then
    SERVICE_BIN="/sbin/service"
  elif [ -x /usr/sbin/service ]; then
    SERVICE_BIN="/usr/sbin/service" # Ubuntu
  elif [ -x /sbin/rc-service ]; then
    SERVICE_BIN="/sbin/rc-service" # OpenRC
  else
    die "Neither systemd nor service binary detected"
  fi
fi

is_systemd() {
  [ x"$SERVICE_BIN" = x"false" ]
}

# find the name of the httpd service


# figure out the installed apache platform
if which httpd2 >/dev/null 2>&1; then #SLES/OpenSuSE
  APACHE_SERVICE="apache2"
  APACHE_CONF=${APACHE_SERVICE}
  APACHE_BIN=$(which httpd2)
elif which apache2 >/dev/null 2>&1; then # Debian based
  APACHE_SERVICE="apache2"
  APACHE_CONF=${APACHE_SERVICE}
  APACHE_BIN=$(which apache2)
else
  APACHE_SERVICE="httpd" # EL based
  APACHE_CONF=${APACHE_SERVICE}
  APACHE_BIN="/usr/sbin/httpd"
fi

normalize_version() {
  local version_string="$1"
  while [ $(echo "$version_string" | grep -o '\.' | wc -l) -lt 2 ]; do
    version_string="${version_string}.0"
  done
  echo "$version_string"
}

version_major() { echo $1 | cut --delimiter=. --fields=1; }
version_minor() { echo $1 | cut --delimiter=. --fields=2; }
version_patch() { echo $1 | cut --delimiter=. --fields=3; }
prepend_zeros() { printf %05d "$1"; }
compare_versions() {
  local lhs="$(normalize_version $1)"
  local comparison_operator=$2
  local rhs="$(normalize_version $3)"

  local lhs1=$(prepend_zeros $(version_major $lhs))
  local lhs2=$(prepend_zeros $(version_minor $lhs))
  local lhs3=$(prepend_zeros $(version_patch $lhs))
  local rhs1=$(prepend_zeros $(version_major $rhs))
  local rhs2=$(prepend_zeros $(version_minor $rhs))
  local rhs3=$(prepend_zeros $(version_patch $rhs))

  [ $lhs1$lhs2$lhs3 $comparison_operator $rhs1$rhs2$rhs3 ]
}

service_request() {
  local service_name=$1
  local request_verb=$2
  if is_systemd; then
    sudo systemctl $request_verb $service_name
  else
    sudo $SERVICE_BIN $service_name $request_verb
  fi
}

# ensures that a generic service is running
# @param service  the name of the service
# @param state    the desired state of the service (on|off)
# @return         0 on success
service_switch() {
  local service_name=$1
  local state=$2

  case $state in
    on)
      echo "starting $service_name..."
      service_request $service_name start || return 100
      ;;
    off)
      echo "stopping $service_name..."
      service_request $service_name stop || return 101
      ;;
    restart)
      echo "restarting $service_name..."
      service_request $service_name restart || return 102
      ;;
    *)
      echo "unrecognized state switching for $service_name"
      return 102
  esac

  return 0
}


# checks if a service needs to be switched on or off
# @param desired_state  the state the service should be switched to
# @param state          the state the service is currently in
# @return  0 if a switch is needed
service_should_switch() {
  local desired_state=$1
  local state=$2
  if [ $state -eq 0 ]; then # is running and...
    if [ "$desired_state" = "off" ]; then # should be switched off
      return 0
    fi
  else                 # is NOT running and...
    if [ "$desired_state" = "on" ]; then # should be switched on
      return 0
    fi
  fi

  return 1
}


# checks if autofs is running on /cvmfs
# @return   0 when autofs is mounted on /cvmfs
autofs_check() {
  cat /proc/mounts | grep -q "^/etc/auto.cvmfs /cvmfs "
}


# ensures that autofs is on or off
# @param state   the desired state of autofs (on|off)
# @return        0 on success
autofs_switch() {
  autofs_check
  if service_should_switch $1 $?; then
    service_switch autofs $1
  fi
}


# switches apache on or off
# @param state   the desired state of autofs (on|off)
# @return        0 on success
apache_switch() {
  service_request $APACHE_SERVICE status > /dev/null 2>&1
  if service_should_switch $1 $?; then
    service_switch $APACHE_SERVICE $1
  fi
}


contains() {
  local haystack="$1"
  local needle=$2

  for elem in $haystack
  do
    if [ $(readlink --canonicalize $elem) = $(readlink --canonicalize $needle) ]; then
      return 0
    fi
  done

  return 1
}


cvmfs_clean() {
  sudo cvmfs_config umount > /dev/null || return 100
  sudo sh -c "rm -rf /var/lib/cvmfs/*"
  sudo rm -f /etc/cvmfs/default.local
  sudo sh -c "rm -f /etc/cvmfs/config.d/*"
  sudo sh -c "cat /dev/null > $CVMFS_TEST_SYSLOG_TARGET"

  timeout=60
  while $(pgrep -u cvmfs cvmfs2 > /dev/null); do
    if [ $timeout -eq 0 ]; then
      return 101
    fi
    timeout=$(($timeout-1))
    sleep 1
  done

  return 0
}


cvmfs_mount() {
  repositories=$1
  shift 1

  sudo sh -c "echo \"CVMFS_REPOSITORIES=$repositories\" > /etc/cvmfs/default.local" || return 100
  sudo sh -c "echo \"CVMFS_HTTP_PROXY=\\\"${CVMFS_TEST_PROXY}\\\"\" >> /etc/cvmfs/default.local" || return 100
  sudo sh -c 'echo "CVMFS_TIMEOUT=20" >> /etc/cvmfs/default.local' || return 100
  sudo sh -c 'echo "CVMFS_TIMEOUT_DIRECT=20" >> /etc/cvmfs/default.local' || return 100
  sudo sh -c 'echo "CVMFS_SERVER_URL=http://cvmfs-atlas-nightlies.cern.ch/cvmfs/atlas-nightlies.cern.ch" > /etc/cvmfs/config.d/atlas-nightlies.cern.ch.local' || return 100
  sudo sh -c "echo CVMFS_SYSLOG_FACILITY=$CVMFS_TEST_SYSLOG_FACILITY >> /etc/cvmfs/default.local" || return 100

  # add additional parameters
  while [ $# -gt 0 ]; do
    local param="$1"
    sudo sh -c "echo \"$1\" >> /etc/cvmfs/default.local" || return 100
    shift 1
  done

  if [ "x$CVMFS_TEST_DEBUGLOG" != "x" ]; then
    sudo sh -c "echo \"CVMFS_DEBUGLOG=$CVMFS_TEST_DEBUGLOG\" >> /etc/cvmfs/default.local" || return 100
  fi
  cvmfs_config probe > /dev/null 2>&1 || return 101

  return 0
}


cvmfs_umount() {
  repositories=$1

  for r in $(echo $repositories | tr , " "); do
    sudo umount /cvmfs/$r
    local result=$?
    if [ $result -ne 0 ]; then
      lsof /cvmfs/$r
      return 200
    fi

    timeout=5
    while cat /proc/mounts | grep -q " /cvmfs/$r "; do
      if [ $timeout -eq 0 ]; then
        return 101
      fi
      timeout=$(($timeout-1))
      sleep 1
    done
  done

  return 0
}


has_selinux() {
  [ -f /selinux/enforce ] && [ $(cat /selinux/enforce) -ne 0 ]
}


get_cvmfs_cachedir() {
  repository=$1

  local cache_dir
  cache_dir=$(cvmfs_config showconfig $repository | grep CVMFS_CACHE_DIR | awk '{print $1}' | cut -d= -f2)
  if [ "x$cache_dir" = "x" ]; then
    echo "Failed to figure out cache directory"
    exit 1
  fi
  echo $cache_dir
}


CVMFS_MEMORY_WARNING_FLAG=0
CVMFS_TIME_WARNING_FLAG=0
CVMFS_GENERAL_WARNING_FLAG=0
CVMFS_MEMORY_WARNING=254
CVMFS_TIME_WARNING=253
CVMFS_GENERAL_WARNING=252
mangle_test_retval() {
  local prior_retval=$1

  # if the test case failed... report the retval right away
  if [ $prior_retval -ne 0 ]; then
    return $prior_retval
  fi

  # check if the test case produced memory warnings and report them
  if [ $CVMFS_MEMORY_WARNING_FLAG -ne 0 ]; then
    return $CVMFS_MEMORY_WARNING
  fi

  # check if the test case produced timeout warnings
  if [ $CVMFS_TIME_WARNING_FLAG -ne 0 ]; then
    return $CVMFS_TIME_WARNING
  fi

  # check if the test case produced any other warnings
  if [ $CVMFS_GENERAL_WARNING_FLAG -ne 0 ]; then
    return $CVMFS_GENERAL_WARNING
  fi

  # return 0 if all is good
  return 0
}

reset_test_warning_flags() {
  CVMFS_MEMORY_WARNING_FLAG=0
  CVMFS_TIME_WARNING_FLAG=0
  CVMFS_GENERAL_WARNING_FLAG=0
}


check_time() {
  start_time=$1
  end_time=$2
  limit=$3

  diff_time=$(($end_time-$start_time))

  if [ $diff_time -gt $limit ]; then
    echo "Time limit exceeded" >&2
    echo "Limit was $limit but it took $diff_time seconds"
    CVMFS_TIME_WARNING_FLAG=1
    return 100
  fi

  return 0
}


check_memory() {
  instance=$1
  limit=$2

  pid=$(attr -qg pid /cvmfs/$instance)             || return 100
  rss="$(sudo cat /proc/$pid/status | grep VmRSS)" || return 101
  rss_kb=$(echo $rss | awk '{print $2}')

  if [ $rss_kb -gt $limit ]; then
    local inode_tracker="$(sudo cvmfs_talk -i $instance internal affairs | grep 'inode tracker')"
    local inserts=$(echo "$inode_tracker" | grep -o "inserts: [0-9]*" | grep -o "[0-9]*$")
    local removes=$(echo "$inode_tracker" | grep -o "removes: [0-9]*" | grep -o "[0-9]*$")
    local elements=$(( $inserts - $removes ))

    echo "Memory limit of $limit kB was exceeded by $instance which used $rss_kb kB"
    echo "We've had $elements items in the inode tracker"
    echo "Output of cat /proc/$pid/status:"
    sudo cat /proc/$pid/status 2>&1
    CVMFS_MEMORY_WARNING_FLAG=1

    return 102
  fi

  return 0
}


min() {
  [ $1 -lt $2 ] && echo $1 || echo $2
}


destroy_repo() {
  local repo=$1
  sudo cvmfs_server rmfs -f $repo || return 100
}


has_repo() {
  local repo=$1
  cvmfs_server list 2>/dev/null | grep -q "^$repo "
}


create_repo() {
  local repo=$1
  local uid=$2
  local debug_log=$3
  shift $(min $# 3)
  local extra_options="$*"

  echo "Shutting down autofs for the cvmfs mounts"
  autofs_switch off || return 100

  if has_repo $repo; then
    echo "Repository $repo is already present... removing it"
    destroy_repo $repo || return 101
  fi

  echo "Creating new repository $repo..."
  local s3_config=""
  local stratum0=""
  local unionfs=""
  if [ x"$CVMFS_TEST_S3_CONFIG" != x"" ]; then
    echo "  S3 Config: $CVMFS_TEST_S3_CONFIG"
    s3_config=" -s $CVMFS_TEST_S3_CONFIG"
  fi
  if [ x"$CVMFS_TEST_STRATUM0" != x"" ]; then
    echo "  Stratum0: $CVMFS_TEST_STRATUM0"
    stratum0=" -w $CVMFS_TEST_STRATUM0"
  fi
  if [ x"$CVMFS_TEST_UNIONFS" != x"" ]; then
    echo "  UnionFS: $CVMFS_TEST_UNIONFS"
    unionfs=" -f $CVMFS_TEST_UNIONFS"
  fi
  sudo cvmfs_server mkfs -o $uid -m                \
                         -a ${CVMFS_TEST_HASHALGO} \
                         $s3_config                \
                         $stratum0                 \
                         $unionfs                  \
                         $extra_options $repo || return 102

  local client_conf="/etc/cvmfs/repositories.d/${repo}/client.conf"

  if [ x"$CVMFS_TEST_SERVER_CACHE" != x"" ]; then
    local cache_base=$(echo "$CVMFS_TEST_SERVER_CACHE" | sed 's/\//\\\//g')
    # will take effect _after_ the first publish operation...
    sudo sed -i "s/^CVMFS_CACHE_BASE=.*\$/CVMFS_CACHE_BASE=${cache_base}/"         $client_conf
    sudo sed -i "s/^CVMFS_RELOAD_SOCKETS=.*\$/CVMFS_RELOAD_SOCKETS=${cache_base}/" $client_conf
  fi

  if [ x$debug_log != x -a x$debug_log != xNO ]; then
    echo "CVMFS_DEBUGLOG=$debug_log" | sudo tee -a $client_conf
  fi
}


create_empty_repo() {
  local repo=$1
  local uid=$2
  local debug_log=$3
  shift $(min $# 3)
  local extra_options="$*"

  create_repo $repo $uid $debug_log "$extra_options" || return 101

  sudo cvmfs_server transaction $repo || return 102
  rm -f /cvmfs/$repo/new_repository
  sudo cvmfs_server publish $repo || return 103
}


# creates a cvmfs repository and fills it with some dummy data
#
# @param repo_name   the name of the repository to create
# @param uid         the user id of the new repository's owner
create_filled_repo() {
  local repo=$1
  local uid=$2
  local debug_log=$3

  create_empty_repo $repo $uid $debug_log || return 101

  sudo cvmfs_server transaction $repo || return 102

  pushdir /cvmfs/$repo

  echo "meaningless file content" > file
  echo "more clever file content" > clever
  ln file hardlinkToFile
  ln -s clever symlinkToClever

  mkdir -p foo/bar/baz
  mkdir -p bar/foo/baz
  touch foo/.cvmfscatalog

  # Put some meaningful stuff into files
  echo "Vom Eise befreit sind Strom und Bäche"         > foo/bar/verse1
  echo "Durch des Frühlings holden, belebenden Blick," > foo/bar/verse2
  echo "Im Tale grünet Hoffnungsglück;"                > foo/bar/verse3
  echo "Der alte Winter, in seiner Schwäche,"          > foo/bar/verse4
  echo "Zog sich in rauhe Berge zurück."               > foo/bar/verse5

  popdir

  sudo cvmfs_server publish $repo || return 103
}


# generates a huge dummy repository content with 500.000 directory entries
# in a somewhat representative directory structure
#
# @param  repo_dir   where to put the dummy dirents
make_huge_repo() {
  local repo_dir=$1
  python ${TEST_ROOT}/common/mock_services/make_repo.py \
    --max-dir-depth        7                     \
    --num-subdirs          5                     \
    --num-files-per-dir    5                     \
    --min-file-size        0                     \
    --max-file-size     5120                     \
    $repo_dir
}


create_stratum1() {
  local replica_name=$1
  local uid=$2
  local stratum0_url=$3
  local stratum0_pub=$4
  shift 4
  local additional_parameters="$*"
  local s3_config=""
  # TODO: Re-enable this as soon as Stratum1 is supported
  #       with an S3 backend
  # if [ x"$CVMFS_TEST_S3_CONFIG" != x"" ]; then
  #   echo "  S3 Config: $CVMFS_TEST_S3_CONFIG"
  #   s3_config=" -s $CVMFS_TEST_S3_CONFIG"
  # fi
  sudo cvmfs_server add-replica -o $CVMFS_TEST_USER    \
                                -n $replica_name       \
                                -a                     \
                                $s3_config             \
                                $additional_parameters \
                                $stratum0_url          \
                                $stratum0_pub
}

# creates a big file at a given location with a given size
# @param path  the location of the new file
# @param size  the desired size in megabytes
create_big_file() {
  local path=$1
  local size=$2

  dd if=/dev/zero of=$path bs=1024k count=$size
}


# generate a custom style recursive listing with only the following infos:
# - file name
# - linkcount
# - file mode
# - file size
# - parent directory
# - symlink destination (when applicable)
# - uid and gid can be specified
#
# @param directory          the directory to be listed
# @param uid                specify a UID for the file owner (optional)
# @param gid                specify a GID for the file owner (optional)
# @return                   a custom directory listing
create_listing() {
  local directory=$1
  local uid=$2
  local gid=$3
  local lst

  lst=$(ls --almost-all --recursive -l --file-type --time-style=+ $directory | \
  awk '
  {
    # skip the total file count, ls prints at the end of each directory listing
    if(substr($1, 0, 5) == "total") next;

    # length of base directory path
    base_dir_length = length(base_dir)

    # truncate base path from the path printed before each new listing
    if(substr($0, 0, base_dir_length) == base_dir) {
      print substr($0, base_dir_length + 1, length($0)-1)
      next;
    }

    # first character
    first = substr($0, 0, 1);

    # print file meta information
    # $1    => file mode (rwx bits, ...)
    # $2    => linkcount
    # $3,$4 => owner, group (might also be provided from outside)
    # $5    => file size (skipped for directories)
    # $6    => file name
    # $7,$8 => symlink destination (only for symlinks :o) )

    if (first != "-" && first != "d" && first != "l")
    {
      printf "\n"
      next;
    }

    # print out file information
    printf $1                     " ";
    printf $2                     " ";
    printf (uid == "" ? $3 : uid) " ";
    printf (gid == "" ? $4 : gid) " ";
    printf $6;

    if(first == "l") printf " " $7 " " $8;
    if(first != "d") printf " " $5;
    printf "\n"
  }' uid=$uid gid=$gid base_dir=$directory)

  echo -e "$lst"
}

# compares the file contents and file meta data of two directories
# Note: function creates the files 'listingFile1' and 'listingFile2' in `pwd`
#       `pwd` should NOT be part of the comparison!!
#
# @param dir1    the directory to probe
# @param dir2    the ground truth directory
# @return        != 0 to indicate inequality, 0 means success
compare_directories() {
  local dir1=$1
  local dir2=$2

  listing1=$(create_listing $dir1)
  listing2=$(create_listing $dir2)

  echo "check if directory structure and file meta data fits"
  local listingFile1="listing_$(basename $dir1)"
  local listingFile2="listing_$(basename $dir2)"
  echo -e "$listing1" > $listingFile1
  echo -e "$listing2" > $listingFile2
  diff -uN $listingFile1 $listingFile2 2>&1 || return 101

  echo "check if the file contents in both directories are the same"
  diff -ruN $dir1 $dir2 2>&1 || return 102

  return 0
}


# run a binary in the background and return it's PID through stdout
#
# @param logfile  a path to a logfile for outputs of the started program
# @return         the process ID of the created background service
run_background_service() {
  local logfile=$1
  shift 1

  local srv_pid

  # shell for the win!
  # This spawns a shell executing the passed command string (sudo sh -c) which
  # will print it's PID (echo $$) into a fifo and execute the user defined
  # binary redirecting its outputs into the logfile (exec $@ >> $logfile 2>&1).
  # Furthermore it disconnects the new process from the executing shell (nohup),
  # satisfies the I/O requirements of nohup (2>&1 < /dev/null) and sends it to
  # the background (&)
  #   Credit: Dario Berzano helped with that monster!
  local fifo="pid_fifo"
  mkfifo $fifo || return 1
  nohup sh -c "echo \$\$ > $fifo; exec $@ >> $logfile 2>&1" 2>&1 < /dev/null &
  srv_pid=$(cat $fifo)
  rm -f $fifo

  # check if the background process is running
  if ! sudo kill -0 $srv_pid > /dev/null 2>&1; then
    return 4
  fi

  # print the PID of the background process and return successfully
  echo $srv_pid
  return 0
}


# open a port for incoming connections. It will accept the connection but stay
# silent on it
#
# Note: The user is responsible for killing the created server process after
#       usage
#
# @param protocol  either UDP or TCP
# @param port      the desired port number to be opened
# @param logfile   a path to the logfile where connection logs should be written
# @return          the process ID of the created server script
open_silent_port() {
  local protocol=$1
  local port=$2
  local logfile=$3
  local pid
  local cmd
  local retcode

  cmd="sudo python ${TEST_ROOT}/common/mock_services/silent_socket.py $protocol $port"
  pid=$(run_background_service $logfile "$cmd")
  retcode=$?

  if [ $retcode -ne 0 ]; then
    return $retcode
  fi

  echo $pid
  return $retcode
}


# checks if a nested catalog is part of the current catalog configuration
# of the repository
# @param catalog_path  the catalog root path to be checked
# @param repo_name     the repository to be checked
check_catalog_presence() {
  local catalog_path=$1
  local repo_name=$2

  cvmfs_server list-catalogs -x $repo_name | grep -x -q $catalog_path
  return $?
}

# counts the number of present catalogs in the repository
# @param repo_name  the name of the repository to investigate
# @return           the number of found catalogs
get_catalog_count() {
  local repo_name=$1

  echo $(cvmfs_server list-catalogs -x $repo_name | wc -l)
}

# retrieves the hash of the current root catalog of the given
# repository by investigating the manifest
# @param repo_name  the name of the repository
# @return           the current root catalog hash
get_current_root_catalog() {
  local repo_name=$1
  local manifest_url="$(get_repo_url $repo_name)/.cvmfspublished"
  local catalog_record=$(curl "$manifest_url" 2>/dev/null | grep --text '^C[a-f0-9]*\(-[a-z0-9]*\)\?$')
                                                                        # ^^~~~~~~~^ ^~~~~~~~~~~~^
                                                                        # ||       | |           |
                                                                        # ||       | +-----------+-- (optional) Hash Suffix
                                                                        # |+-------+---------------- Hash String
                                                                        # +------------------------- Manifest Field Identifier
  local characters=$(echo -n $catalog_record | wc -c)
  echo -n $catalog_record | tail -c $(( $characters - 1 ))
}

# uses `cvmfs_server check` to check the integrity of the catalog structure
# additionally it might check the backend storage integrity as well when
# provided with -i
# @param repo    the repository to be checked
check_repository() {
  local repo=$1
  shift 1

  cvmfs_server check $@ $repo || return 100
  return 0
}

# wrapper function to start a new repository update transaction
# @param repo    the repository you want to start the transaction for
start_transaction() {
  local repo=$1

  cvmfs_server transaction $repo || return 100
  return 0
}

# wrapper function to abort a transaction
# @param repo    the repository you want to abort a transaction on
abort_transaction() {
  local repo=$1

  cvmfs_server abort -f $repo || return 100
  return 0
}

# wrapper function to rollback a repository to a specified tag
#
# @param repo   the repository you want to rollback
# @param tag    the name of the tag to be rollbacked to
rollback_repo() {
  local repo=$1
  local tag=$2

  cvmfs_server rollback -t $tag -f $repo || return 100
  return 0
}

# wrapper function to publish an repository after its contents were updated.
# @param repo    the repository name to start the transaction in
publish_repo() {
  local repo=$1
  shift 1

  # parse the command line arguments (keep quotation marks)
  args="-v"
  while [ $# -gt 0 ]; do
    if echo "$1" | grep -q "[[:space:]]"; then
      args="$args \"$1\""
    else
      args="$args $1"
    fi
    shift 1
  done

  # enable the debug mode?
  # in debug mode we redirect output directly to the interactive shell,
  # overriding any redirections to logfiles or whatever... We want to hack!
  case $CVMFS_TEST_SRVDEBUG in
    fail)
      cvmfs_server publish -d $args $repo > /dev/tty 2>&1 || return 100
    ;;
    startup)
      cvmfs_server publish -D $args $repo > /dev/tty 2>&1 || return 100
    ;;
    *)
      cvmfs_server publish $args $repo || return 100
    ;;
  esac

  return 0
}


# sources the repository server configuration file for the given repo name
# @param name  the name of the repository to load the configs for
load_repo_config() {
  local name=$1
  local conf_dir="/etc/cvmfs/repositories.d/${name}"
  [ ! -f "${conf_dir}/server.conf" ] || . ${conf_dir}/server.conf
  [ ! -f "${conf_dir}/client.conf" ] || . ${conf_dir}/client.conf
}


# runs the given command and measures the time it took to execute
stop_watch() {
  begin=$(date +%s)
  cmd="$@"
  $cmd
  res=$?
  end=$(date +%s)
  echo $((end - begin))
  return $res
}


# wrapper around pushd (that is not available in dash)
# if pushd is not available, a normal `cd` is used
# Note: We do not reimplement the whole functionality of pushd, with our work-
#       around it is only possible to have ONE directory-level stored
pushdir() {
  type pushd > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    pushd $1
    return $?
  else
    cd $1
    return $?
  fi
}


# wrapper around popd (that is not available in dash)
# if popd is not available, a normal `cd -` is used to go back to the last dir
# Note: We do not reimplement the whole functionality of popd, with our work-
#       around it is only possible to have ONE directory-level stored
popdir() {
  type popd > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    popd $1
    return $?
  else
    cd -
    return $?
  fi
}


# retrieves the apache version string "2.x.xx"
get_apache_version() {
  ${APACHE_BIN} -v | head -n1 | \
    sed 's/^Server version: Apache\/\([0-9]\+\.[0-9]\+\.[0-9]\+\).*$/\1/'
}


# figure out apache config file mode
#
# @return   apache config mode (stdout) (see globals below)
APACHE_CONF_MODE_OLD=1 # *.conf goes to ${APACHE_CONF}/conf.d
APACHE_CONF_MODE_NEW=2 # *.conf goes to ${APACHE_CONF}/conf-available
get_apache_conf_mode() {
  local minor_apache_version=$(version_minor "$(get_apache_version)")
  if [ $minor_apache_version -ge 4 ] || [ -d /etc/${APACHE_CONF}/conf-available ]; then
    echo $APACHE_CONF_MODE_NEW
  else
    echo $APACHE_CONF_MODE_OLD
  fi
}


# find location of apache configuration files
#
# @return   the location of apache configuration files (stdout)
get_apache_conf_path() {
  local res_path="/etc/${APACHE_CONF}"
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    echo "${res_path}/conf-available"
  else
    echo "${res_path}/conf.d"
  fi
}


# returns the apache configuration string for 'allow from all'
# Note: this is necessary, since apache 2.4.x formulates that different
#
# @return   a configuration snippet to allow s'th from all hosts (stdout)
get_compatible_apache_allow_from_all_config() {
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    echo "Require all granted"
  else
    local nl='
'
    echo "Order allow,deny${nl}    Allow from all"
  fi
}


# writes apache configuration file
# This figures out where to put the apache configuration file depending
# on the running apache version
# Note: Configuration file content is expected to come through stdin
#
# @param   file_name  the name of the apache config file (no path!)
# @return             0 on success
create_apache_config_file() {
  local file_name=$1
  local conf_path
  conf_path="$(get_apache_conf_path)"

  # create (or append) the conf file
  cat - | sudo tee ${conf_path}/${file_name} > /dev/null || return 1

  # the new apache requires the enable the config afterwards
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    sudo a2enconf $file_name > /dev/null || return 2
  fi

  return 0
}


# removes apache config files dependent on the apache version in place
# Note: As of apache 2.4.x `a2disconf` needs to be called before removal
#
# @param   file_name  the name of the conf file to be removed (no path!)
# @return  0 on successful removal
remove_apache_config_file() {
  local file_name=$1
  local conf_path
  conf_path="$(get_apache_conf_path)/${file_name}"

  # disable configuration on newer apache versions
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    sudo a2disconf $file_name > /dev/null 2>&1 || return 1
  fi

  # remove configuration file
  sudo rm -f $conf_path
}


get_local_repo_storage() {
  local repo_name="$1"
  echo "/srv/cvmfs/${repo_name}"
}

get_local_repo_url() {
  local repo_name="$1"
  echo "http://localhost/cvmfs/${repo_name}"
}

get_s3_repo_url() {
  local repo_name="$1"
  local s3_stratum0_url="$CVMFS_TEST_STRATUM0"
  [ x"$s3_stratum0_url" != x"" ] || die "\$CVMFS_TEST_STRATUM0 needs to be set for S3 tests to work!"
  [ $(echo -n "$s3_stratum0_url" | tail -c1) = "/" ] || s3_stratum0_url="${s3_stratum0_url}/"
  echo "${s3_stratum0_url}${repo_name}"
}

get_repo_url() {
  local repo_name="$1"
  if [ x"$CVMFS_TEST_S3_CONFIG" != x"" ]; then
    get_s3_repo_url "$repo_name"
  else
    get_local_repo_url "$repo_name"
  fi
}

get_object_url() {
  local repo_name="$1"
  local object_hash="$2"
  local repo_url="$(get_repo_url $repo_name)"
  local object_path="$(echo -n $object_hash | sed -e 's/^\(..\)\(.*\)$/\1\/\2/')"
  echo "${repo_url}/data/${object_path}"
}

get_apache_config_filename() {
  local repo_name="$1"
  echo "${repo_name}.conf"
}


cleanup_legacy_repo_leftovers() {
  local legacy_repo_name="$1"
  local legacy_repo_storage="$(get_local_repo_storage $legacy_repo_name)"
  local apache_config_file="$(get_apache_config_filename $legacy_repo_name)"

  echo -n "cleanup (if necessary)... "
  has_repo $legacy_repo_name && die "fail"
  if [ -d $legacy_repo_storage ]; then
    sudo rm -fR $legacy_repo_storage
  fi
  if [ -f /etc/cvmfs/keys/${legacy_repo_name}.crt ] || \
     [ -f /etc/cvmfs/keys/${legacy_repo_name}.pub ] || \
     [ -f /etc/cvmfs/keys/${legacy_repo_name}.key ] || \
     [ -f /etc/cvmfs/keys/${legacy_repo_name}.masterkey ]; then
    sudo rm -f /etc/cvmfs/keys/${legacy_repo_name}.*
  fi
  remove_apache_config_file $apache_config_file
  echo "done"
}


# resigns a freshly planted legacy repository (see plant_legacy_repo())
# Note: This expects a matching keychain in /etc/keys/{$repo_name}
# @param repo_name  the FQRN of the legacy repository to be resigned
_resign_legacy_repository() {
  local repo_name="$1"
  local repo_storage="$(get_local_repo_storage $repo_name)"
  local legacy_repo_storage="${repo_storage}/pub/catalogs"
  local tmp_dir="$(pwd)/tmp"
  local upstream="local,${legacy_repo_storage}/data/txn,${legacy_repo_storage}"

  mkdir -p $tmp_dir || return 1

  # recreate whitelist
  local whitelist=${tmp_dir}/whitelist.${repo_name}
  echo `date -u "+%Y%m%d%H%M%S"` > ${whitelist}.unsigned
  echo "E`date -u --date='next month' "+%Y%m%d%H%M%S"`" >> ${whitelist}.unsigned
  echo "N$repo_name" >> ${whitelist}.unsigned
  openssl x509 -fingerprint -sha1 -in /etc/cvmfs/keys/${repo_name}.crt | grep "SHA1 Fingerprint" | sed 's/SHA1 Fingerprint=//' >> ${whitelist}.unsigned
  local hash;
  hash=`openssl sha1 < ${whitelist}.unsigned | tr -d '\n' | tail -c40`
  echo "--" >> ${whitelist}.unsigned
  echo $hash >> ${whitelist}.unsigned
  echo -n $hash > ${whitelist}.hash
  openssl rsautl -inkey /etc/cvmfs/keys/${repo_name}.masterkey -sign -in ${whitelist}.hash -out ${whitelist}.signature
  cat ${whitelist}.unsigned ${whitelist}.signature | sudo tee ${legacy_repo_storage}/.cvmfswhitelist > /dev/null
  rm -f ${whitelist}.unsigned ${whitelist}.signature ${whitelist}.hash
}


# extracts a tarball into the root directory!
# Note: it expects the tarball to define the full destination path.
# @param tarball  the path to the tarball to be planted
# @param verbose  print the verbose output of tar
plant_tarball() {
  local tarball="$1"
  local verbose="$2"
  local olddir="$(pwd)"
  local tar_params="xzf"

  if [ x"$verbose" != x"" ]; then
    tar_params="${tar_params}v"
  fi

  cd /                          || return 101
  sudo tar $tar_params $tarball || return 102
  cd $olddir                    || return 103
}


# extracts a legacy repository contained in a tarball.
# Note: This expects the tarball to define the full destination path. Furthermore
#       it expects a repo keychain to be planted in /etc/keys/${legacy_repo_name}
# @param tarball           path to the tarball containing the legacy repo
# @param legacy_repo_name  FQRN of the repository to be planted
# @param verbose           print verbose output
plant_legacy_repository_revision() {
  local tarball="$1"
  local legacy_repo_name="$2"
  local verbose="$3"
  local legacy_repo_storage="$(get_local_repo_storage $legacy_repo_name)"

  plant_tarball "$tarball" "$verbose"                                  || return 104
  [ -d ${legacy_repo_storage}/pub ]                                    || return 105
  [ -f ${legacy_repo_storage}/pub/catalogs/.cvmfscatalog ]             || return 106
  [ -f ${legacy_repo_storage}/pub/catalogs/.cvmfswhitelist ]           || return 107
  sudo touch ${legacy_repo_storage}/pub/catalogs/.cvmfs_master_replica || return 108
  _resign_legacy_repository "$legacy_repo_name"                        || return 109
}


# creates a path into the CAS of CVMFS server
#
# @param content_hash   the content hash to be checked
make_path() {
  local content_hash="$1"
  local characters=$(echo -n $content_hash | wc -c)
  local head_cnt=2
  local tail_cnt=$(( $characters - $head_cnt ))
  echo "data/$(echo -n $content_hash | head -c $head_cnt)/$(echo -n $content_hash | tail -c $tail_cnt)"
}


# peeks in the upstream storage to find a given content hash
#
# @param repository     the repository name to be queried
# @param content_hash   the content has to be checked for availability
# @return 0             on successfully found object
peek_backend() {
  local repo_name="$1"
  local content_hash="$2"
  local remote_path=$(make_path $content_hash)

  load_repo_config $repo_name
  cvmfs_swissknife peek -d $remote_path -r $CVMFS_UPSTREAM_STORAGE
}


# switches on/off the garbage collection for a given repository
#
# @param name  the name of the repository to be changed
# @return      0 return code on success
toggle_gc() {
  local name=$1
  local cfg_file="/etc/cvmfs/repositories.d/${name}/server.conf"
  local tmp_file="$(mktemp)"

  local value="$(cat $cfg_file | grep 'CVMFS_GARBAGE_COLLECTION' | sed -e 's/.*=\([a-z]\+\)/\1/')"
  local new_value="true"
  [ x"$value" = x"true" ] && new_value="false"

  cat $cfg_file | sed -e "s/\(CVMFS_GARBAGE_COLLECTION\)=[a-z]\+/\1=$new_value/" > $tmp_file
  sudo cp -f $tmp_file $cfg_file || return 1
  rm -f $tmp_file                || return 2
  return 0
}

# disables the automatic garbage collection of a given repository configuration
#
# @param name  the name of the repository to reconfigure
disable_auto_garbage_collection() {
  local name="$1"
  local cfg_file="/etc/cvmfs/repositories.d/${name}/server.conf"

  if cat $cfg_file | grep -q 'CVMFS_AUTO_GC'; then
    local tmp_cfg="$(mktemp)"
    cat $cfg_file | sed -e 's/^\(CVMFS_AUTO_GC\)=.*$/\1=false/' > $tmp_cfg || return 1
    sudo mv -f $tmp_cfg $cfg_file || return 2
  fi
}


# get the current unix timestamp
get_timestamp() {
  date --date='2 seconds ago' +@%s
}

# display a timestamp in human readable form
display_timestamp() {
  local timestamp=$1
  date --date="$timestamp"
}


# copy all content of /bin/* into a given directory (for server testing purposes)
#
# @param destination_directory
cp_bin() {
  local destination_directory="$1"
  sudo cp -R /bin/* $destination_directory  || return 1
  sudo chmod -R a+rw $destination_directory || return 2
  for f in $(find $destination_directory -type f); do
    sudo chmod 0444 $f || return 3
  done
}

# copy all content of /usr/bin/* into a given directory (for server testing purposes)
#
# @param destination_directory
cp_usrbin() {
  local destination_directory="$1"
  sudo cp -R /usr/bin/* $destination_directory || return 1
  sudo chmod -R a+rw $destination_directory    || return 2
  for f in $(find $destination_directory -type f); do
    sudo chmod 0444 $f || return 3
  done
}


# prints a benchmark log message
benchmark_log() {
  local log_message=$1
  echo "===========    ${log_message}"
}


# waits until cvmfs is mounted
wait_fqrn_mount() {
  local waits=0
  while ! mount | grep -q "/cvmfs/${FQRN}"; do
    waits=$(( waits + 1 ))
    if [ "$waits" -ge 60 ]; then
      die "${FQRN} could not be mounted"
    fi
    sleep 1
  done
}


# runs the command once in order to get a warm cache
create_warm_cache() {
  local workspace=$1
  cvmfs2 -f -o config=cvmfs.conf,disable_watchdog,simple_options_parsing $FQRN /cvmfs/$FQRN 2>&1 & #> /dev/null 2>&1 &
  wait_fqrn_mount

  cvmfs_run_benchmark 2>&1
  cvmfs_umount $FQRN
  return 0
}


# creates the default cvmfs.conf file for normal testing
#
# @param destination_file  absolute path of the directory
create_default_cvmfs_config() {
  local destination_directory="$1"
  local config_file=$destination_directory/cvmfs.conf
  local test_folder=$( cd $(dirname $0) ; pwd -P )

  cat > $config_file << EOF
CVMFS_CACHE_BASE=${CVMFS_OPT_CACHEDIR}
CVMFS_RELOAD_SOCKETS=${CVMFS_OPT_CACHEDIR}
CVMFS_SERVER_URL=http://cvmfs-stratum-one.cern.ch/cvmfs/@fqrn@
CVMFS_SHARED_CACHE=no
CVMFS_HTTP_PROXY=${CVMFS_TEST_PROXY}
CVMFS_AUTO_UPDATE=false
CMS_LOCAL_SITE=${test_folder}/benchmarks/004-cms
CVMFS_QUOTA_LIMIT=-1

EOF

}


# sets the valgrind options depending on the test type
#
# @param test_type  concrete test to execute
set_valgrind_options() {
  local CVMFS_OPT_CALLGRIND="--tool=callgrind --dump-before=fuse_session_loop_mt --dump-after=fuse_session_loop_mt --dsymutil=yes --log-file=${FQRN}.callgrind.log -v"
  local CVMFS_OPT_MEMCHECK="--tool=memcheck --xml=yes --xml-file=${FQRN}.memcheck.xml --trace-children=yes --child-silent-after-fork=yes --leak-check=yes --log-file=${FQRN}.memcheck.log -v"
  OPTIONS=""
  case $CVMFS_OPT_TEST_TYPE in
    callgrind)
      OPTIONS=$CVMFS_OPT_CALLGRIND
    ;;
    memcheck)
      OPTIONS=$CVMFS_OPT_MEMCHECK
    ;;
  esac
}


# creates the environment to run the benchmark
#
# @param workspace  absolute path to the directory where the benchmark will put the files in
setup_benchmark_environment() {
  local workspace="$1"
  mkdir -p /cvmfs/$FQRN
  mkdir -p "$CVMFS_OPT_OUTPUT_DIR/$FQRN"
  mkdir -p $workspace/cache

  # cleaning the cache
  local cachedir="${CVMFS_OPT_CACHEDIR}/${FQRN}"
  if [ -d "$cachedir" ] && [ "x$cachedir" != x ]; then
    rm -rf $cachedir/*
  fi

  # mtab trick
  if [ ! -h /etc/mtab ]; then
    mv /etc/mtab /etc/mtab.save
    ln -s /proc/mounts /etc/mtab
    CVMFS_OPT_MTAB_MODIFIED="true"
  fi

  # check that the cache directory exists, is empty and is correctly labeled for SElinux
  if [ ! -d "$CVMFS_OPT_CACHEDIR" ]; then
    mkdir -p "$CVMFS_OPT_CACHEDIR"
    has_selinux
    selinux=$?
    if [ "$selinux" -eq 0 ]; then
      chcon -Rv --type=cvmfs_cache_t $CVMFS_OPT_CACHEDIR
    fi
  else
    if [ x"$CVMFS_OPT_CACHEDIR" != x ]; then
      rm -rf "$CVMFS_OPT_CACHEDIR"/*
    fi
  fi

  # create a cvmfs.conf file or use a custom one
  if [ -z "$CVMFS_OPT_CONFIG_FILE" ]; then
    create_default_cvmfs_config $workspace
  else
    cp -f "$CVMFS_OPT_CONFIG_FILE" $workspace
  fi

  return 0
}


# creates a system.info file file with information about the environment
create_info_file() {
  cat > system.info << EOF
- Operating system:
$(uname -a)


- CernVM-FS version:
$(cvmfs2 --version)


- cvmfs2 executable md5:
$(md5sum $(which cvmfs2))


- CernVM-FS talk:
$(cvmfs_talk -p ${CVMFS_OPT_CACHEDIR}/${FQRN}/cvmfs_io.${FQRN} -i ${FQRN} internal affairs)

EOF

}


# runs a benchmark $CVMFS_OPT_ITERATIONS times
run_benchmark() {
  local count=$CVMFS_OPT_ITERATIONS
  set_valgrind_options

  # use or not warm cache
  if [ x"$CVMFS_OPT_WARM_CACHE" = x"yes" ]; then
    benchmark_log "Starting initial execution"
    create_warm_cache $workspace
  else
    benchmark_log "Using cold cache"
  fi

  benchmark_log "Starting loading the profiler and mounting in /cvmfs/${FQRN}"
  benchmark_log "Running valgrind with the following parameters: $OPTIONS"
  benchmark_log "Launching the job $count times"
  valgrind $OPTIONS cvmfs2 -f -o config=cvmfs.conf,disable_watchdog,simple_options_parsing $FQRN /cvmfs/$FQRN &
  PID=$!
  wait_fqrn_mount

  local iteration=1
  local code=0
  while (( count > 0 && code == 0 )); do
    benchmark_log "Starting iteration ${iteration}"
    cvmfs_run_benchmark
    code=$?
    count=$(( count - 1 ))
    iteration=$(( iteration + 1 ))
  done

  if [ "$code" -eq 0 ]; then
    benchmark_log "Collecting information about the tests..."
    create_info_file
  else
    benchmark_log "Problem executing the tests. Aborting"
    benchmark_log $(lsof /cvmfs/${FQRN})
  fi

  benchmark_log "Iterations finished. Unmounting cvmfs"
  cvmfs_umount $FQRN
  wait $PID
  return $code
}


# collects the files and pastes them into $CVMFS_OPT_OUTPUT_DIR/$FQRN
collect_benchmark_results() {
  local benchmark_output_dir="$CVMFS_OPT_OUTPUT_DIR/$FQRN"

  # undo the mtab trick
  if [ x"$CVMFS_OPT_MTAB_MODIFIED" = x"true" ]; then
    mv /etc/mtab.save /etc/mtab
  fi

  # collect the results
  local workspace=$workdir
  if [ -d "$benchmark_output_dir" ] && [ "x$benchmark_output_dir" != x ]; then
    rm -rf "$benchmark_output_dir"/*
  fi
  cp  -rf $workdir/system.info $workdir/$FQRN.*.log $workdir/callgrind.out.* $workdir/$FQRN.memcheck.xml $workdir/cvmfs.conf $benchmark_output_dir > /dev/null 2>&1
  benchmark_log "Test results copied into $benchmark_output_dir" >> $logfile
}
