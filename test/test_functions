# By default, this script runs in testing mode
# Although it allows for a server debugging mode, which attaches gdb to
# the `cvmfs_server publish` process and allows for both online and
# failure debugging.
#
# To allow for online debugging, export CVMFS_TEST_SRVDEBUG like so:
#
# `export CVMFS_TEST_SRVDEBUG=fail`    - for crash debugging with gdb
# `export CVMFS_TEST_SRVDEBUG=startup` - for interactive debugging with gdb


CVMFS_TEST_DEBUGLOG=${CVMFS_TEST_DEBUGLOG:=}
CVMFS_TEST_PROXY=${CVMFS_TEST_PROXY:=http://ca-proxy.cern.ch:3128}
CVMFS_TEST_SCRATCH=${CVMFS_TEST_SCRATCH:=/tmp/cvmfs-test}
CVMFS_TEST_EXCLUDE=${CVMFS_TEST_EXCLUDE:=}
CVMFS_TEST_SYSLOG_FACILITY=${CVMFS_TEST_SYSLOG_FACILITY:=5}
CVMFS_TEST_SYSLOG_TARGET=${CVMFS_TEST_SYSLOG_TARGET:=/var/log/cvmfs-testing.log}

CVMFS_TEST_REPO=${CVMFS_TEST_REPO:=test.cern.ch}
CVMFS_TEST_REPO_MORE=${CVMFS_TEST_REPO_MORE:=test-more.cern.ch}
CVMFS_TEST_USER=${CVMFS_TEST_USER:=sftnight}   # user and group are used to over-
CVMFS_TEST_GROUP=${CVMFS_TEST_GROUP:=sftnight} # write the owner of files for testing

CVMFS_TEST_UNIONFS=${CVMFS_TEST_UNIONFS:=aufs} # union filesystem type to test
CVMFS_TEST_SRVDEBUG=${CVMFS_TEST_SRVDEBUG:=}
CVMFS_TEST_HASHALGO=${CVMFS_TEST_HASHALGO:=sha1}

die() {
  echo -e $1 >&2
  exit 1
}


# find the service binary
if [ -x /sbin/service ]; then
  service_binary="/sbin/service"
else
  # Ubuntu
  service_binary="/usr/sbin/service"
fi

# find the name of the httpd service


# figure out the installed apache platform
if which httpd2 >/dev/null 2>&1; then #SLES/OpenSuSE
  APACHE_SERVICE="apache2"
  APACHE_CONF=${APACHE_SERVICE}
  APACHE_BIN=$(which httpd2)
elif which apache2 >/dev/null 2>&1; then # Debian based
  APACHE_SERVICE="apache2"
  APACHE_CONF=${APACHE_SERVICE}
  APACHE_BIN=$(which apache2)
else
  APACHE_SERVICE="httpd" # EL based
  APACHE_CONF=${APACHE_SERVICE}
  APACHE_BIN="/usr/sbin/httpd"
fi

version_major() { echo $1 | cut --delimiter=. --fields=1; }
version_minor() { echo $1 | cut --delimiter=. --fields=2; }
version_patch() { echo $1 | cut --delimiter=. --fields=3; }

# ensures that a generic service is running
# @param service  the name of the service
# @param state    the desired state of the service (on|off)
# @return         0 on success
service_switch() {
  local service_name=$1
  local state=$2

  # switch it on or off, if necessary
  case $state in
    on)
      echo "starting $service_name..."
      sudo $service_binary $service_name start || return 100
      ;;
    off)
      echo "stopping $service_name..."
      sudo $service_binary $service_name stop || return 101
      ;;
    restart)
      echo "restarting $service_name..."
      sudo $service_binary $service_name restart || return 102
      ;;
    *)
      echo "unrecognized state switching for $service_name"
      return 102
  esac

  return 0
}


# checks if a service needs to be switched on or off
# @param desired_state  the state the service should be switched to
# @param state          the state the service is currently in
# @return  0 if a switch is needed
service_should_switch() {
  local desired_state=$1
  local state=$2
  if [ $state -eq 0 ]; then # is running and...
    if [ "$desired_state" = "off" ]; then # should be switched off
      return 0
    fi
  else                 # is NOT running and...
    if [ "$desired_state" = "on" ]; then # should be switched on
      return 0
    fi
  fi

  return 1
}


# checks if autofs is running on /cvmfs
# @return   0 when autofs is mounted on /cvmfs
autofs_check() {
  cat /proc/mounts | grep -q "^/etc/auto.cvmfs /cvmfs "
}


# ensures that autofs is on or off
# @param state   the desired state of autofs (on|off)
# @return        0 on success
autofs_switch() {
  autofs_check
  service_should_switch $1 $?
  if [ $? -eq 0 ]; then
    service_switch autofs $1
    return $?
  else
    return 0
  fi
}


# switches apache on or off
# @param state   the desired state of autofs (on|off)
# @return        0 on success
apache_switch() {
  sudo $service_binary $APACHE_SERVICE status > /dev/null 2>&1
  service_should_switch $1 $?
  if [ $? -eq 0 ]; then
    service_switch $APACHE_SERVICE $1
    return $?
  else
    return 0 # already in correct state
  fi
}


contains() {
  local haystack="$1"
  local needle=$2

  for elem in $haystack
  do
    if [ $(readlink --canonicalize $elem) = $(readlink --canonicalize $needle) ]; then
      return 0
    fi
  done

  return 1
}


cvmfs_clean() {
  sudo cvmfs_config umount > /dev/null || return 100
  sudo sh -c "rm -rf /var/lib/cvmfs/*"
  sudo rm -f /etc/cvmfs/default.local
  sudo sh -c "rm -f /etc/cvmfs/config.d/*"
  sudo sh -c "cat /dev/null > $CVMFS_TEST_SYSLOG_TARGET"

  timeout=5
  while $(pgrep -u cvmfs cvmfs2 > /dev/null); do
    if [ $timeout -eq 0 ]; then
      return 101
    fi
    timeout=$(($timeout-1))
    sleep 1
  done

  return 0
}


cvmfs_mount() {
  repositories=$1
  shift 1

  sudo sh -c "echo \"CVMFS_REPOSITORIES=$repositories\" > /etc/cvmfs/default.local" || return 100
  sudo sh -c "echo \"CVMFS_HTTP_PROXY=\\\"${CVMFS_TEST_PROXY}\\\"\" >> /etc/cvmfs/default.local" || return 100
  sudo sh -c 'echo "CVMFS_TIMEOUT=20" >> /etc/cvmfs/default.local' || return 100
  sudo sh -c 'echo "CVMFS_TIMEOUT_DIRECT=20" >> /etc/cvmfs/default.local' || return 100
  sudo sh -c 'echo "CVMFS_SERVER_URL=http://cvmfs-atlas-nightlies.cern.ch/cvmfs/atlas-nightlies.cern.ch" > /etc/cvmfs/config.d/atlas-nightlies.cern.ch.local' || return 100
  sudo sh -c "echo CVMFS_SYSLOG_FACILITY=$CVMFS_TEST_SYSLOG_FACILITY >> /etc/cvmfs/default.local" || return 100

  # add additional parameters
  while [ $# -gt 0 ]; do
    local param="$1"
    sudo sh -c "echo \"$1\" >> /etc/cvmfs/default.local" || return 100
    shift 1
  done

  if [ "x$CVMFS_TEST_DEBUGLOG" != "x" ]; then
    sudo sh -c "echo \"CVMFS_DEBUGLOG=$CVMFS_TEST_DEBUGLOG\" >> /etc/cvmfs/default.local" || return 100
  fi
  cvmfs_config probe > /dev/null 2>&1 || return 101

  return 0
}


cvmfs_umount() {
  repositories=$1

  for r in $(echo $repositories | tr , " "); do
    sudo umount /cvmfs/$r || return 100

    timeout=5
    while cat /proc/mounts | grep -q /cvmfs/$r; do
      if [ $timeout -eq 0 ]; then
        return 101
      fi
      timeout=$(($timeout-1))
      sleep 1
    done
  done

  return 0
}



get_cvmfs_cachedir() {
  repository=$1

  local cache_dir
  cache_dir=$(cvmfs_config showconfig $repository | grep CVMFS_CACHE_DIR | awk '{print $1}' | cut -d= -f2)
  if [ "x$cache_dir" = "x" ]; then
    echo "Failed to figure out cache directory"
    exit 1
  fi
  echo $cache_dir
}


CVMFS_MEMORY_WARNING_FLAG=0
CVMFS_TIME_WARNING_FLAG=0
CVMFS_MEMORY_WARNING=254
CVMFS_TIME_WARNING=253
mangle_test_retval() {
  local prior_retval=$1

  # if the test case failed... report the retval right away
  if [ $prior_retval -ne 0 ]; then
    return $prior_retval
  fi

  # check if the test case produced memory warnings and report them
  if [ $CVMFS_MEMORY_WARNING_FLAG -ne 0 ]; then
    return $CVMFS_MEMORY_WARNING
  fi

  # check if the test case produced timeout warnings
  if [ $CVMFS_TIME_WARNING_FLAG -ne 0 ]; then
    return $CVMFS_TIME_WARNING
  fi

  # return 0 if all is good
  return 0
}

reset_test_warning_flags() {
  CVMFS_MEMORY_WARNING_FLAG=0
  CVMFS_TIME_WARNING_FLAG=0
}


check_time() {
  start_time=$1
  end_time=$2
  limit=$3

  diff_time=$(($end_time-$start_time))

  if [ $diff_time -gt $limit ]; then
    echo "Time limit exceeded" >&2
    echo "Limit was $limit but it took $diff_time seconds"
    CVMFS_TIME_WARNING_FLAG=1
    return 100
  fi

  return 0
}


check_memory() {
  instance=$1
  limit=$2

  pid=$(attr -qg pid /cvmfs/$instance)             || return 100
  rss="$(sudo cat /proc/$pid/status | grep VmRSS)" || return 101
  rss_kb=$(echo $rss | awk '{print $2}')

  if [ $rss_kb -gt $limit ]; then
    local inode_tracker="$(sudo cvmfs_talk -i $instance internal affairs | grep 'inode tracker')"
    local inserts=$(echo "$inode_tracker" | grep -o "inserts: [0-9]*" | grep -o "[0-9]*$")
    local removes=$(echo "$inode_tracker" | grep -o "removes: [0-9]*" | grep -o "[0-9]*$")
    local elements=$(( $inserts - $removes ))

    echo "Memory limit of $limit kB was exceeded by $instance which used $rss_kb kB"
    echo "We've had $elements items in the inode tracker"
    echo "Output of cat /proc/$pid/status:"
    sudo cat /proc/$pid/status 2>&1
    CVMFS_MEMORY_WARNING_FLAG=1

    return 102
  fi

  return 0
}


destroy_repo() {
  local repo=$1
  sudo cvmfs_server rmfs -f $repo || return 100
}


has_repo() {
  local repo=$1
  cvmfs_server list | grep -q "^$repo "
}


create_repo() {
  local repo=$1
  local uid=$2
  local debug_log=$3
  local extra_options="$4"

  echo "Shutting down autofs for the cvmfs mounts"
  autofs_switch off || return 100

  if has_repo $repo; then
    echo "Repository $repo is already present... removing it"
    destroy_repo $repo || return 101
  fi

  echo "Creating new repository $repo..."
  sudo cvmfs_server mkfs -o $uid -m -f ${CVMFS_TEST_UNIONFS} -a ${CVMFS_TEST_HASHALGO} $extra_options $repo || return 102

  if [ x$debug_log != x -a x$debug_log != xNO ]; then
    echo "CVMFS_DEBUGLOG=$debug_log" | sudo tee -a /etc/cvmfs/repositories.d/${repo}/client.conf
  fi
}


create_empty_repo() {
  local repo=$1
  local uid=$2
  local debug_log=$3
  local extra_options="$4"

  create_repo $repo $uid $debug_log $extra_options || return 101

  sudo cvmfs_server transaction $repo || return 102
  rm -f /cvmfs/$repo/new_repository
  sudo cvmfs_server publish $repo || return 103
}


# creates a cvmfs repository and fills it with some dummy data
#
# @param repo_name   the name of the repository to create
# @param uid         the user id of the new repository's owner
create_filled_repo() {
  local repo=$1
  local uid=$2
  local debug_log=$3

  create_empty_repo $repo $uid $debug_log || return 101

  sudo cvmfs_server transaction $repo || return 102

  pushdir /cvmfs/$repo

  echo "meaningless file content" > file
  echo "more clever file content" > clever
  ln file hardlinkToFile
  ln -s clever symlinkToClever

  mkdir -p foo/bar/baz
  mkdir -p bar/foo/baz
  touch foo/.cvmfscatalog

  # Put some meaningful stuff into files
  echo "Vom Eise befreit sind Strom und Bäche"         > foo/bar/verse1
  echo "Durch des Frühlings holden, belebenden Blick," > foo/bar/verse2
  echo "Im Tale grünet Hoffnungsglück;"                > foo/bar/verse3
  echo "Der alte Winter, in seiner Schwäche,"          > foo/bar/verse4
  echo "Zog sich in rauhe Berge zurück."               > foo/bar/verse5

  popdir

  sudo cvmfs_server publish $repo || return 103
}


# generates a huge dummy repository content with 500.000 directory entries
# in a somewhat representative directory structure
#
# @param  repo_dir   where to put the dummy dirents
make_huge_repo() {
  local repo_dir=$1
  python ${TEST_ROOT}/mock_services/make_repo.py \
    --max-dir-depth        7                     \
    --num-subdirs          5                     \
    --num-files-per-dir    5                     \
    --min-file-size        0                     \
    --max-file-size     5120                     \
    $repo_dir
}


# creates a big file at a given location with a given size
# @param path  the location of the new file
# @param size  the desired size in megabytes
create_big_file() {
  local path=$1
  local size=$2

  dd if=/dev/zero of=$path bs=1024k count=$size
}


# generate a custom style recursive listing with only the following infos:
# - file name
# - linkcount
# - file mode
# - file size
# - parent directory
# - symlink destination (when applicable)
# - uid and gid can be specified
#
# @param directory          the directory to be listed
# @param uid                specify a UID for the file owner (optional)
# @param gid                specify a GID for the file owner (optional)
# @return                   a custom directory listing
create_listing() {
  local directory=$1
  local uid=$2
  local gid=$3
  local lst

  lst=$(ls --almost-all --recursive -l --file-type --time-style=+ $directory | \
  awk '
  {
    # skip the total file count, ls prints at the end of each directory listing
    if(substr($1, 0, 5) == "total") next;

    # length of base directory path
    base_dir_length = length(base_dir)

    # truncate base path from the path printed before each new listing
    if(substr($0, 0, base_dir_length) == base_dir) {
      print substr($0, base_dir_length + 1, length($0)-1)
      next;
    }

    # first character
    first = substr($0, 0, 1);

    # print file meta information
    # $1    => file mode (rwx bits, ...)
    # $2    => linkcount
    # $3,$4 => owner, group (might also be provided from outside)
    # $5    => file size (skipped for directories)
    # $6    => file name
    # $7,$8 => symlink destination (only for symlinks :o) )

    if (first != "-" && first != "d" && first != "l")
    {
      printf "\n"
      next;
    }

    # print out file information
    printf $1                     " ";
    printf $2                     " ";
    printf (uid == "" ? $3 : uid) " ";
    printf (gid == "" ? $4 : gid) " ";
    printf $6;

    if(first == "l") printf " " $7 " " $8;
    if(first != "d") printf " " $5;
    printf "\n"
  }' uid=$uid gid=$gid base_dir=$directory)

  echo -e "$lst"
}

# compares the file contents and file meta data of two directories
# Note: function creates the files 'listingFile1' and 'listingFile2' in `pwd`
#       `pwd` should NOT be part of the comparison!!
#
# @param dir1    the directory to probe
# @param dir2    the ground truth directory
# @return        != 0 to indicate inequality, 0 means success
compare_directories() {
  local dir1=$1
  local dir2=$2

  listing1=$(create_listing $dir1)
  listing2=$(create_listing $dir2)

  echo "check if directory structure and file meta data fits"
  local listingFile1="listing_$(basename $dir1)"
  local listingFile2="listing_$(basename $dir2)"
  echo -e "$listing1" > $listingFile1
  echo -e "$listing2" > $listingFile2
  diff -uN $listingFile1 $listingFile2 2>&1 || return 101

  echo "check if the file contents in both directories are the same"
  diff -ruN $dir1 $dir2 2>&1 || return 102

  return 0
}


# run a binary in the background and return it's PID through stdout
#
# @param logfile  a path to a logfile for outputs of the started program
# @return         the process ID of the created background service
run_background_service() {
  local logfile=$1
  shift 1

  local srv_pid

  # shell for the win!
  # This spawns a shell executing the passed command string (sudo sh -c) which
  # will print it's PID (echo $$) into a fifo and execute the user defined
  # binary redirecting its outputs into the logfile (exec $@ >> $logfile 2>&1).
  # Furthermore it disconnects the new process from the executing shell (nohup),
  # satisfies the I/O requirements of nohup (2>&1 < /dev/null) and sends it to
  # the background (&)
  #   Credit: Dario Berzano helped with that monster!
  local fifo="pid_fifo"
  mkfifo $fifo || return 1
  nohup sh -c "echo \$\$ > $fifo; exec $@ >> $logfile 2>&1" 2>&1 < /dev/null &
  srv_pid=$(cat $fifo)
  rm -f $fifo

  # check if the background process is running
  if ! sudo kill -0 $srv_pid > /dev/null 2>&1; then
    return 4
  fi

  # print the PID of the background process and return successfully
  echo $srv_pid
  return 0
}


# open a port for incoming connections. It will accept the connection but stay
# silent on it
#
# Note: The user is responsible for killing the created server process after
#       usage
#
# @param protocol  either UDP or TCP
# @param port      the desired port number to be opened
# @param logfile   a path to the logfile where connection logs should be written
# @return          the process ID of the created server script
open_silent_port() {
  local protocol=$1
  local port=$2
  local logfile=$3
  local pid
  local cmd
  local retcode

  cmd="sudo python ${TEST_ROOT}/mock_services/silent_socket.py $protocol $port"
  pid=$(run_background_service $logfile "$cmd")
  retcode=$?

  if [ $retcode -ne 0 ]; then
    return $retcode
  fi

  echo $pid
  return $retcode
}


# checks if a nested catalog is part of the current catalog configuration
# of the repository
# @param catalog_path  the catalog root path to be checked
# @param repo_name     the repository to be checked
check_catalog_presence() {
  local catalog_path=$1
  local repo_name=$2

  cvmfs_swissknife lsrepo -r /srv/cvmfs/$repo_name | grep -x -q $catalog_path
  return $?
}

# counts the number of present catalogs in the repository
# @param repo_name  the name of the repository to investigate
# @return           the number of found catalogs
get_catalog_count() {
  local repo_name=$1

  echo $(cvmfs_swissknife lsrepo -r /srv/cvmfs/$repo_name | wc -l)
}

# uses `cvmfs_server check` to check the integrity of the catalog structure
# additionally it might check the backend storage integrity as well when
# provided with -i
# @param repo    the repository to be checked
check_repository() {
  local repo=$1
  shift 1

  cvmfs_server check $@ $repo || return 100
  return 0
}

# wrapper function to start a new repository update transaction
# @param repo    the repository you want to start the transaction for
start_transaction() {
  local repo=$1

  cvmfs_server transaction $repo || return 100
  return 0
}

# wrapper function to publish an repository after its contents were updated.
# @param repo    the repository name to start the transaction in
publish_repo() {
  local repo=$1
  shift 1

  # parse the command line arguments (keep quotation marks)
  args="-v"
  while [ $# -gt 0 ]; do
    if echo $1 | grep -q "\s"; then
      args="$args \"$1\""
    else
      args="$args $1"
    fi
    shift 1
  done

  # enable the debug mode?
  # in debug mode we redirect output directly to the interactive shell,
  # overriding any redirections to logfiles or whatever... We want to hack!
  case $CVMFS_TEST_SRVDEBUG in
    fail)
      cvmfs_server publish -d $args $repo > /dev/tty 2>&1 || return 100
    ;;
    startup)
      cvmfs_server publish -D $args $repo > /dev/tty 2>&1 || return 100
    ;;
    *)
      cvmfs_server publish $args $repo || return 100
    ;;
  esac

  return 0
}


# sources the repository server configuration file for the given repo name
# @param name  the name of the repository to load the configs for
load_repo_config() {
  local name=$1
  . /etc/cvmfs/repositories.d/${name}/server.conf
}


# runs the given command and measures the time it took to execute
stop_watch() {
  begin=$(date +%s)
  cmd="$@"
  $cmd
  res=$?
  end=$(date +%s)
  echo $((end - begin))
  return $res
}


# wrapper around pushd (that is not available in dash)
# if pushd is not available, a normal `cd` is used
# Note: We do not reimplement the whole functionality of pushd, with our work-
#       around it is only possible to have ONE directory-level stored
pushdir() {
  type pushd > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    pushd $1
    return $?
  else
    cd $1
    return $?
  fi
}


# wrapper around popd (that is not available in dash)
# if popd is not available, a normal `cd -` is used to go back to the last dir
# Note: We do not reimplement the whole functionality of popd, with our work-
#       around it is only possible to have ONE directory-level stored
popdir() {
  type popd > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    popd $1
    return $?
  else
    cd -
    return $?
  fi
}


# retrieves the apache version string "2.x.xx"
get_apache_version() {
  ${APACHE_BIN} -v | head -n1 | \
    sed 's/^Server version: Apache\/\([0-9]\+\.[0-9]\+\.[0-9]\+\).*$/\1/'
}


# figure out apache config file mode
#
# @return   apache config mode (stdout) (see globals below)
APACHE_CONF_MODE_OLD=1 # *.conf goes to ${APACHE_CONF}/conf.d
APACHE_CONF_MODE_NEW=2 # *.conf goes to ${APACHE_CONF}/conf-available
get_apache_conf_mode() {
  local minor_apache_version=$(version_minor "$(get_apache_version)")
  if [ $minor_apache_version -ge 4 ] || [ -d /etc/${APACHE_CONF}/conf-available ]; then
    echo $APACHE_CONF_MODE_NEW
  else
    echo $APACHE_CONF_MODE_OLD
  fi
}


# find location of apache configuration files
#
# @return   the location of apache configuration files (stdout)
get_apache_conf_path() {
  local res_path="/etc/${APACHE_CONF}"
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    echo "${res_path}/conf-available"
  else
    echo "${res_path}/conf.d"
  fi
}


# returns the apache configuration string for 'allow from all'
# Note: this is necessary, since apache 2.4.x formulates that different
#
# @return   a configuration snippet to allow s'th from all hosts (stdout)
get_compatible_apache_allow_from_all_config() {
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    echo "Require all granted"
  else
    local nl='
'
    echo "Order allow,deny${nl}    Allow from all"
  fi
}


# writes apache configuration file
# This figures out where to put the apache configuration file depending
# on the running apache version
# Note: Configuration file content is expected to come through stdin
#
# @param   file_name  the name of the apache config file (no path!)
# @return             0 on success
create_apache_config_file() {
  local file_name=$1
  local conf_path
  conf_path="$(get_apache_conf_path)"

  # create (or append) the conf file
  cat - | sudo tee ${conf_path}/${file_name} > /dev/null || return 1

  # the new apache requires the enable the config afterwards
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    sudo a2enconf $file_name > /dev/null || return 2
  fi

  return 0
}


# removes apache config files dependent on the apache version in place
# Note: As of apache 2.4.x `a2disconf` needs to be called before removal
#
# @param   file_name  the name of the conf file to be removed (no path!)
# @return  0 on successful removal
remove_apache_config_file() {
  local file_name=$1
  local conf_path
  conf_path="$(get_apache_conf_path)/${file_name}"

  # disable configuration on newer apache versions
  if [ x"$(get_apache_conf_mode)" = x"$APACHE_CONF_MODE_NEW" ]; then
    sudo a2disconf $file_name > /dev/null 2>&1 || return 1
  fi

  # remove configuration file
  sudo rm -f $conf_path
}


get_repo_storage() {
  local repo_name="$1"
  echo "/srv/cvmfs/${repo_name}"
}

get_repo_url() {
  local repo_name="$1"
  echo "http://localhost/cvmfs/${repo_name}"
}

get_apache_config_filename() {
  local repo_name="$1"
  echo "${repo_name}.conf"
}


cleanup_legacy_repo_leftovers() {
  local legacy_repo_name="$1"
  local legacy_repo_storage="$(get_repo_storage $legacy_repo_name)"
  local apache_config_file="$(get_apache_config_filename $legacy_repo_name)"

  echo -n "cleanup (if necessary)... "
  has_repo $legacy_repo_name && die "fail"
  if [ -d $legacy_repo_storage ]; then
    sudo rm -fR $legacy_repo_storage
  fi
  if [ -f /etc/cvmfs/keys/${legacy_repo_name}.crt ] || \
     [ -f /etc/cvmfs/keys/${legacy_repo_name}.pub ] || \
     [ -f /etc/cvmfs/keys/${legacy_repo_name}.key ] || \
     [ -f /etc/cvmfs/keys/${legacy_repo_name}.masterkey ]; then
    sudo rm -f /etc/cvmfs/keys/${legacy_repo_name}.*
  fi
  remove_apache_config_file $apache_config_file
  echo "done"
}


# resigns a freshly planted legacy repository (see plant_legacy_repo())
# Note: This expects a matching keychain in /etc/keys/{$repo_name}
# @param repo_name  the FQRN of the legacy repository to be resigned
_resign_legacy_repository() {
  local repo_name="$1"
  local repo_storage="$(get_repo_storage $repo_name)"
  local legacy_repo_storage="${repo_storage}/pub/catalogs"
  local tmp_dir="$(pwd)/tmp"
  local upstream="local,${legacy_repo_storage}/data/txn,${legacy_repo_storage}"

  cat ${legacy_repo_storage}/.cvmfspublished | head -n6 | \
    sudo tee ${legacy_repo_storage}/.cvmfspublished_unsigned > /dev/null || return 1
  mkdir -p $tmp_dir || return 2
  sudo cvmfs_swissknife sign \
    -c /etc/cvmfs/keys/${repo_name}.crt \
    -k /etc/cvmfs/keys/${repo_name}.key \
    -n ${repo_name} \
    -m ${legacy_repo_storage}/.cvmfspublished_unsigned \
    -t $tmp_dir \
    -r $upstream > /dev/null || return 3
}


# extracts a tarball into the root directory!
# Note: it expects the tarball to define the full destination path.
# @param tarball  the path to the tarball to be planted
plant_tarball() {
  local tarball="$1"
  local olddir="$(pwd)"

  cd /                  || return 101
  sudo tar xzf $tarball || return 102
  cd $olddir            || return 103
}


# extracts a legacy repository contained in a tarball.
# Note: This expects the tarball to define the full destination path. Furthermore
#       it expects a repo keychain to be planted in /etc/keys/${legacy_repo_name}
# @param tarball           path to the tarball containing the legacy repo
# @param legacy_repo_name  FQRN of the repository to be planted
plant_legacy_repository_revision() {
  local tarball="$1"
  local legacy_repo_name="$2"
  local legacy_repo_storage="$(get_repo_storage $legacy_repo_name)"

  plant_tarball "$tarball"                                             || return 104
  [ -d ${legacy_repo_storage}/pub ]                                    || return 105
  [ -f ${legacy_repo_storage}/pub/catalogs/.cvmfscatalog ]             || return 106
  [ -f ${legacy_repo_storage}/pub/catalogs/.cvmfswhitelist ]           || return 107
  sudo touch ${legacy_repo_storage}/pub/catalogs/.cvmfs_master_replica || return 108
  _resign_legacy_repository "$legacy_repo_name"                         || return 109
}
