-include $(TOOLS_MKDIR).mk
LLVM_ANALYZER     := $(self_EX_FLAGS_LLVM_ANALYZER)
OVERRIDABLE_FLAGS := $(filter $(self_EX_FLAGS_OVERRIDABLE_FLAGS),$(ALL_COMPILER_FLAGS))
##############################################################################
TARGETDIR:= $(subst /,_,$(THISDIR))
.DEFAULT_GOAL := all
.PHONY: FORCE_TARGET
##############################################################################
multipletools := info
wrongtool := info
comma:= ,
empty:= 
colon:= :
path_seperator := :
space:= $(epmty) $(empty)
prebuild       := 
postbuild      :=
prelibdeps     :=
prebindeps     :=
ALL_SCRAM_PROJECTS :=
ALL_SUBSYSTEMS     :=
ALL_PACKAGES       :=
ALL_PYTHON_DIRS    :=
ALL_EMPTY_PACKAGES :=
ALL_BUILDFILES     :=
ALL_PRODS          :=
SKIP_UNITTESTS     := $(patsubst skiptest_%,%,$(filter skiptest_%,$(MAKECMDGOALS)))
FAST:=
XFAST:=
UFAST:=
ONLYECHOTARGETS:=
OBJEXT:=o
MODULE_PREFIX:=lib
COMMON_WORKINGDIR := $(SCRAM_TMP)/common
WORKINGDIR := $(SCRAM_INTwork)
YACC                        := bison
LEX                         := flex
LATEX                       := latex
DVISUFFIX                   := dvi
PSSUFFIX                    := ps
PDFSUFFIX                   := pdf
PS2PDF                      := ps2pdf
DVIPS                       := dvips
LD_BIG_OPT                  := 
BIGLIB_OBJEXT               := obj
OLD_TIMESTAMP               := 198001010100
NON_XML_BUILDFILE           := 
UPDATE_CLASSVERSION         :=
ALL_CLASS_VERSION_RULES     :=
HOOK_PACKAGE                :=
HOOK_PRODUCT                :=
CLASSES_H_GENERATOR         := $(LOCALTOP)/$(SCRAM_CONFIGDIR)/genClassesH
DROP_EXTERNAL_HEADER_MMD_DEPS:= yes
###################################
CMDS_COMPILERS_MAP          := CXX:g++ CC:gcc FC:g77
ALL_CMDS                    := sh awk cat cd chmod cp dirname echo false find g77 g++ gcc grep ln ls mkdir mv perl python rm sed sort touch tr true uname uniq xargs ld
SHELL                       := /bin/sh
BASECMD_which               := which
CMD_cd  := cd
ifdef CXX
CMD_g++ := $(CXX)
endif
ifdef CC
CMD_gcc := $(CC)
endif
ifdef FC
CMD_g77 := $(FC)
endif
###################################
SetLocalCMDs    = $(if $($1),$(eval CMD_$2:=$($1)),)
SetCompilerCMDs = $(if $($1),,$(eval $1:=$(CMD_$2)))
ShellCMDs       = $(if $(CMD_$1),,$(eval CMD_$1:=$(eval x:=$(strip $(firstword $(shell $(BASECMD_which) $1 2>&1))))$(if $(wildcard $x),$x,$1)))
###################################
$(eval $(call ShellCMDs,which))
BASECMD_which := $(CMD_which)
$(foreach c,$(CMDS_COMPILERS_MAP),$(eval $$(call SetLocalCMDs,$(subst :,$(comma),$c))))
$(foreach c,$(ALL_CMDS)         ,$(eval $(call ShellCMDs,$c)))
$(foreach c,$(CMDS_COMPILERS_MAP),$(eval $$(call SetCompilerCMDs,$(subst :,$(comma),$c))))
###################################
UNAME                       := $(CMD_uname)
ifndef CXX_MF
CXX_MF:=-MF
endif
ifndef C_MF
C_MF:=-MF
endif
ifndef F77_MF
F77_MF:=-MF
endif
ifndef CXX_MMD
CXX_MMD:=-MMD
endif
ifndef C_MMD
C_MMD:=-MMD
endif
ifndef F77_MMD
F77_MMD:=-MMD
endif
ifndef CXX_MM
CXX_MM:=$(patsubst %D,%,$(CXX_MMD))
endif
ifndef C_MM
C_MM:=$(patsubst %D,%,$(C_MMD))
endif
ifndef F77_MM
F77_MM:=$(patsubst %D,%,$(F77_MMD))
endif
###################################
SHAREDSUFFIX := so
ifeq ($(filter-out osx%,$(SCRAM_ARCH)),)
SHAREDSUFFIX := dylib
endif
ifndef OS_RUNTIME_LIBRARY_PATH
OS_RUNTIME_LIBRARY_PATH := LD_LIBRARY_PATH
ifeq ($(filter-out osx%,$(SCRAM_ARCH)),)
OS_RUNTIME_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH
endif
endif
ifndef CXXSHAREDFLAGS
ifeq ($(filter-out slc%,$(SCRAM_ARCH)),)
CXXSHAREDFLAGS                 := -shared
endif
endif
SHARED_LIB_LOAD_CHECK := 
##############################################################################
ifndef RUN_LLVM_ANALYZER_ON_ALL
RUN_LLVM_ANALYZER_ON_ALL:=no
endif
ifndef SCRAMSTORENAME_LIB
SCRAMSTORENAME_LIB:=lib
endif
ifeq ($(strip $(SCRAM_SOURCEDIR)),)
SCRAM_SOURCEDIR:=src
endif

ifneq ($(strip $(PYTHON_BASE)),)
CMD_python := $(PYTHON_BASE)/bin/python
endif

ifneq ($(wildcard $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)),)
CONFIGDEPS += $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)
endif
CONFIGDEPS += $(WORKINGDIR)/cache/xlibs

ifndef SCRAM_BUILDVERBOSE
VERB:=@
VERB_ECHO:=:
else
VERB:=
VERB_ECHO:=echo
endif

ifeq ($(strip $(BUILD_LOG)),yes)
DO_BUILD_LOG:=
else
DO_BUILD_LOG:=:
endif

ifneq ($(findstring k,$(firstword  $(MAKEFLAGS))),)
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || ($(CMD_echo) gmake: \*\*\* [$@] Error $$? ; exit 0)
else
ifeq ($(strip $(BUILD_LOG)),yes)
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || (exitcode=$$?; $(CMD_echo) gmake: \*\*\* [$@] Error $$exitcode ; exit $$exitcode)
else
FORCE_BUILD_START =
FORCE_BUILD_END =
endif
endif

$(SCRAM_SOURCEDIR) :=

##############################################################################
##############################################################################
define set_cached_var_func_arg_
cached_var_func_arg$(cached_var_func_arg_count_$(1))_$(1) := $(2)
cached_var_func_arg_count_$(1) := $(cached_var_func_arg_count_$(1))1
endef
define set_cached_var_
cached_var_func_arg_count_$(1) := 
$(foreach arg,$(subst $(comma),$(space),$(cached_var_function_$(1))),$(eval $(call set_cached_var_func_arg_,$(1),$(arg))))
cached_var_$(1) := $(call $(cached_var_func_arg_$(1)),$(cached_var_func_arg1_$(1)),$(cached_var_func_arg11_$(1)),$(cached_var_func_arg111_$(1)),$(cached_var_func_arg1111_$(1)),$(cached_var_func_arg11111_$(1)))
endef
define get_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(cached_var_$(1)))
endef
define get_uniq_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(eval cached_var_$(1):=$(call Uniq,$(cached_var_$(1))))$(cached_var_$(1)))
endef
##############################################################################
define GetTimeStamp
$(CMD_perl) -e '@d=stat "$(1)"; print "$$d[9]\n";'
endef
define Uniq
$(eval uniq_string_:=)$(strip $(foreach v,$(1),$(if $(filter $(v),$(uniq_string_)),,$(eval uniq_string_+=$(v))))$(uniq_string_))
endef
define AddCachedVariable
cached_var_function_$(1)  := $(subst $(colon),$(comma),$(2))
ifeq ($$(strip $(3)),)
$(1) = $$(call get_cached_var_,$(1))
else
$(1) = $$(call get_uniq_cached_var_,$(1))
endif
endef
define GetVariable
$($(1))
endef
define AdjustFlag
$(strip $(filter-out $(strip $(REM_$1_$2) $(REM_$2)),$($2)) $($1_$2))
endef
define AdjustFlags
$(foreach f,$3,$(filter-out $(strip $(foreach t,$2,$(REM_$t_$f))),$($1_$f)) $(foreach t,$2,$($t_$f)))
endef
define Tool_CXXFLAGS
$(filter-out $(USER_REM_CXXFLAGS) $($(1)_LOC_FLAGS_REM_CXXFLAGS),$(CXXFLAGS)) $($(1)_LOC_FLAGS_CXXFLAGS_ALL) $(USER_CXXFLAGS)
endef
define Tool_FFLAGS
$(filter-out $(USER_REM_FFLAGS) $($(1)_LOC_FLAGS_REM_FFLAGS),$(FFLAGS)) $($(1)_LOC_FLAGS_FFLAGS_ALL) $(USER_FFLAGS)
endef
define Tool_CFLAGS
$(filter-out $(USER_REM_CFLAGS) $($(1)_LOC_FLAGS_REM_CFLAGS),$(CFLAGS)) $($(1)_LOC_FLAGS_CFLAGS_ALL) $(USER_CFLAGS)
endef
define Tool_CPPFLAGS
$(filter-out $(USER_REM_CPPFLAGS) $($(1)_LOC_FLAGS_REM_CPPFLAGS),$(CPPFLAGS)) $(filter-out $(USER_REM_CPPDEFINES) $($(1)_LOC_FLAGS_REM_CPPDEFINES),$(CPPDEFINES)) $($(1)_LOC_FLAGS_CPPDEFINES_ALL) $($(1)_LOC_FLAGS_CPPFLAGS_ALL) $(USER_CPPFLAGS) $(USER_CPPDEFINE) $(addprefix -I,$(wildcard $(INCLUDE))) $(addprefix -I,$(wildcard $($(1)_LOC_INCLUDE_ALL)))
endef
define Tool_LDFLAGS
$(USER_LDFLAGS) $(filter-out $(USER_REM_LDFLAGS) $($(1)_LOC_FLAGS_REM_LDFLAGS),$(LDFLAGS)) $(addprefix -L,$(LIBDIR) $(filter-out $(LIBDIR),$($(1)_LOC_LIBDIR_ALL))) $(addprefix -l,$(LIB)) $(addprefix -l,$($(1)_LOC_LIB_ALL)) $($(1)_LOC_FLAGS_LDFLAGS_ALL)
endef
define CalculateToolOrder
$(if $(strip $($(1)_EX_USE)),$(shell $(CMD_perl) \-e '@z=($(2) $(foreach dep,$(foreach d,$($(1)_EX_USE),$($d)),$(comma)$($(dep)_ORDER))); @z=sort {$$a <=> $$b} @z;$$x=$$z[0];$$x--;print "$$x";'),$(2))
endef
define FindToolDependency
$(sort $(foreach dep,$(foreach d,$($(1)_$(2)_USE),$($d)),$(dep) $($(dep)_EX_USE_ALL)))
endef
define FindUOLibDependency
$(sort $(foreach d,$($(1)_EX_USE),$($($d)_EX_LIB) $($($d)_EX_UOLIB)))
endef
define FindToolDepVariable
$($(1)_$(3)_$(2)) $(foreach var,$(sort $(foreach dep,$($(1)_$(3)_USE_ALL),$($(dep)_ORDER):$(strip $(subst $(space),$(colon),$($(dep)_EX_$(2)))))),$(wordlist 2,99999,$(subst $(colon),$(space),$(var))))
endef

define ProductOrder
ifeq ($(strip $($(1)_ORDER)),)
$(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):$(if $(strip $(2)),$(strip $(2)),99999),)
endif
$(foreach err,$(foreach use,$(filter-out $(ALL_TOOLS),$(sort $($(1)_LOC_USE) $($(1)_EX_USE))),$(if $($($(use))_EX_USE),,$(use))),$(4)_USE_ERR+=$(err))
endef

define ProductCommonVarsTools
$(eval $(call ProductOrder,$1,$2,$3,$4))
$(foreach type,INCLUDE LIB LIBDIR,$(eval $(call AddCachedVariable,$(1)_EX_$(type)_ALL,FindToolDepVariable:$(1):$(type):EX,1)))
$(foreach type,$(foreach f,$(ALL_COMPILER_FLAGS),FLAGS_$(f)),$(eval $(call AddCachedVariable,$(1)_EX_$(type)_ALL,FindToolDepVariable:$(1):$(type):EX,)))
$(foreach type,$(foreach f,$(ALL_COMPILER_FLAGS),FLAGS_REM_$(f)),$(eval $(call AddCachedVariable,$(1)_EX_$(type)_ALL,FindToolDepVariable:$(1):$(type):EX,)))
$(call AddCachedVariable,$(1)_EX_USE_ALL,FindToolDependency:$(1):EX,)
endef

define ProductCommonVars
$(eval $(call ProductOrder,$1,$2,$3,$4))
$(foreach scope,$(if $(strip $($(1)_EX_LIB)$($(1)_EX_USE)),EX) LOC,$(foreach type,INCLUDE LIB LIBDIR,$(eval $(call AddCachedVariable,$(1)_$(scope)_$(type)_ALL,FindToolDepVariable:$(1):$(type):$(scope),1))))
$(foreach scope,$(if $(strip $($(1)_EX_LIB)$($(1)_EX_USE)),EX) LOC,$(foreach type,$(foreach f,$(OVERRIDABLE_FLAGS),FLAGS_$(f)),$(eval $(call AddCachedVariable,$(1)_$(scope)_$(type)_ALL,FindToolDepVariable:$(1):$(type):$(scope),))))
$(foreach scope,$(if $(strip $($(1)_EX_LIB)$($(1)_EX_USE)),EX) LOC,$(eval $(call AddCachedVariable,$(1)_$(scope)_USE_ALL,FindToolDependency:$(1):$(scope),)))
$(foreach f,$(OVERRIDABLE_FLAGS),$(eval $(call AddCachedVariable,$(1)_$f,Tool_$f:$(1),)))
endef

define ProductCommonVarsExternal
ifneq ($(strip $($(1)_BuildFile)),)
$(eval $(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):99999,))
$(eval $(call AddCachedVariable,$(1)_EX_LIB_ALL,FindToolDepVariable:$(1):LIB:EX,1))
$(eval $(call AddCachedVariable,$(1)_EX_USE_ALL,FindToolDependency:$(1):EX,))
$(eval $(call AddCachedVariable,$(1)_EX_UOLIB,FindUOLibDependency:$(1),))
else
$(1)_ORDER:=99999
endif
endef

define outputlog
  @if [ -d $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) ] ; then \
    $(DO_BUILD_LOG) for f in `$(CMD_find) $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) -name "*" -type f | $(CMD_grep) -v  '/build\.log$$'` ; $(DO_BUILD_LOG) do $(DO_BUILD_LOG) $(CMD_cat) $$f $(redirectlog_$(2)) ; $(DO_BUILD_LOG) $(CMD_rm) -f $$f;  $(DO_BUILD_LOG) done ;\
  fi
endef
define outputLogFile
  @if [ "X$1" != "X" ] ; then \
    $(CMD_cat) $1;\
    dir=`$(CMD_dirname) $1`;\
    while [ ! -f "$$dir/build.log" ] && [ "$$dir" != "$(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)" ] ; do \
      dir=`$(CMD_dirname) $$dir`;\
    done ;\
    [ -f "$$dir/build.log" ] && $(CMD_cat) $1 >> $$dir/build.log ;\
    $(CMD_rm) -f $1;\
  fi
endef
define checklibs
  $(eval xliberr:=)$(foreach x,$($(1)_LOC_LIB),$(if $(strip $(filter-out $($(1)_PACKAGE),$($(x)_PACKAGE))),$(eval xliberr+=$x:$($(x)_PACKAGE)),)) \
  if [ "X$(xliberr)" != "X" ] ; then \
    $(CMD_echo) "****ERROR: Skipping build of $1 generated from $($(1)_PACKAGE) as it is explicitly linking following library/libraries." ;\
    for x in $(xliberr) ; do $(CMD_echo) "    -> $$x" | $(CMD_sed) -e 's|:self/| from |';  done;\
    $(CMD_false);\
  fi
endef
##############################################################################
define BuildClean
  if [ "X$(1)" != "X" ] ; then \
    if [ -d $(WORKINGDIR)/$(1) ] ; then \
      regexp=$2; \
      if [ "X$$regexp" == "X" ] ; then regexp='[0-9][0-9]'; fi ;\
      $(CMD_find) $(WORKINGDIR)/$(1) -name "AUTOCLEAN.*.clean" -type f | $(CMD_xargs) $(CMD_cat) | $(CMD_grep) "^$$regexp:" | $(CMD_sort) | $(CMD_uniq) | $(CMD_sed) -e "s|^$$regexp:||" > $(WORKINGDIR)/$(1)/.AUTOCLEAN ; \
      if [ "X$3" == "X" ] ; then $(CMD_cat) $(WORKINGDIR)/$(1)/.AUTOCLEAN; fi;\
      $(CMD_sh) $(WORKINGDIR)/$(1)/.AUTOCLEAN;\
      $(CMD_rm) -rf $(WORKINGDIR)/$(1); \
      $(CMD_rm) -rf $(WORKINGDIR)/classes/$(1); \
    fi;\
  fi
endef

define AutoCleanFile
$(dir $(1))/AUTOCLEAN.$(notdir $(1)).$(2).clean
endef
##############################################################################
# Macros for pre/post build steps:
define copy_build_product
  if [ ! -d $(LOCALTOP)/$(1) ]; then 	\
    $(CMD_mkdir) -p $(LOCALTOP)/$(1)	&&\
    $(CMD_echo) "Creating product storage directory: $(LOCALTOP)/$(1)"; \
  fi &&\
  $(CMD_echo) "Copying $@ to productstore area:" &&\
  $(CMD_echo) "01:$(CMD_rm) -f $(1)/$(@F)" > $(call AutoCleanFile,$@,prod) &&\
  $(CMD_rm) -f $(LOCALTOP)/$(1)/$(@F) &&\
  $(CMD_cp) $@ $(LOCALTOP)/$(1) || ($(CMD_rm) -f $@ && $(CMD_echo) ">> Deleted: $@" && exit 1)
endef

define copy_lib_to_main_productstore
  $(call install_name_tool,$(@F),$@) && $(call copy_build_product,$(1))
endef

define copy_bigobj_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_bin_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_test_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_py_to_main_productstore
  $(call copy_build_product,$(1))
endef

define delete_build_prod 
  $(CMD_rm) -f $@ $(LOCALTOP)/$(1)/$(@F)
endef

define delete_plugin_build_prod 
  $(call delete_build_prod,$(1)) &&\
  if [ "X$(2)" != X ] ; then \
    if [ -f $($(2)_pluginprod) ] ; then \
      $(CMD_touch) $(LOCALTOP)/$(SCRAM_INTwork)/cache/$($(2)_plugintype)_$($(2)_pluginrefresh) &&\
      $(CMD_rm) -f $(LOCALTOP)/$($(2)_pluginprod) ;\
    fi ;\
  fi
endef

define	clean_path
  @if [ -d $(LOCALTOP)/$(1) ] ; then \
    $(CMD_echo) "Cleaning local working directory:$(1)"; \
    $(CMD_rm) -rf $(LOCALTOP)/$(1) ; \
  fi
endef

define clean_prod
  @if [ -f $(LOCALTOP)/$(1) ] ; then \
    $(CMD_echo) "Cleaning product: $(1)" ; \
    $(CMD_rm) -f $(LOCALTOP)/$(1); \
  fi    
endef

define clean_src_scripts
  @$(call clean_files,$(1),$(2))
endef

define clean_files
  for f in $(1); do \
    $(CMD_rm) -rf $(LOCALTOP)/$(2)/$$f;	\
  done
endef

define edm_plugin_clean
  $(call clean_prod,$($(1)_plugindir)/plugin$(1).$(SHAREDSUFFIX))
  $(call clean_prod,$($(1)_pluginprod))
endef

define rivet_plugin_clean
  $(call clean_prod,$($(1)_pluginprod))
endef

define do_plugin_refresh
endef
#############################################################################
##############################################################################
define check_module_load
  if [ "X$(SHARED_LIB_LOAD_CHECK)" != X ] ; then \
    if [ "X$(1)" = X ] ; then \
      $(CMD_echo) "@@@@ Checking shared library load: $(@F)"	&&\
      ($(SHARED_LIB_LOAD_CHECK) $@ || ($(call delete_plugin_build_prod,$(2),$(3)) && exit 1)) &&\
      $(CMD_echo) "@@@@ ----> OK, shared library loaded successfully: $(@F)" ; \
    else \
      $(CMD_echo) "@@@@ Shared library loading was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)"; \
    fi ;\
  else \
    $(CMD_echo) "@@@@ Shared library loading was SKIPPED due to SCRAM_NOLOADCHECK: $(@F)" ;\
  fi
endef

ifeq ($(filter-out osx%,$(SCRAM_ARCH)),)
  define install_name_tool
    install_name_tool -id $1 $2
  endef
else
  define install_name_tool
    $(CMD_true)
  endef
endif

ifndef SCRAM_NOEDMWRITECONFIG
define edm_write_config
  $(CMD_rm) -rf $(<D)/edm_write_config && $(CMD_mkdir) -p $(<D)/edm_write_config &&\
  $(CMD_echo) "@@@@ Running $(EDM_WRITE_CONFIG) for $(1)" &&\
  ($(CMD_cd) $(<D)/edm_write_config && $(EDM_WRITE_CONFIG) -p $(LOCALTOP)/$<) &&\
  for file in `$(CMD_ls) $(<D)/edm_write_config`; do \
    ([ -d $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package) ] || $(CMD_mkdir) -p $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package)) ;\
    $(CMD_cp) -f $(<D)/edm_write_config/$$file $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package) ;\
    $(CMD_echo) "01:$(CMD_rm) -f $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package)/$$file" >> $(call AutoCleanFile,$<,edm) ;\
  done
endef
else
define edm_write_config
  $(CMD_echo) "@@@@ Skipping $(EDM_WRITE_CONFIG) for $(1) due to SCRAM_NOEDMWRITECONFIG"
endef
endif

define rivet_register_plugin
  @$(startlog_$(2)) if [ -f $< ] ; then \
    [ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
    $(call install_name_tool,$(@F),$<) &&\
    $(CMD_cp) -f $< $@ &&\
    $(CMD_echo) "01:$(CMD_rm) -f $@"               > $(call AutoCleanFile,$<,rivet) &&\
    $(CMD_echo) "--- Registered Rivet Plugin: $(1)"; \
  else \
    $(CMD_rm) -f $@ ;\
  fi $(endlog_$(2))
endef

define edm_register_plugin
  @$(startlog_$(2)) $(CMD_touch) $(LOCALTOP)/$(SCRAM_INTwork)/cache/edm_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
    ($(call edm_write_config,$(1)) || ($(CMD_rm) -f $< && exit 1)) &&\
    plugin=$(patsubst lib%,plugin%,$(<F)) &&\
    $(CMD_echo) "module $$plugin" > $(<D)/$(@F) &&\
    (($(CMD_cp) -f $< $(@D)/$$plugin && $(call install_name_tool,$(patsubst lib%,plugin%,$(<F)),$(@D)/$(patsubst lib%,plugin%,$(<F)))) || ($(CMD_rm) -f $< $(<D)/$$plugin && exit 1)) &&\
    $(CMD_cp) -f $(<D)/$(@F) $@ &&\
    $(CMD_echo) "01:$(CMD_rm) -f $(@D)/$$plugin $@" > $(call AutoCleanFile,$<,edm) &&\
    $(CMD_echo) "90:edmPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,edm) &&\
    $(CMD_echo) "--- Registered EDM Plugin: $(1)"; \
  else \
    $(CMD_rm) -f $@ $(@D)/$(patsubst lib%,plugin%,$(<F)) ;\
  fi $(endlog_$(2))
endef
##############################################################################
##############################################################################
#Compilation Rules
define run_compile_command
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling $(4) $< " &&\
  $(VERB_ECHO) $6 $($7_MMD) $($7_MF) $(basename $@).d $< -o $@ &&\
              ($6 $($7_MMD) $($7_MF) $(basename $@).d $< -o $@ || ($6 $($7_MM) $< -o $(basename $@).d && $(CMD_sed) -i -e 's|.*:|$@:|' $(basename $@).d && exit 1)) $5 $(endlog_$(2))
endef
define compile_cxx_common
  $(call run_compile_command,$1,$2,$3,$4,$5,$(CXX) -c $(3) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS),CXX)
endef
define compile_c_common
  $(call run_compile_command,$1,$2,$3,$4,$5,$(CC)  -c $(3) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS),C)
endef
define compile_fortran_common
  $(call run_compile_command,$1,$2,$3,$4,$5,$(FC)  -c $(3) $(FOPTIMISEDFLAGS) $(FSHAREDOBJECTFLAGS),F77)
endef

#LLVM Analyzer Rules
define run_analyze_command
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Analyzing $(4) $< " &&\
  $(VERB_ECHO) $5 $< -o /dev/null &&\
               $5 $< -o /dev/null $(endlog_$(2))
endef
define analyze_cxx_common
  $(call run_analyze_command,$1,$2,$3,$4,$(CXX) -c $(3) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS))
endef
define analyze_c_common
  $(call run_analyze_command,$1,$2,$3,$4,$(CC) -c $(3) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS))
endef

##############################################################################
define compile_cxx
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CXXFLAGS))
endef
define compile_cxx_capabilities
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,EDM CAPABILITIES,CPPFLAGS CXXFLAGS),capabilities)
endef
define compile_cxx_edm
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,EDM,CPPFLAGS CXXFLAGS),edm plugin)
endef
define compile_c
  $(call compile_c_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CFLAGS))
endef
define compile_c_edm
  $(call compile_c_common,$1,$2,$(call AdjustFlags,$1,EDM,CPPFLAGS CFLAGS),edm plugin)
endef  
define compile_fortran
  $(call compile_fortran_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS FFLAGS))
endef  
define compile_boost
  $(call compile_cxx_common,$1,$2,-DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($*)" $(call AdjustFlags,$1,,CPPFLAGS PY_CXXFLAG),boost)
endef  
define compile_pywrapper
  $(call compile_cxx_common,$1,$2,-DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($(1)_PyWrapper)" $(call AdjustFlags,$1,,CPPFLAGS PY_CXXFLAG),pywrapper)
endef

define analyze_cxx
  $(call analyze_cxx_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CXXFLAGS))
endef
define analyze_c
  $(call analyze_c_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CFLAGS))
endef
##############################################################################
# Dictionary compilation
define processTmpMMDData
  [ -f $(basename $@).d ] && $(CMD_sed) -e 's#$1##g;s#$2:#$<:#g;s#^  *\.\./\(\.\./\)*# #g' $(basename $@).d | $(CMD_grep) -v '^ *\\$$' > $<.dx; mv $<.dx $(basename $@).d
endef
define compile_lcgdict
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling LCG dictionary: $<" &&\
  $(VERB_ECHO)                   $(CXX) $(CXX_MMD) $(CXX_MF) $(1)/$(patsubst $($(1)_objdir)/%,%,$(basename $@).d) -c -I$(LOCALTOP) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@) &&\
  (($(CMD_cd) $($(1)_objdir)/..; $(CXX) $(CXX_MMD) $(CXX_MF) $(1)/$(patsubst $($(1)_objdir)/%,%,$(basename $@).d) -c -I$(LOCALTOP) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@)) || ($(CMD_rm) -f $< && exit 1)) $(endlog_$(2))
  @$(call processTmpMMDData,$(1)/$(patsubst $($(1)_objdir)/%,%,$<),$(1)/$(patsubst $($(1)_objdir)/%,%,$@))
endef
# Root Dictionary compilation
define compile_rootdict
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,ROOTDICT,CPPFLAGS CXXFLAGS),root dictionary,|| ($(CMD_rm) -f $< && exit 1))
  @$(call processTmpMMDData,$<,$@)
endef
define compile_python
  $(CMD_echo) ">> Compiling python modules $1" &&\
  $(VERB_ECHO) "$(CMD_python) -m compileall -q $1" &&\
  $(CMD_python) -m compileall -q $1 || $(CMD_touch) $(COMMON_WORKINGDIR)/cache/python_error
endef
##############################################################################
# Source Generators Rules
# boost source generation from Pyste
define pyste2boost
  @$(startlog_$(2))$(CMD_echo)  ">> Generating and compiling Boost stub for module $*" 	&& \
  $(VERB_ECHO) python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< &&\
  python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< $(endlog_$(2))
endef  
# PyWrapper Generation
define generate_pywrapper
  @$(startlog_$(2))$(CMD_echo) "Generating wrapper code to put the following files in a single module called: $(1)" $(endlog_$(2))
  @exec 5>&1;	\
  ( $(CMD_echo) "#include <boost/python.hpp>"; echo;	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    $(CMD_echo) "  $$c" 1>&5;				\
    $(CMD_echo) "extern void init_module_$$c ();";	\
  done;						\
  echo; $(CMD_echo) "void init_module_$(1) () {";	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    $(CMD_echo) "  init_module_$$c ();";		\
  done;						\
  $(CMD_echo) "}"; echo;				\
  $(CMD_echo) "extern \"C\" void init$(1) () {";	\
  $(CMD_echo) 'boost::python::detail::init_module("$(1)",'\
	'init_module_$(1));';			\
  $(CMD_echo) "}";					\
  ) > $@.tmp
  @$(CMD_mv) $@.tmp $@
endef  
#LCG dictionary generation
define generate_classes_h
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) && $(CMD_rm) -f $@ &&\
  $(CMD_echo) ">> Generating LCG reflex dict header file $(patsubst $(LOCALTOP)/$(SCRAM_SOURCEDIR)/%,%,$<)" &&\
  $(VERB_ECHO) $(CLASSES_H_GENERATOR) $< &&\
  (            $(CLASSES_H_GENERATOR) $< > $@ || ($(CMD_rm) -f $@ && exit 1)) \
  $(endlog_$(2))
endef

define generate_lcgdict
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) && $(CMD_rm) -f $@ &&\
  $(CMD_echo) ">> Building LCG reflex dict from header file $(patsubst $(LOCALTOP)/%,%,$4)" &&\
  $(VERB_ECHO) $(GENREFLEX) $(4) -s $(3) -o $@ $($(6)_GENREFLEX_ARGS) --gccxmlopt=\"$(GENREFLEX_GCCXMLOPT)\" --gccxmlpath=$(GCCXML_BASE)/bin --capabilities=$(notdir $(5)) $(GENREFLEX_CPPFLAGS) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS) &&\
               $(GENREFLEX) $(4) -s $(3) -o $@ $($(6)_GENREFLEX_ARGS) --gccxmlopt="$(GENREFLEX_GCCXMLOPT)"   --gccxmlpath=$(GCCXML_BASE)/bin --capabilities=$(notdir $(5)) $(GENREFLEX_CPPFLAGS) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS) \
  $(endlog_$(2))
endef
# ROOt dictionary generation
define generate_rootdict
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Building Root dict from header file $< " &&\
  $(VERB_ECHO) $(ROOTCINT) -f $@ -c -p -DGNU_SOURCE $(call AdjustFlags,$1,ROOTDICT,CPPFLAGS) $< &&\
  (            $(ROOTCINT) -f $@ -c -p -DGNU_SOURCE $(call AdjustFlags,$1,ROOTDICT,CPPFLAGS) $< || ($(CMD_rm) -f $@ && exit 1)) &&\
  $(CMD_mv) $@ $@.base	&&\
  $(CMD_cat) $< $@.base > $@ &&\
  $(CMD_rm) -f $@.base $(endlog_$(2))
endef
# CodeGen record Generation
define generate_codegen_record
  @$(startlog_$(2))$(CMD_echo) ">> Generating file $(@F) from class descriptor $<" &&\
  $(VERB_ECHO) $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< &&\
  $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< $(endlog_$(2))
endef
# MOC generation
define generate_moc
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Running moc ( $(3) ) for $<" &&\
  $(3) -o $@ $< $(endlog_$(2))
endef
# Flex Generaton
define generate_lex
  @$(startlog_$(2))$(CMD_echo) "Flex: Generating $@ from $<" &&\
  $(VERB_ECHO) $(LEX) -o$@ -P$(patsubst %lex,%,$*) $< &&\
  ($(LEX) -o$@ -P$(patsubst %lex,%,$*) $< || ($(CMD_rm) -f $@ && exit 1))$(endlog_$(2))
endef
define generate_parse
  @$(startlog_$(2))$(CMD_echo) "Bison: Generating $@ from $<" &&\
  $(VERB_ECHO) $(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< &&\
  ($(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< ||($(CMD_rm) -f $(basename $@).h $(basename $@).cc && exit 1)) &&\
  $(CMD_cd) $(WORKINGDIR)/$(3) &&\
  $(CMD_rm) -f $*parse.h && $(CMD_ln) -s $(1)/$*parse.h $*parse.h $(endlog_$(2))
endef
##############################################################################
define processMMDData
  $(startlog_$(2))$(CMD_rm) -f $3 && $(CMD_touch) $3 &&\
  for dep in $4 ; do \
    if [ -f $$dep ] ; then $(CMD_sed) -e 's|.*$(LOCALTOP)/| |g$(if $(strip $(DROP_EXTERNAL_HEADER_MMD_DEPS)),;s|^  */.*||,)' $$dep | $(CMD_grep) -v '^ *$$' >> $3 ; $(CMD_echo) "" >> $3; fi ; \
  done &&\
  $(if $(strip $(DROP_EXTERNAL_HEADER_MMD_DEPS)),$(CMD_true),$(call addMMDDepsRules,$3)) $(endlog_$(2))
endef
define addMMDDepsRules
  $(CMD_tr) ' ' '\012' <  $1 | $(CMD_sed) -e 's/^'\\\\'$$//;/^$$/ d;/:$$/ d;s/$$/ :/' > $1.new &&\
  $(CMD_sort) $1.new | $(CMD_uniq) >> $1 &&\
  $(CMD_rm) -f $1.new
endef
##############################################################################
# Library linking Rules
# Shared library linking
define link_lib_common
  @$(startlog_$(2))$(CMD_echo) ">> Building $(5) $@" &&\
  $(CMD_touch) $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO)                $(CXX) $(6) $(LD_BIG_OPT) $(CXXSHAREDFLAGS) $(call GetMissingSymbolFlags,$1)     $($(1)_objs) -o $@ $(if $7,$7,$(call AdjustFlags,$1,,LDFLAGS)) &&\
  (($(call checklibs,$(1)) && $(CXX) $(6) $(LD_BIG_OPT) $(CXXSHAREDFLAGS) $(call GetMissingSymbolFlags,$1,yes) $($(1)_objs) -o $@ $(if $7,$7,$(call AdjustFlags,$1,,LDFLAGS))) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(1)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) $(endlog_$(2))
  @if [ "X$(BIGLIBS)" = "X" ] ; then $(call processMMDData,$1,$2,$@.dep,$(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d)); fi
endef
define link_lib
  $(call link_lib_common,$1,$2,$3,$4,shared library,$(call AdjustFlags,$1,,CXXFLAGS))
endef  
define link_lib_edm
  $(call link_lib_common,$1,$2,$3,$4,edm plugin,$(call AdjustFlags,$1,EDM,CXXFLAGS),$(call AdjustFlags,$1,EDM,LDFLAGS))
endef
define link_pylib
  @$(startlog_$(2))$(CMD_echo) ">> Building Python module $($(1)_product)" && \
  $(CMD_touch) $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO)                $(CXX) $(LD_BIG_OPT) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $($(1)_CXXSharedLink) &&\
  (($(call checklibs,$(1)) && $(CXX) $(LD_BIG_OPT) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $($(1)_CXXSharedLink)) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_lib_to_main_productstore,$(3)) $(endlog_$(2))
  @if [ "X$(BIGLIBS)" = "X" ] ; then $(call processMMDData,$1,$2,$@.dep,$(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d)) ; fi
endef  
#Shared Capabilities library
define link_lib_capabilities
  @$(startlog_$(2))$(CMD_echo) ">> Building capability library $@" &&\
  $(VERB_ECHO)                $(CXX) $(LD_BIG_OPT) $(call AdjustFlags,$1,EDM CAPABILITIES,CXXFLAGS) $(call GetMissingSymbolFlags,$1)     $(CXXSHAREDFLAGS) $5 -o $@ $(call AdjustFlags,$(4)_CDICT,EDM LCGDICT,LDFLAGS) &&\
  (($(call checklibs,$(1)) && $(CXX) $(LD_BIG_OPT) $(call AdjustFlags,$1,EDM CAPABILITIES,CXXFLAGS) $(call GetMissingSymbolFlags,$1,yes) $(CXXSHAREDFLAGS) $5 -o $@ $(call AdjustFlags,$(4)_CDICT,EDM LCGDICT,LDFLAGS)) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(4)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) &&\
  $(call check_edm_class_version,$1,$6,$3,$4) $(endlog_$(2))
endef

##############################################################################
# Binary/test building Rules
# Binary building 
define build_bin
  @$(startlog_$(2))$(CMD_echo) ">> Building binary $(1)" &&\
  $(VERB_ECHO)                $(CXX) $(call AdjustFlags,$1,$4,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $($(1)_LDFLAGS) -o $@ &&\
  (($(call checklibs,$(1)) && $(CXX) $(call AdjustFlags,$1,$4,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $($(1)_LDFLAGS) -o $@) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_bin_to_main_productstore,$(3)) $(endlog_$(2))
  @$(call processMMDData,$1,$2,$@.dep,$(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d))
endef
# Test executable building
define build_test
  $(call build_bin,$(1),$(2),$(3),$(4))
endef  
##############################################################################
# Data download and Copy
define script_copy
  @$(startlog_$(2))[ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
  $(CMD_rm) -rf $@ &&\
  $(CMD_cp) -rp $< $@	&&\
  $(CMD_echo) ">> Copied $(@F)" $(endlog_$(2))
endef
define generate_python_bytecode
  if [ "X$(PYTHON_COMPILE)" != X ] ; then \
    $(CMD_echo) ">> Generating python byte-code: $(1)" && \
    python $(PYTHON_COMPILE) -f $(1) >/dev/null 2>&1; \
  else \
    $(CMD_echo) "Python tool is not used. So not going to generate byte-code." ; \
  fi
endef
define python_script_copy
  @$(startlog_$(2))if [ ! -d $(LOCALTOP)/$(3) ]; then \
    $(CMD_mkdir) -p $(LOCALTOP)/$(3) &&\
    $(CMD_echo) "Creating product storage directory: $(LOCALTOP)/$(3)"; 	\
  fi &&\
  $(CMD_rm) -rf $($(1)_python_dir) && $(CMD_mkdir) -p $($(1)_python_dir) &&\
  $(CMD_echo) ">> Copying python/* to $($(1)_python_dir)" &&\
  for name in `$(CMD_ls) $($(1)_srcdir) | $(CMD_grep) -v "CVS\|BuildFile\|BuildFile.xml"` ; do \
    f=$($(1)_srcdir)/$$name &&\
    if [ -d $$f ] ; then \
      $(CMD_cp) -rp $$f $($(1)_python_dir) || continue ;\
    else  \
      [ "X`$(CMD_echo) $$f | $(CMD_grep) '\.py$$'`" != X ] || continue ; \
      $(CMD_cp) -rp $$f $($(1)_python_dir)/ || continue ;\
    fi \
  done &&\
  $(call generate_python_bytecode,$(LOCALTOP)/$($(1)_python_dir)) &&\
  for dir in `$(CMD_find) $($(1)_python_dir) -name "*" -type d` ; do \
    if [ ! -f $$dir/__init__.py ] ; then \
      $(CMD_touch) $$dir/__init__.py; \
    fi \
  done &&\
  $(CMD_touch) $($(1)_python_dir)/__init__.py &&\
  $(CMD_touch) $($(1)_python_dir)/../__init__.py $(endlog_$(2))
endef
define copy_src_scripts
  @$(startlog_$(2))$(CMD_echo) "------- copying scripts from $(1) -------" &&\
  for f in $(3); do \
    [ -f $(LOCALTOP)/$(1)/$$f ] || continue ;\
    $(CMD_echo) ">> Copying $(LOCALTOP)/$(1)/$$f"	&&\
    $(CMD_cp) -p $(LOCALTOP)/$(1)/$$f  $(LOCALTOP)/$(4) || continue ;\
  done $(endlog_$(2))
endef
define src2store_copy
  @$(startlog_$(2)) $(CMD_echo) "------- copying files from $(1) -------" &&\
  [ -d $(LOCALTOP)/$(4) ] || $(CMD_mkdir) -p $(LOCALTOP)/$(4) &&\
  for f in $(3) ; do \
    if [ -d $(LOCALTOP)/$(4)/$$f ] ; then \
      $(CMD_rm) -rf $(LOCALTOP)/$(4)/$$f; \
    fi &&\
    $(CMD_cp) -rp $(LOCALTOP)/$(1)/$$f $(LOCALTOP)/$(4)/$$f &&\
    $(CMD_echo) ">> copied $$f"; \
  done $(endlog_$(2))
endef
define copy_python_products
  @$(startlog_$(2))[ -d $(4) ] || ($(CMD_mkdir) -p $(4) && $(CMD_echo) ">> $(4) created") &&\
  $(CMD_cp) $(3) $(4) $(endlog_$(2))
endef
#############################################################################
# Tesings test executable
define run_test
  @if [ "X$($(1)_NO_TESTRUN)" == "Xyes" ] ; then \
    $(CMD_echo) "Package "$(patsubst $(SCRAM_SOURCEDIR)/%/test,%,$(4))": Skipping test $(1)"; \
  else \
    $(CMD_echo) "Package "$(patsubst $(SCRAM_SOURCEDIR)/%/test,%,$(4))": Running test $(1)" &&\
    [ -d $($(1)_objdir) ] || $(CMD_mkdir) -p $($(1)_objdir) &&\
    $(CMD_rm) -f $($(1)_objdir)/testing.log; $(CMD_touch) $($(1)_objdir)/testing.log  &&\
    $(CMD_echo) " " >> $($(1)_objdir)/testing.log &&\
    $(CMD_echo) "===== Test \"$(1)\" ====" >> $($(1)_objdir)/testing.log &&\
    export PATH=$(LOCALTOP)/$(2):$(LOCALTOP)/$(4):$(PATH) && (($($(1)_TEST_RUNNER_CMD)) >> $($(1)_objdir)/testing.log 2>&1 || ($(CMD_echo) "" && $(CMD_echo) "---> test $(1) had ERRORS") >> $($(1)_objdir)/testing.log) &&\
    $(CMD_echo) " " >> $($(1)_objdir)/testing.log &&\
    $(CMD_echo) "^^^^ End Test $(1) ^^^^" >> $($(1)_objdir)/testing.log &&\
    $(CMD_cat) $($(1)_objdir)/testing.log &&\
    $(CMD_cat) $($(1)_objdir)/testing.log >> $(LOCALTOP)/$(3)/testing.log; \
  fi
endef

##############################################################################
define bf_update
  @if [ ! -f $@ ] || [ "X$($(1)_BuildFile)" = X ] ; then \
    $(CMD_touch) $@;\
  elif [ "X`$(call get_time_stamp,$@)`" != "X`$(call get_time_stamp,$($(1)_BuildFile))`" ] ; then \
      $(CMD_touch) $@;\
  fi
endef
define config_update
  @[ -d  $(@D)] || $(CMD_mkdir) -p $(@D) ; $(CMD_touch) $@ ;\
  if [ "X$($(1)_BuildFile)" != X ] ; then \
    $(CMD_touch) -r $($(1)_BuildFile) $(WORKINGDIR)/cache/bf/$(1);\
  fi
endef
define timestamp_cmp
  $(CMD_perl) -e "my @s1=stat '$1'; my @s2=stat '$2';"'print $$s1[9]<=>$$s2[9];'
endef
define get_time_stamp
  $(CMD_perl) -e 'my @d=stat "$(1)"; print "$$d[9]\n";'
endef
define libdeps
$(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_LOC_LIB) $(foreach u,$($(1)_LOC_USE) $($(1)_EX_USE),$($u) $($($u)_EX_LIB) $($($u)_EX_UOLIB))))
endef
#############################################################################
define SubSystem
.PHONY: $(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2) runtests_$(2) unittests_$(2) compile_$(2) precompile_$(2)
$(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2): $(subdirs_$(2))
	@$(CMD_echo) ">> Subsystem $(1) built"
runtests_$(2): $(addprefix runtests_,$(subdirs_$(2)))
	@:
unittests_$(2): $(addprefix unittests_,$(subdirs_$(2)))
	@:
runpython_$(2): $(addprefix runpython_,$(subdirs_$(2)))
	@:
compile_$(2): $(addprefix compile_,$(subdirs_$(2)))
	@:
precompile_$(2): $(addprefix precompile_,$(subdirs_$(2)))
	@:
endef
define EmptyPackage
$(1)_libdeps      := $$(call libdeps,$1)
$(1)_CONFIGDEPS := $(CONFIGDEPS) $$(sort $$(foreach u,$$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$$($$($$(u))_XDEPS) $$(if $$($$($$(u))_BuildFile),$$($$($$(u))_BuildFile),$$(filter $(SCRAM_TOOLS_DIR)/$$(u),$(ToolTimeStamps)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
endif
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_BuildFile) $$($(1)_libdeps)
	@$(CMD_touch) $$@
endef
define Package
.PHONY: $(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2) runtests_$(2) unittests_$(2) compile_$(2) precompile_$(2)
ifeq ($(strip $(BUILD_LOG)),yes)
logfile_$(2) := $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1)/build.log
redirectlog_$(2) := >> $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1)/build.log
else
logfile_$(2) := 
redirectlog_$(2) := 
endif
$(WORKINGDIR)/cache/msg/$(SCRAM_SOURCEDIR)/$(1).msg: $$(logfile_$(2)) FORCE_TARGET
	@$(DO_BUILD_LOG) $(CMD_echo) ">> Entering Package $(1)" $$(redirectlog_$(2)) &&\
	$(CMD_echo) ">> Entering Package $(1)" $(if $(HOOK_PACKAGE), && $(HOOK_PACKAGE) -s -p $1,) &&\
	[ -d $$(@D) ] || $(CMD_mkdir) -p $$(@D) && $(CMD_touch) -t $(OLD_TIMESTAMP) $$@
$(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2): $(WORKINGDIR)/cache/msg/$(SCRAM_SOURCEDIR)/$(1).msg $(addprefix all_,$(subdirs_$(2)))
	$$(call outputlog,$(1),$(2))
	@$(DO_BUILD_LOG) $(CMD_echo) ">> Leaving Package $(1)"  $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) $(CMD_echo) ">> Package $(1) built" $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) $(CMD_cat) $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1)/build.log &&\
	$(CMD_echo) ">> Leaving Package $(1)" &&\
	$(CMD_echo) ">> Package $(1) built" $(if $(HOOK_PACKAGE), && $(HOOK_PACKAGE) -e -p $1,)
ifeq ($$(filter $(2)_test,$(subdirs_$(2))),$(2)_test)
runtests_$(2): $(2) runtests_$(2)_test
	@$(CMD_echo) ">> Tests for package $(1) ran."
unittests_$(2): unittests_$(2)_test
	@$(CMD_echo) ">> Tests for package $(1) ran."
endif
precompile_$(2): $(addprefix precompile_,$(subdirs_$(2)))
	@:
compile_$(2): $(addprefix compile_,$(subdirs_$(2)))
	@:
ifeq ($$(filter $(2)_python,$(subdirs_$(2))),$(2)_python)
runpython_$(2): runpython_$(2)_python
	@$(CMD_echo) ">> Python for package $(1) ran."
endif
endef

define addPlugin
$(2)_pluginname    := $(1)
ALL_$(3)_PLUGINS   += $(1)
$(1)_plugintype    := $(3)
$(1)_no_lib_copy   := $(4)
$(1)_plugindir     := $(5)
$(1)_pluginrefresh := $(6)
$(1)_plugincache   := $(7)
$(1)_pluginprod    := $(5)/$(8)
$(1)_pluginlib     := $($(2)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
all_$(2)           += $(5)/$(8)
$(1)_extra_deps    += $(WORKINGDIR)/cache/prod/$(6) 
ifndef SCRAM_NOEDMWRITECONFIG
ifeq ($$(strip $(3)),edm)
$(1)_extra_deps    += $(WORKINGDIR)/cache/prod/$(EDM_WRITE_CONFIG)
$(1)_package       := $(patsubst $(SCRAM_SOURCEDIR)/%,%,$(patsubst self/%,%,$($(1))))
$(1)_package       := $$(if $$(strip $$(filter $$($(1)_package),$(ALL_PACKAGES))),$$($(1)_package),$$(dir  $$($(1)_package)))
endif
endif
$(5)/$(8): $$($(1)_pluginlib) $$($(1)_extra_deps)
	$$(call $(3)_register_plugin,$(1),$(9))
endef
define edmPlugin
ifneq ($(strip $($(1)_objs)$(filter $1,${2}Capabilities)),)
$$(eval $$(call addPlugin,$1,$2,edm,yes,$3,edmPluginRefresh,.edmplugincache,$(1).edmplugin,$1))
$(1)_BUILDRULES := _edm
else
$$(info gmake: *** [$4 contains only $(SCRAM_BUILDFILE).xml without any sources. Better to remove $(SCRAM_BUILDFILE).xml too or do not tag this directory] Error 1)
endif
endef
define rivetPlugin
$(eval $(call addPlugin,$1,$2,rivet,yes,$3,,,Rivet$(1).$(SHAREDSUFFIX),$1))
endef

ifeq ($(strip $(SCRAM_MULTIPLE_COMPILERS)-$(SCRAM_COMPILER)),yes-$(LLVM_ANALYZER))
define CXXCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile FORCE_LLVM_CHECK
	$$(call analyze_cxx,$(1),$(3))
endef
define CCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile FORCE_LLVM_CHECK
	$$(call analyze_c,$(1),$(3))
endef
else
define CXXCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_cxx$(4),$(1),$(3))
endef
define CCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_c$(4),$(1),$(3))
endef
endif

define F77CompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $$($(1)_objdir)/precompile
	$$(call compile_fortran$(4),$(1),$(3))
endef

define EmptyProduct
.PHONY: $(1) all_$(1) $(2) all_$(2)
$(1) $(2): all_$(1)
	@:
endef

define LogFile
startlog_$(1) = $$(FORCE_BUILD_START)
endlog_$(1)   = $$(FORCE_BUILD_END)
ifeq ($$(strip $$(BUILD_LOG)),yes)
redirectlog_$(1) := >> $(WORKINGDIR)/cache/log/$(2)/$(1)
startlog_$(1) += (
endlog_$(1)   += ) $$(redirectlog_$(1)) 2>&1
logfile_$(1)  := $(WORKINGDIR)/cache/log/$(2)/$(1)
else
logfile_$(1)     := 
redirectlog_$(1) := 
endif
endef

#safename,path,safepath,scriptstore,scripts,binstore
define CommonBinaryHead
$(3)          += all_$(1)
$(eval $(call LogFile,$(1),$(2)))
.PHONY: $(1) all_$(1)
$(1)_objdir := $(WORKINGDIR)/$(2)/$(1)
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES), $($(1)_files))
$(1)_files_exts   := $$(sort $$(patsubst .%,%,$$(suffix $$($(1)_files))))
$(1)_LOC_USE_BIG  := $(if $(strip $(BIGLIBS)),$$(sort $$(foreach o,$$($(1)_LOC_USE),$$($$($$(o))_bigprod))),)
$(1)_LOC_USE      += $$(if $$(strip $$(filter $(FORTRANSRC_FILES_SUFFIXES),$$($(1)_files_exts))),$(F77_TYPE_COMPILER),) $$($(1)_LOC_USE_BIG)
$(1)_libdeps      := $$(call libdeps,$1)
$(1)_objs         := $$(addprefix $$($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$($(1)_files)))) $(if $(strip $(BIGLIBS)),$(call BigObjectsPaths,$($(1)_bigobjs)))
ifneq ($(strip $(5)),)
.PHONE: $(1)_install_scripts_rule
$(1)_install_scripts_rule: $(logfile_$(1))
	$$(call copy_src_scripts,$(2),$(1),$(5),$(4))
all_$(1) += $(1)_install_scripts_rule
endif
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(WORKINGDIR)/$(2)/productautocleanup $$(sort $$(foreach u,$$(sort $$($(1)_LOC_USE) $($(1)_EX_USE)),$$($$($$(u))_XDEPS) $$(if $$($$($$(u))_BuildFile),$$($$($$(u))_BuildFile),$$(filter $(SCRAM_TOOLS_DIR)/$$(u),$(ToolTimeStamps)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ifeq ($(filter $($(1)_BuildFile),$(ALL_BUILDFILES)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
endif
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
endif
$(1)_config += $(WORKINGDIR)/cache/msg/$(2)/$(1).msg $$($(1)_objdir)/config $(if $(strip $(filter $($(3)_parent),$(ALL_PACKAGES))),$(WORKINGDIR)/cache/msg/$(SCRAM_SOURCEDIR)/$($(3)_parent).msg,)
endef

#safename,path,productstore,type,logprodstore,safepath
define CommonBinaryTail
$(eval $($(1)_PRE_INIT_FUNC))
ifneq ($$(strip $($(1)_objs)),)
ALL_$(4)_PRODUCTS += $(1)
ifeq ($(strip $(4)),lib)
$$(eval $$(call BigObject,$1,$1,$($(1)_objs)))
endif
$(1):  $($(1)_objdir)/$($(1)_product)
ifeq ($(strip $(if $(strip $($(1)_bigprod)),obj)$(filter lib,$(4))),objlib)
$(SCRAMSTORENAME_OBJS)/$($(1)_product): $($(1)_objdir)/$($(1)_product)
	@:
$($(1)_objdir)/$($(1)_product): $($(1)_objdir)/compile
	$$(call big_obj,$1,$1,$($(1)_objs),$(SCRAMSTORENAME_OBJS),yes)
else
$($(1)_objdir)/$($(1)_product): $($(1)_objdir)/compile $($(1)_libdeps) $(if $(strip $(BIGLIBS)),$($(1)_pkgs))
ifeq ($(strip $(4)),lib)
	$$(call link_lib$($(1)_BUILDRULES),$(1),$(1),$(3),$($(1)_pluginname))
	@$$(startlog_$(1)) $(if $(HOOK_PRODUCT),$(HOOK_PRODUCT) -e -p $1,$(CMD_true)) $$(endlog_$(1))
ifeq ($(strip $(BIGLIBS)),yes)
	@$$(startlog_$(1))$(CMD_echo) "Leaving big library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
else
	@$$(startlog_$(1))$(CMD_echo) "Leaving library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
endif
endif
ifeq ($(strip $(4)),bin)
	$$(call build_bin,$(1),$(1),$(3),BIN)
endif
ifeq ($(strip $(4)),python)
	$$(call link_pylib,$(1),$(1),$(3))
endif
ifeq ($(strip $(4)),test)
	$$(call build_test,$(1),$(1),$(3),TEST)
.PHONE: runtests_$(1) unittests_$(1)
ifeq ($$(strip $$(filter $(1),$(SKIP_UNITTESTS))),$(1))
$(1)_NO_TESTRUN := yes
endif
runtests_$(6) += runtests_$(1)
unittests_$(6) += unittests_$(1)
runtests_$(1): all_$(1) unittests_$(1)
	@:
unittests_$(1): $(patsubst %,runtests_%,$($(1)_PRE_TEST)) $(LOCALTOP)/$(5)/testing.log
	$$(call run_test,$(1),$(3),$(5),$(2))
endif
endif
$(WORKINGDIR)/cache/prod/$(1): $($(1)_objdir)/$($(1)_product)
	@if [ ! -f $$@ ] ; then $(CMD_touch) $$@; fi
ifneq ($$(strip $($(1)_product)),)
ifneq ($(wildcard $($(1)_objdir)/$($(1)_product).dep),)
-include $($(1)_objdir)/$($(1)_product).dep
endif
endif
$(WORKINGDIR)/cache/msg/$(2)/$(1).msg: $(logfile_$(1)) FORCE_TARGET
	@$$(startlog_$(1))[ -d $$(@D) ] || $(CMD_mkdir) -p $$(@D) && $(CMD_touch) -t $(OLD_TIMESTAMP) $$@ $(if $(HOOK_PRODUCT), && $(HOOK_PRODUCT) -s -p $1,) $$(endlog_$(1))
precompile_$(6):: $($(1)_objdir)/precompile $($(1)_extra_files)
	@:
compile_$(6):: $($(1)_objdir)/compile
	@:
$($(1)_objdir)/precompile: $($(1)_config) $($(1)_precompile) $(logfile_$(1))
	@$(CMD_touch) $$@
ifeq ($$(strip $(4)),lib)
	@$(startlog_$(1))$(CMD_echo) "Entering library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
endif
$($(1)_objdir)/compile: $($(1)_objdir)/precompile $($(1)_objs) $($(1)_compile)
	@$(CMD_touch) $$@
$($(1)_objdir)/link: $($(1)_objdir)/compile $($(1)_objdir)/$($(1)_product) $($(1)_link)
	@$(CMD_touch) $$@
all_$(1): $($(1)_objdir)/link $$(all_$(1))
	@:
else
ifneq ($(strip $($(1)_bigprod)),)
$$(eval $$($(1)_bigprod)_bigobjs := $$(filter-out $1,$$($$($(1)_bigprod)_bigobjs)))
endif
endif
endef

define FindBuildFile
$(if $(wildcard $(1).xml),$(1).xml,$(1))
endef

define MultipleWarningMsg
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(multipletools),****WARNING: Multiple products with same name $(1))
$$(call $$(multipletools),             Previous defination: $($(1)))
$$(call $$(multipletools),             Current  defination: $(2))
endif
endef

define ProductWithNoFiles
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building of $(1) from $$(call FindBuildFile,$(2)/$(SCRAM_BUILDFILE)) because)
ifeq ($(strip $(3)),)
$$(info $$(space)             there are no files mentioned in the this Buildfile)
else
$$(info $$(space)             \"$(3)\" does not match any file under $(2) directory)
endif
endif
endef

define UseError
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(wrongtool),****WARNING: Invalid tool $(1). Please fix $$(call FindBuildFile,$$(subst tmp/$(SCRAM_ARCH)/cache/bf/,,$2)) file.)
endif
endef

#safename
define CompileRules
$(foreach ext,$(filter $(CXXSRC_FILES_SUFFIXES),    $($(1)_files_exts)),$(eval $(call CXXCompileRule,$(1),$(ext),$(1),$($(1)_BUILDRULES))))
$(foreach ext,$(filter $(CSRC_FILES_SUFFIXES),      $($(1)_files_exts)),$(eval $(call CCompileRule,$(1),$(ext),$(1),$($(1)_BUILDRULES))))
$(foreach ext,$(filter $(FORTRANSRC_FILES_SUFFIXES),$($(1)_files_exts)),$(eval $(call F77CompileRule,$(1),$(ext),$(1))))
endef

#safename,path,safepath,scriptstore,scripts,productstore,type,logprodstore
define Binary
ifneq ($(strip $(BIGLIBS)$(BIGOBJS)),)
$(1)_LOC_LIB := $$(sort $$(foreach l,$$($(1)_LOC_LIB),$$(if $$(strip $$($$(l)_bigprod)),$$($$(l)_bigprod),$$l)))
endif
$$(eval $$(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
ALL_BINARIES += $(1)
$(1)_product := $(1)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(6),$(7),$(8),$(3)))
$$(eval $$(call CompileRules,$(1)))
endef

#safename,path,safepath,scriptstore,scripts,libstore,logprodstore
define Library
$(eval $(call LibraryHead,$(1),$(2),$(3),$(4),$(5)))
$(eval $(call LibraryTail,$(1),$(2),$(6),$(7),$(3)))
endef

#safename,path,safepath,scriptstore,scripts
define LibraryHead
$(eval $(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
ifeq ($(strip $($(1)_bigprod)),)
$(1)_product      := $(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
else
$(1)_product      := $(1).$(BIGLIB_OBJEXT)
endif
endef

#safename,path,libstore,logprodstore,safepath
define LibraryTail
$(eval $(call CommonBinaryTail,$(1),$(2),$(3),lib,$(4),$(5)))
ifneq ($$(strip $$($(1)_objs)),)
ifeq ($(strip $($(1)_bigprod)),)
ALL_LIBRARIES += $(1)
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_objdir)/$($(1)_product)
	@:
endif
$$(eval $$(call CompileRules,$(1)))
else
$(1) all_$(1): $$(all_$(1))
	@:
endif
endef

define AddExtraPythonProdRule
$(if $(2),$(eval $(call ExtraPythonProd,$(1),$(firstword $(2)),$(firstword $(3))))$(eval $(call AddExtraPythonProdRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)))),)
endef

define ExtraPythonProd
all_$(1)_extra_python_prod += $(3)/$(2)
$(3)/$(2): $(2) $(1)_copy_python_scripts $($(1)_CONFIGDEPS)
	@$(CMD_echo) ">> Copying python products \"$(2)\" => $(3)"
	$$(call copy_python_products,$(1),$(logfile_$(1)),$(2),$(3))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,xprodfiles,xproddirs
define PythonProductHead
$(3)          += all_$(1)
.PHONY: $(1) all_$(1) $(1)_copy_python_scripts
$(eval $(call LogFile,$(1),$(2)))
$(1)_objdir       := $(WORKINGDIR)/$(2)/$(1)
$(1)_python_dir := $(addprefix $(6)/,$(patsubst $(SCRAM_SOURCEDIR)/%/python,%,$(2)))
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES), $($(1)_files))
$(1)_files_exts   := $$(sort $$(patsubst .%,%,$$(suffix $$($(1)_files))))
$(1)_LOC_USE      += $$(if $$(strip $$(filter $(FORTRANSRC_FILES_SUFFIXES),$$($(1)_files_exts))),$(F77_TYPE_COMPILER),)
$(1)_CONFIGDEPS := $(CONFIGDEPS) $$(sort $$(foreach u,$$(sort $$($(1)_LOC_USE) $($(1)_EX_USE)),$$($$($$(u))_XDEPS) $$(if $$($$($$(u))_BuildFile),$$($$($$(u))_BuildFile),$$(filter $(SCRAM_TOOLS_DIR)/$$(u),$(ToolTimeStamps)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
endif
$(1)_config += $$($(1)_objdir)/config
all_$(1) += $(1)_copy_python_scripts
ifeq ($(strip $(4)),1)
ifeq ($$(strip $(5)),1)
$(1)_copy_python_scripts: $(logfile_$(1)) $(COMMON_WORKINGDIR)/cache/python_symlinks
	@:
else
$(1)_copy_python_scripts: $(logfile_$(1))
	$$(call python_script_copy,$(1),$(logfile_$(1)),$(6))
endif
else
$(1)_copy_python_scripts: $(logfile_$(1))
	@$(CMD_echo) "No source files to compile. Nothing to be done for Python modules at $(2)."
endif
runpython_$(3): $(1)_copy_python_scripts
	@:
ifneq ($(strip $(7)),)
.PHONY: $(1)_extra_python_prod
all_$(1) += $(all_$(1)_extra_python_prod)
$(eval $(call AddExtraPythonProdRule,$(1),$(7),$(8)))
all_$(1) += $(all_$(1)_extra_python_prod)
endif
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_files        := $$(notdir $$(wildcard $$(foreach dir,$$($(1)_srcdir),$$(foreach ext,$(CXXSRC_FILES_SUFFIXES),$$(dir)/*.$$(ext)))))
$(1)_files        += $$(patsubst %.pyste,%_boost.cc,$$(notdir $$(wildcard $$($(1)_srcdir)/*.pyste)))
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES),$$($(1)_files))
endef

define PythonProductFlags
$(1)_files        += $($(1)_objdir)/$(1)_PyWrapper.cc
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_PY_CXXFLAGS   = $$(filter-out -pedantic-errors -ansi, $$($(1)_CXXFLAGS))
$(1)_libdeps      := $$(call libdeps,$1)
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_classnames   := $$(patsubst %_boost,%,$$(filter %_boost,$$(basename $$(notdir $$($(1)_files)))))
$(1)_CXXSharedLink = -rdynamic $$($(1)_LDFLAGS)
endef

#safename,path,productstore,logprodstore,safepath
define PythonProductTail
$(1)_product := $(1).$(SHAREDSUFFIX)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(3),python,$(4),$(5)))
$$(eval $$(call CompileRules,$(1)))
.PRECIOUS: $($(1)_objdir)/%_boost.cc
$($(1)_objdir)/%_boost.cc: $($(1)_srcdir)/%.pyste $($(1)_config)
	$$(call pyste2boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_srcdir)/%_boost.cc $($(1)_config)
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_objdir)/%_boost.cc
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.o: $($(1)_objdir)/$(1)_PyWrapper.cc
	$$(call compile_pywrapper,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.cc: $($(1)_config)
	$$(call generate_pywrapper,$(1),$(1))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,libstore,xprodfiles,xproddirs,logprodstore
define PythonProduct
$(eval $(call PythonProductHead,$(1),$(2),$(3),$(4),$(5),$(6),$(8),$(9)))
ifneq ($$(strip $$($(1)_files)),)
ifneq ($$(strip $$($(1)_BuildFile)),)
ifneq ($$(strip $$(filter boost_python,$($(1)_LOC_USE))),)
$$(eval $$(call PythonProductFlags,$(1)))
$$(eval $$(call PythonProductTail,$(1),$(2),$(7),$(10),$(3)))
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing boost_python tool selecting in $(2)/$(SCRAM_BUILDFILE))
endif
endif
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing $(2)/$(SCRAM_BUILDFILE))
endif
endif
endif
ifeq ($$(strip $$($(1)_product)),)
$(1) all_$(1): $(all_$(1))
	@:
endif
endef

define Src2StoreCopy
.PHONY: $(1) all_$(1)
$(1)_files := $(filter-out CVS $(SCRAM_BUILDFILE) $(SCRAM_BUILDFILE).xml $($(1)_SKIP_FILES), $($(1)_files))
$(1): all_$(1)
	@:
ifneq ($$(strip $$($(1)_files)),)
$(eval $(call LogFile,$(1),$(2)))
$(1)_installdir := $(3)
all_$(1): $(logfile_$(1))
	@$$(call clean_files,$($(1)_SKIP_FILES),$$($(1)_installdir))
	$$(call src2store_copy,$(2),$(1),$$($(1)_files),$$($(1)_installdir))
endif
endef

define CommonDataRules
.PHONY: $(1) all_$(1)
$(1) all_$(1): $($(1)_data_copy_rule)
endef

define CommonProductRules
.PHONY: $(1) all_$(1)
ifeq ($(strip $(3)),TEST)
.PHONY: runtests_$(1) unittests_$(1) 
$(1) += $($(1)_data_copy_rule)
runtests_$(1): $(1) $(runtests_$(1))
	@:
unittests_$(1): $(unittests_$(1))
	@:
endif
$(1) all_$(1): $($(1))
	@:
endef

ifneq ($(strip $(SCRAM_MULTIPLE_COMPILERS)-$(SCRAM_COMPILER)-$(RUN_LLVM_ANALYZER_ON_ALL)),yes-$(LLVM_ANALYZER)-no)  #If not llvm-analyzer else requested to run llvm-alayzer for gen code too
define AddMOC
$(1)_LOC_FLAGS_CPPFLAGS     += -I$($(1)_objdir)/moc
$(1)_FILE_MOC	  := $(foreach suffix,h cc cpp cxx,$(patsubst %.$(suffix),%_$(suffix)_moc.cc,$(filter %.$(suffix),$(2))))
$(1)_FILE_MOC_SRC := $$(filter %_cc_moc.cc %_cpp_moc.cc %_cxx_moc.cc, $$($(1)_FILE_MOC))
$(1)_FILE_MOC_INC := $(filter-out $$($(1)_FILE_MOC_SRC),$$($(1)_FILE_MOC))
$(1)_files        += $$($(1)_FILE_MOC_INC)
$(1)_objs         += $$(addprefix $($(1)_objdir)/moc/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_FILE_MOC_INC)))))
$(1)_extra_files   += $($(1)_objdir)/moc/run_moc
$($(1)_objdir)/moc/run_moc: $$(addprefix $($(1)_objdir)/moc/, $$($(1)_FILE_MOC))
	@[ -f $$@ ] || $(CMD_touch) $$@
$($(1)_objdir)/moc/%.$(OBJEXT):  $($(1)_objdir)/moc/%.cc
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/moc/%_h_moc.cc:   $(3)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_h_moc.cc:   $(4)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cc_moc.cc:  $(4)/%.cc  $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cpp_moc.cc: $(4)/%.cpp $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cxx_moc.cc: $(4)/%.cxx $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
endef

#safename,path,*LinkDef.h files
define RootDict
$(1)_LinkDef_files          := $(addprefix $($(1)_objdir)/,$(patsubst %.h,%.cc,$(3)))
$(1)_LOC_FLAGS_CPPFLAGS     += -I$(LOCALTOP)/$(2)
$(1)_files                  += $$($(1)_LinkDef_files)
$(1)_objs                   += $(addprefix $($(1)_objdir)/,$(patsubst %.h,%.$(OBJEXT),$(3)))
.PRECIOUS: $$($(1)_LinkDef_files)
$(1)_extra_files += $$($(1)_LinkDef_files)
$($(1)_objdir)/%.cc: $($(1)_srcdir)/%.h $($(1)_config)
	$$(call generate_rootdict,$(1),$(1))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cc
	$$(call compile_rootdict,$(1),$(1))
endef


#safename,prodpath
define RootMap
$($(1)_objdir)/$(1).rootmap: $($(1)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
	@$$(startlog_$(1))$(CMD_echo) ">> Generating RootMap file: $$(@F)" &&\
	$(CMD_cd) $$(<D); genmap -i $$(<F) -o $$(@F) $$(endlog_$(1))
$(2)/$(1).rootmap: $($(1)_objdir)/$(1).rootmap
	@$(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod)
	@$(CMD_cp) $$< $$@
all_$(1) += $(2)/$(1).rootmap
endef

#safename,libname,prodpath
define LcgDictRootMap
$(2)_GENREFLEX_ARGS += --rootmap=$(2).rootmap --rootmap-lib=$(MODULE_PREFIX)$(2).$(SHAREDSUFFIX)
$($(1)_objdir)/$(2).rootmap: $($(1)_objdir)/$(MODULE_PREFIX)$(2).$(SHAREDSUFFIX)
	@$(CMD_touch) $$@
$(3)/$(2).rootmap: $($(1)_objdir)/$(2).rootmap
	@$(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod)
	@$(CMD_cp) $$< $$@
all_$(1) += $(3)/$(2).rootmap
endef

#safename,rootmap,hfiles,defxmlfiles,prodstore,genreflexargs,Cababilities
define LCGDict
$(1)$(7)_GENREFLEX_ARGS := $(6)
$(eval $(call AddLCGDictRule,$(1),$(3),$(4),$(1)$(7),a/))
$(eval $(call AddSealCapabilitiesRule,$(1),$(1)$(7),a/))
ifeq ($(strip $(2)),1)
$$(eval $$(call LcgDictRootMap,$1,$(1)$(7),$5))
endif
ifneq ($(strip $7),)
ALL_lib_PRODUCTS += $(1)$(7)
ifeq ($(strip $($(1)_bigprod)),)
ALL_CLASS_VERSION_RULES += $($(1)_objdir)/updateclassversion
ifneq ($(strip $(UPDATE_CLASSVERSION)),)
all_$(1)       += $($(1)_objdir)/updateclassversion
$($(1)_objdir)/updateclassversion: $($(1)_objdir)/$(MODULE_PREFIX)$(1)$(7).$(SHAREDSUFFIX)
	@$(CMD_touch) $$@
endif
$$(eval $$(call LCGDictLibRule,$1,$5,$7,$4,$($(1)_objdir),$$($(1)$(7)_objs)))
endif
$$(eval $$(call BigObject,$(1),$(1)$(7),$$($(1)$(7)_objs)))
endif
endef

#safename,prodstore,Capabilities,defxmlfiles,objdir,objs,
define LCGDictLibRule
$(1)$(3)_CDICT_LDFLAGS   = -l$(1) $$($(1)_LDFLAGS)
all_$(1)  += $(5)/$(MODULE_PREFIX)$(1)$(3).$(SHAREDSUFFIX)
$(5)/$(MODULE_PREFIX)$(1)$(3).$(SHAREDSUFFIX): $6 $(WORKINGDIR)/cache/prod/lib$(1)
	$$(call link_lib_capabilities,$(1),$(1),$(2),$(1)$(3),$6,$(4))
endef

define AddLCGDictRule
$(if $(2),$(eval rflx_name:=$(rflx_name)x)$(eval $(call LCGDictRule,$(1),$(5)$(rflx_name),$(firstword $(2)),$(firstword $(3)),$(4)))$(eval $$(call AddLCGDictRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)),$(4),$(5)))$(eval rflx_name:=),)
endef

define AddSealCapabilitiesRule
ifeq ($(strip $(BIGLIBS)),)
ifneq ($(strip $$($(2)_seal_cap)),)
$(1)_compile     += $($(1)_objdir)/$(3)seal_cap.$(OBJEXT)
$(2)_objs        += $($(1)_objdir)/$(3)seal_cap.$(OBJEXT)
$(1)_extra_files += $($(1)_objdir)/$(3)seal_cap.cc
$($(1)_objdir)/$(3)seal_cap.$(OBJEXT): $($(1)_objdir)/$(3)seal_cap.cc
	$$(call compile_cxx_capabilities,$(1),$(1))
$($(1)_objdir)/$(3)seal_cap.cc: $$($(2)_seal_cap)
	@($(CMD_echo) 'static  const char* clnames[] = {' ;\
	  $(CMD_cat) $$^ | $(CMD_grep) LCGReflex/ ;\
	  $(CMD_echo) '};' ;\
	  $(CMD_echo) 'extern "C" void SEAL_CAPABILITIES (const char**& names, int& n )' ;\
	  $(CMD_echo) '{names = clnames;n = sizeof(clnames)/sizeof(char*);}') > $$@
endif
endif
endef

define LCGDictRule
$(1)_files  := $($(1)_objdir)/$(2)r.cc        $($(1)_files)
$(1)_objs   := $($(1)_objdir)/$(2)r.$(OBJEXT) $($(1)_objs)
$(1)_extra_files += $($(1)_objdir)/$(2)r.cc
ifneq ($(strip $(filter $(LOCALTOP)/$(WORKINGDIR)/classes/%,$3)),)
$3: $4
	$$(call generate_classes_h)
endif
$($(1)_objdir)/$(2)r.cc: $(4) $(3) $($(1)_config)
	$$(call generate_lcgdict,$(1),$(1),$(4),$(3),$(2)i.cc,$(5))
$($(1)_objdir)/$(2)r.$(OBJEXT): $($(1)_objdir)/$(2)r.cc
	$$(call compile_lcgdict,$(1),$(1))
ifneq ($1,$5)
$(5)_seal_cap    += $($(1)_objdir)/$(2)i.cc
$($(1)_objdir)/$(2)i.cc: $($(1)_objdir)/$(2)r.cc
	@[ -f $$< ] || $(CMD_rm) -f $$@
ifneq ($(strip $(BIGLIBS)),)
$(5)_dict += $(SCRAMSTORENAME_OBJS)/dict/$(5).$(notdir $(2))
$(1)_extra_files += $$($(5)_dict)
$(SCRAMSTORENAME_OBJS)/dict/$(5).$(notdir $(2)): $($(1)_objdir)/$(2)i.cc
	@[ -d $$(@D) ] || mkdir -p $$(@D)
	@if [ -f $$< ] ; then \
	  $(CMD_grep) '"LCGReflex/' $$< > $$@ ;\
	else \
	  $(CMD_rm) -f $$@;\
	fi
endif
endif
endef

#safename,path,lexyacc,parseyacc,
define LexYACC
$(1)_lex_files     :=  $(3)
$(1)_yacc_files    :=  $(4)
$(1)_generated_hdr := $$(addprefix $($(1)_objdir)/, $$(addsuffix .h,  $$(basename $$(notdir $$($(1)_yacc_files)))))
$(1)_generated_src := $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_lex_files)))))
$(1)_generated_src += $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_yacc_files)))))
ifneq ($$(strip $$($(1)_generated_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/$(SCRAM_SOURCEDIR)
endif
$(1)_objs          += $$(patsubst %.cc,%.$(OBJEXT),$$($(1)_generated_src))
$(1)_extra_files    += $$($(1)_generated_src) $$($(1)_generated_hdr)
.PRECIOUS: $$($(1)_generated_src) $$($(1)_generated_hdr)
$($(1)_objdir)/%lex.cc: $($(1)_srcdir)/%lex.l $($(1)_config)
	$$(call generate_lex,$(1),$(1))
$($(1)_objdir)/%parse.cc $($(1)_objdir)/%parse.h: $($(1)_srcdir)/%parse.y $($(1)_config)
	$$(call generate_parse,$(1),$(1),$(2))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cc $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef

#safename,path,CODEGENPATH
define CodeGen
$(1)_CODEGENPY            := python $(3)/bin/codegen.py
$(1)_CODEGENTEMPLATES     := $(3)/templates
$(1)_codegen_object_names := $(foreach file,$(wildcard $(foreach dir,$($(1)_srcdir),$(dir)/*.desc.xml)),$(notdir $(patsubst %.desc.xml,%,$(file))))
$(1)_codegen_src := $$(addprefix $($(1)_objdir)/,$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.cpp .reg.cpp _T_Context.cpp,$$(objname)$$(suffix))))
$(1)_codegen_hdr := $$(addprefix $($(1)_objdir)/, $$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.h Record.h,$$(objname)$$(suffix))))
$(1)_codegen_rtvr_src :=$(addprefix $($(1)_objdir)/,$(1)Retriever.cpp)
$(1)_codegen_rtvr_hdr :=$(addprefix $($(1)_objdir)/,$(1)Retriever.h)
ifneq ($$(strip $$($(1)_codegen_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/$(SCRAM_SOURCEDIR)
endif
ifneq ($$(strip $$($(1)_codegen_rtvr_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/$(SCRAM_SOURCEDIR)
endif
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_src))
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_rtvr_src))
$(1)_extra_files += $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$(1)_extra_files += $$($(1)_codegen_rtvr_src) $$($(1)_codegen_rtvr_hdr)
.PRECIOUS: $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$($(1)_objdir)/%.h $($(1)_objdir)/%Record.h $($(1)_objdir)/%.cpp $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/%_T_Context.cpp: $($(1)_srcdir)/%.desc.xml $($(1)_config)
	$$(call generate_codegen_record,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.$(OBJEXT): $($(1)_objdir)/$(1)Retriever.cpp
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.cpp $($(1)_objdir)/$(1)Retriever.h: $$($(1)_codegen_hdr)
	@:
$($(1)_objdir)/%.reg.$(OBJEXT): $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%_T_Context.$(OBJEXT): $($(1)_objdir)/%_T_Context.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef
endif   #If not llvm-analyzer
##############################################################################
define SetTargetType
ifneq ($(strip $(filter bigobj,$(MAKECMDGOALS))),)
  BIGOBJS:=yes
endif
ifneq ($(strip $(filter updateclassversion,$(MAKECMDGOALS))),)
  UPDATE_CLASSVERSION:=yes
endif
ifeq ($(strip $(MAKECMDGOALS)),outputlog)
  FAST :=yes
  XFAST:=yes
  UFAST:=yes
endif
ifeq ($(strip $(MAKECMDGOALS)),clean)
  ONLYECHOTARGETS:=yes
  FAST :=yes
  XFAST:=yes
  UFAST:=yes
else
ifeq ($(strip $(filter-out productmap gindices skiptest_% echo_% clean_% fast xfast ufast bigobj outputlog updateclassversion,$(MAKECMDGOALS))),)
  ONLYECHOTARGETS:=yes
  ifneq ($(strip $(filter ufast,$(MAKECMDGOALS))),)
    FAST :=yes
    XFAST:=yes
    UFAST:=yes
  else
    ifneq ($(strip $(filter xfast,$(MAKECMDGOALS))),)
      FAST :=yes
      XFAST:=yes
    else
      ifneq ($(strip $(filter fast,$(MAKECMDGOALS))),)
        FAST :=yes
      endif
    endif
  endif
endif
endif
endef
define UpdateMakeGoalTypes
$(if $(strip $(MAKECMDGOALS)),$(eval $(call SetTargetType)),)
endef
define GetEchoVariable
$(if $(strip $(filter echo_%,$(1))),$(patsubst echo_%,%,$(1)),)
endef
$(eval $(call UpdateMakeGoalTypes))
##############################################################################
.PHONY: ToolUpdated_% ToolUpdated ExternalLinks Non-xml\ BuildFile\ check
Non-xml\ BuildFile\ check:
	@if [ "X$(NON_XML_BUILDFILE)" != "X" ] ; then \
	  $(CMD_echo) "****ERROR: Non-XML BuildFiles found. Please convert these to xml format using 'scram build -c'";\
          $(foreach bf,$(NON_XML_BUILDFILE),$(CMD_echo) "          => $(bf)";) \
	  [ "X$(RELEASETOP)" = "X" ] || exit 1 ;\
	fi
FORCE_TARGET:  Non-xml\ BuildFile\ check
	@:
$(WORKINGDIR)/cache/prod/%:
	@$(CMD_touch) $@
$(LOCALTOP)/$(SCRAMSTORENAME_LOGS)/testing.log: FORCE_TARGET
	@$(CMD_mkdir) -p $(@D) ;\
	$(CMD_rm) -rf $@; \
	$(CMD_echo) "Creating test log file $(SCRAMSTORENAME_LOGS)/testing.log" ;\
	$(CMD_touch) $@
$(WORKINGDIR)/cache/log/%: FORCE_TARGET
	@if [ -f $@ ] ; then  \
	  $(CMD_rm) -f $@ ;\
	else \
	  [ -d $(@D) ] || $(CMD_mkdir) -p $(@D) ;\
	fi
	@$(CMD_touch) -t $(OLD_TIMESTAMP) $@
ToolUpdated_%: ToolUpdated
ExternalLinks ToolUpdated:
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH)
$(WORKINGDIR)/cache/xlibs: $(WORKINGDIR)/cache/xlibs.backup
	@$(CMD_touch) -t $(OLD_TIMESTAMP) $@
$(WORKINGDIR)/cache/xlibs.backup: $(LOCALTOP)/external/$(SCRAM_ARCH)/links.DB 
	@$(CMD_touch) $@
$(LOCALTOP)/external/$(SCRAM_ARCH)/links.DB: $(ToolTimeStamps) $(LOCALTOP)/external/$(SCRAM_ARCH)
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH)
$(LOCALTOP)/external/$(SCRAM_ARCH): FORCE_TARGET
	@[ -d $@ ] || $(CMD_mkdir) -p $@
######################################################################
$(eval curtop:=$(shell $(CMD_echo) $$LOCALTOP))
ifneq ($(curtop),$(SCRAM_INIT_LOCALTOP))
  PROJECT_RENAME_TARGET:=
  ifeq ($(strip $(MAKECMDGOALS)),ProjectRename)
    PROJECT_RENAME_TARGET:=yes
  else
    ifeq ($(strip $(MAKECMDGOALS)),projectrename)
      PROJECT_RENAME_TARGET:=yes
    else
      ifeq ($(strip $(MAKECMDGOALS)),PROJECTRENAME)
        PROJECT_RENAME_TARGET:=yes
      endif
    endif
  endif
  ifneq ($(PROJECT_RENAME_TARGET),yes)
    $(eval dummyfile:=localtopchecking.file.$(shell date +%s.%N 2>/dev/null))
    $(eval xxtmp:=$(shell $(CMD_touch) $(SCRAM_INIT_LOCALTOP)/$(dummyfile) 2> /dev/null))
    ifeq ($(strip $(wildcard $(curtop)/$(dummyfile))),)
      $(eval xxtmp:=$(shell $(CMD_rm) -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
      $(info **** ERROR: You have moved/renamed this project area "$(curtop)" from "$(SCRAM_INIT_LOCALTOP)")
      $(error Please first run \"scramv1 b ProjectRename\")
    endif
    $(eval xxtmp:=$(shell $(CMD_rm) -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
  endif
endif

.PHONY: projectrename ProjectRename PROJECTRENAME
ProjectRename projectrename PROJECTRENAME:
	@if [ -f ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl ] ; then \
	  ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl $(SCRAM_INIT_LOCALTOP) $(curtop) $(SCRAM_ARCH); \
	  $(CMD_echo) "Done: $@"; \
	fi
######################################################################
#Common Rules
.PHONY: all project project_all all_$(SCRAM_SOURCEDIR) ProjectPluginRefresh CompilePython PostBuild
all: all_$(TARGETDIR)
	@if [ "X$(TARGETDIR)" != "X$(SCRAM_SOURCEDIR)" ] ; then \
	  $(DO_BUILD_LOG) $(MAKE) -f $(SCRAM_MAKEFILE) ufast outputlog ;\
	  $(MAKE) -f $(SCRAM_MAKEFILE) PostBuild ;\
	fi
project project_all all_$(SCRAM_SOURCEDIR): $(SCRAM_SOURCEDIR)
	@:

.PHONY: python help compile precompile runtests unittests clean distclean cache_clean project_clean project_help
.PHONY: clean_$(SCRAM_SOURCEDIR) help_$(SCRAM_SOURCEDIR)
help: help_$(TARGETDIR)
clean: clean_$(TARGETDIR)
runtests: runtests_$(TARGETDIR)
unittests: unittests_$(TARGETDIR)
python: runpython_$(TARGETDIR)
compile: compile_$(TARGETDIR)
precompile: precompile_$(TARGETDIR)

project_clean clean_$(SCRAM_SOURCEDIR) vclean cache_clean distclean:
	@$(CMD_echo) "Cleaning ProductStore directories:"
	$(CMD_rm) -rf $(ALL_PRODUCT_STORES)
	@$(CMD_echo) "Resetting project cache:"; $(CMD_mkdir) -p $(SCRAM_ADMIN_DIR)
	@for db in ProjectCache DirCache RuntimeCache ObjectCache; do \
	  $(CMD_echo) $(CMD_rm) -f $(SCRAM_ADMIN_DIR)/$$db.db* ; \
	  $(CMD_touch) $(SCRAM_ADMIN_DIR)/$$db.db.gz; \
	  $(CMD_rm) -f $(SCRAM_ADMIN_DIR)/$$db.db* ;  \
	done
	$(CMD_rm) -rf $(SCRAM_ADMIN_DIR)/MakeData
	@if [ "X$(COMPILE_PYTHON_SCRIPTS)" = "Xyes" ] ; then \
	  $(CMD_echo) "Cleaning up the compiled .pyc and generated __init__.py files in the $(SCRAM_SOURCEDIR) directory." &&\
	  if [ -d $(SCRAM_SOURCEDIR) ] ;      then $(CMD_find) $(SCRAM_SOURCEDIR)       -name '__init__.py' -type f | $(CMD_xargs) $(CMD_grep) '^#Automatically created by SCRAM' | $(CMD_sed) -e 's|/__init__.py:.*|/__init__.py|' | $(CMD_uniq) | $(CMD_xargs) $(CMD_rm) -f ; fi &&\
	  if [ -d cfipython/$(SCRAM_ARCH) ] ; then $(CMD_find) cfipython/$(SCRAM_ARCH)  -name '*.pyc' -type f       | $(CMD_xargs) $(CMD_rm) -f ; fi &&\
	  if [ -d $(SCRAM_SOURCEDIR) ] ;      then $(CMD_find) $(SCRAM_SOURCEDIR)       -name '*.pyc' -type f       | $(CMD_xargs) $(CMD_rm) -f ; fi ;\
	fi
	$(CMD_rm) -rf $(SCRAM_INTwork)

project_help help_$(SCRAM_SOURCEDIR):
	@$(CMD_echo) "------------ Help for Project-level Builds ------------"
	@$(CMD_echo) ""
	@$(CMD_echo) "clean:"
	@$(CMD_echo) "     Clean the local working directory only."
	@$(CMD_echo) ""
	@$(CMD_echo) "python:"
	@$(CMD_echo) "     To just build python i.e. creating sym-links and compiling python modules."
	@$(CMD_echo) ""
	@$(CMD_echo) "prebuild:"
	@$(CMD_echo) "     Execute pre-build target for the project."
	@$(CMD_echo) ""
	@$(CMD_echo) "postbuild:"
	@$(CMD_echo) "     Execute the post-build target for the project."
	@$(CMD_echo) ""
	@$(CMD_echo) "release-test:"
	@$(CMD_echo) "     Run the integration test suite"
	@$(CMD_echo) ""
	@$(CMD_echo) "runtests:"
	@$(CMD_echo) "     Build and run all tests for the project, or package-level tests only."
	@$(CMD_echo) "     (Depends on the location where \"scram b runtests\" is run)."
	@$(CMD_echo) ""
	@$(CMD_echo) "unittests:"
	@$(CMD_echo) "     Same as runtests but does not try to build the test first."
	@$(CMD_echo) ""

.PHONY: release release-build release-reset release-check release-test release-doc release-docs release-freeze

release: release-reset release-build postbuild

release-build: project_all

release-reset: distclean

release-check: release-test

release-test: integration-test

release-docs release-doc: doc

release-freeze: release-check
	@$(CMD_echo) "Cleaning up and protecting directories:"
	@$(CMD_cd) $(LOCALTOP); \
	$(CMD_rm) -fr $(SCRAM_INTwork)/$(SCRAM_SOURCEDIR) ; \
	$(CMD_rm) -fr $(SCRAM_INTwork)/cache ; \
	$(CMD_find) . -type f -print | $(CMD_xargs) $(CMD_chmod) a-w; \
	$(CMD_find) . -type d -print | $(CMD_xargs) $(CMD_chmod) 555

###############################################################################
ifdef SCRAM_NOLOADCHECK
SHARED_LIB_LOAD_CHECK :=
endif
PLUGIN_REFRESH_CMDS :=
###############################################################################
-include $(TOOLS_MKDIR)/SCRAMBased/self_libs_def.mk
$(foreach x,$(ALL_TOOLS),$(eval $x := $x))
$(foreach x,$(ALL_TOOLS),$(eval $(call ProductCommonVarsTools,$x,,,$x)))
-include $(PUB_DIRCACHE_MKDIR)/src.mk
-include $(PUB_DIRCACHE_MKDIR)/DirCache.mk
-include $(DIRCACHE_MKDIR)/ExtraBuilsRules/*.mk
-include $(DIRCACHE_MKDIR)/DirCache.mk
-include $(TOOLS_MKDIR)/SCRAMBased/all.mk
-include $(DIRCACHE_MKDIR)/RmvDirCache.mk
ifneq ($(strip $(BIGLIBS)),)
-include $(SCRAM_CONFIGDIR)/SCRAM/GMake/Makefile.bigobj.rules
LD_BIG_OPT := -Wl,-z,muldefs
endif
##############################################################################
ifneq ($(strip $(RELEASETOP)),)
POISON_INCLUDE_DIR := $(wildcard $(LOCALTOP)/poison)
self_EX_INCLUDE := $(subst $(RELEASETOP)/$(SCRAM_SOURCEDIR),$(POISON_INCLUDE_DIR) $(RELEASETOP)/$(SCRAM_SOURCEDIR),$(self_EX_INCLUDE))
endif
$(foreach f,$(OVERRIDABLE_FLAGS),$(eval $f:=$(if $(strip $(RELEASETOP)),$(call AdjustFlag,DEV,$f),$(call AdjustFlag,RELEASE,$f))))
LIBDIR := $(wildcard $(LIBDIR))
####### Clean up the directories which were already build but now have been removed from src area ######
ifneq ($(strip $(REMOVED_DIRS)),)
$(shell $(CMD_echo) "" > $(WORKINGDIR)/.AUTOCLEAN)
$(foreach d,$(sort $(REMOVED_DIRS)),$(if $(wildcard $(WORKINGDIR)/$(d)),$(eval xx:=$(shell $(CMD_find) $(WORKINGDIR)/$(d) -name "AUTOCLEAN.*.clean" -type f | $(CMD_xargs) $(CMD_cat) | $(CMD_grep) "^[0-9][0-9]:" | $(CMD_sed) -e "s|^[0-9][0-9]:||" |$(CMD_sort) | $(CMD_uniq) >> $(WORKINGDIR)/.AUTOCLEAN)$(info Cleaning up removed directory:$(d))$(shell $(CMD_rm) -rf $(WORKINGDIR)/classes/$(d) $(WORKINGDIR)/$(d))),))
$(foreach d,$(REMOVED_DIRS),$(if $(wildcard $(WORKINGDIR)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),$(shell $(CMD_touch) $(SCRAM_INTwork)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),))
xx:=$(shell $(CMD_sh) $(WORKINGDIR)/.AUTOCLEAN; $(CMD_rm) -rf $(DIRCACHE_MKDIR)/RmvDirCache.mk $(DIRCACHE_MKDIR)/RmvDirCache; $(CMD_mkdir) -p $(DIRCACHE_MKDIR)/RmvDirCache; $(CMD_touch) $(DIRCACHE_MKDIR)/RmvDirCache.mk)
endif
####### Update Tools and Prods rules ##############
ifeq ($(strip $(UFAST)),)
$(foreach x,$(ALL_TOOLS),$(foreach err,$($(x)_USE_ERR),$(eval $(call UseError,$(err),$(x)))))
ifeq ($(strip $(XFAST)),)
$(foreach x,$(ALL_EXTERNAL_PRODS),$(eval $(call ProductCommonVarsExternal,$(x)))$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_PRODS),$(eval $(call ProductCommonVars,$(x),,,$($(x)_BuildFile))))
$(foreach x,$(ALL_BIG_PRODS),$(eval $(call ProductCommonVars,$(x),,,$($(x)_BuildFile))))
ifeq ($(strip $(FAST)),)
$(info >> Local Products Rules ..... started)
ifeq ($(strip $(BIGLIBS)),)
$(foreach x,$(ALL_PRODS),$(eval $($(x)_INIT_FUNC)))
else
TEST_test :=
$(foreach x,$(ALL_BIG_PRODS),$(eval $(call BigProductInit,$x)))
$(foreach x,$(ALL_PRODS),$(if $(strip $(filter %.lib,$($(x)_CLASS))),$(eval $($(x)_INIT_FUNC)),$(eval TEST_test += $x)))
$(foreach x,$(TEST_test),$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_BIG_PRODS),$(eval $($(x)_INIT_FUNC)))
TEST_test :=
endif
$(info >> Local Products Rules ..... done)
endif
$(foreach bf,$(ALL_BUILDFILES),$(foreach err,$(sort $($(bf)_USE_ERR)),$(eval $(call UseError,$(err),$(bf)))))
$(foreach x,$(ALL_COMMONRULES),$(eval $($(x)_INIT_FUNC)))
endif
####### Update Subsystems and Packages rules ##############
$(foreach dir,$(ALL_SUBSYSTEMS),$(eval $(call SubSystem,$(dir),$(SCRAM_SOURCEDIR)_$(subst /,_,$(dir)))))
$(foreach dir,$(ALL_PACKAGES),$(eval $(call Package,$(dir),$(SCRAM_SOURCEDIR)_$(subst /,_,$(dir)))))
endif
###########################################################
PHONY: $(SCRAM_SOURCEDIR) prebuild postbuild runtests_$(SCRAM_SOURCEDIR) unittests_$(SCRAM_SOURCEDIR) runpython_$(SCRAM_SOURCEDIR) compile_$(SCRAM_SOURCEDIR) precompile_$(SCRAM_SOURCEDIR)
$(SCRAM_SOURCEDIR): prebuild $($(SCRAM_SOURCEDIR)) $(subdirs_$(SCRAM_SOURCEDIR))
	@$(DO_BUILD_LOG) $(MAKE) -f $(SCRAM_MAKEFILE) ufast outputlog
	@$(MAKE) -f $(SCRAM_MAKEFILE) PostBuild
prebuild: $(prebuild)
	@$(CMD_echo) ">> Building $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) ----"; \
	[ -d $(LOCALTOP)/logs/$(SCRAM_ARCH) ] || $(CMD_mkdir) -p $(LOCALTOP)/logs/$(SCRAM_ARCH)
postbuild: $(postbuild) release-check
	@$(CMD_echo) "Release $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) build finished at `date`"
runpython_$(SCRAM_SOURCEDIR): $(addprefix runpython_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Python completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
runtests_$(SCRAM_SOURCEDIR): $(addprefix runtests_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Test sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
unittests_$(SCRAM_SOURCEDIR): $(addprefix unittests_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Test sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
compile_$(SCRAM_SOURCEDIR): $(addprefix compile_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Compile sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
precompile_$(SCRAM_SOURCEDIR): $(addprefix precompile_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Pre-compile sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
###########################################################
define GetMissingSymbolFlags
  $(if $($(1)_libcheck),$(if $2,$(info @@@@ Checking for missing symbols was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)),),$(MISSING_SYMBOL_FLAGS))
endef
ifndef SCRAM_NOSYMCHECK
ifeq ($(strip $(MISSING_SYMBOL_FLAGS)),)
define check_missing_symbols
  if [ "X$(1)" = X ] ; then \
    $(CMD_echo) "@@@@ Checking shared library for missing symbols: $(@F)" &&\
    $(CMD_echo) "int main(){}" > $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp  &&\
    $(VERB_ECHO) $(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp &&\
    ($(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp || ($(CMD_rm) -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out && $(call delete_plugin_build_prod,$(2),$(3)) && exit 1)) &&\
    $(CMD_rm) -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out	&&\
    $(CMD_echo) "@@@@ ----> OK, shared library FULLY-BOUND (no missing symbols): $(@F)" ; \
  else \
    $(CMD_echo) "@@@@ Checking for missing symbols was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)"; \
  fi
endef
else
check_missing_symbols:=$(CMD_true)
endif
else
define check_missing_symbols
  $(CMD_echo) "@@@@ Checking for missing symbols was SKIPPED due to SCRAM_NOSYMCHECK: $(@F)"
endef
endif
###############################################################################
ifneq ($(strip $(EDM_CHECK_CLASS_VERSION)),)
EDM_CHECK_CLASS_VERSION_SCRIPT:=$(if $(strip $(wildcard $(LOCALTOP)/$(EDM_CHECK_CLASS_VERSION))),$(LOCALTOP)/$(EDM_CHECK_CLASS_VERSION),)
ifeq ($(strip $(EDM_CHECK_CLASS_VERSION_SCRIPT)),)
ifneq ($(strip $(RELEASETOP)),)
EDM_CHECK_CLASS_VERSION_SCRIPT:=$(if $(strip $(wildcard $(RELEASETOP)/$(EDM_CHECK_CLASS_VERSION))),$(RELEASETOP)/$(EDM_CHECK_CLASS_VERSION),)
endif
endif
ifeq ($(strip $(EDM_CHECK_CLASS_VERSION_SCRIPT)),)
EDM_CHECK_CLASS_VERSION_SCRIPT:=$(CMD_echo) ">> Skipped running EDM Class Version test" && $(CMD_true)
endif
endif

#product,list of def.xmls file,plugin,productstore
ifneq ($(strip $(EDM_CHECK_CLASS_VERSION)),)
ifneq ($(strip $(UPDATE_CLASSVERSION)),)
define update_edm_class_version
  for x in $2; do \
    fname=`basename $$x` &&\
    $(CMD_echo) ">> Generating EDM Class Version for $$x in $(@F)" &&\
    $(VERB_ECHO)  $(EDM_CHECK_CLASS_VERSION_SCRIPT) -g -l $(@F) -x $$x &&\
    (($(CMD_cd) $(@D) && $(EDM_CHECK_CLASS_VERSION_SCRIPT) -g -l $(@F) -x $$x) || ($(CMD_true))) &&\
    if [ -f $(@D)/classes_def.xml.generated ] ; then \
      if [ "X`diff $(@D)/classes_def.xml.generated $$x | wc -l`" != "X0" ] ; then \
        $(CMD_cp) $(@D)/classes_def.xml.generated $$x.generated &&\
        $(CMD_echo) ">> New Class Version File:  $$x.generated" ;\
      fi &&\
      $(CMD_rm) -f $(@D)/classes_def.xml.generated ;\
    fi ;\
  done &&\
  $(CMD_echo) "@@@@ ----> Generated EDM Class Version" &&
endef
else
define update_edm_class_version
endef
endif
define check_edm_class_version
  $(call update_edm_class_version,$1,$2,$3,$4) \
  for x in $2; do \
    $(CMD_echo) ">> Checking EDM Class Version for $$x in $(@F)" &&\
    $(VERB_ECHO) $(OS_RUNTIME_LIBRARY_PATH)=$$LOCALTOP/$(@D):$$$(OS_RUNTIME_LIBRARY_PATH) $(EDM_CHECK_CLASS_VERSION_SCRIPT) -l $(@F) -x $$x &&\
    (($(OS_RUNTIME_LIBRARY_PATH)=$$LOCALTOP/$(@D):$$$(OS_RUNTIME_LIBRARY_PATH) $(EDM_CHECK_CLASS_VERSION_SCRIPT) -l $(@F) -x $$x) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) ;\
  done &&\
  $(CMD_echo) "@@@@ ----> OK  EDM Class Version "
endef
else
define check_edm_class_version
$(CMD_true)
endef
define update_edm_class_version
$(CMD_true)
endef
endif
###########################################################

.PHONY: all_% clean_% help_% runtests_% unittests_% runpython_% compile_% precompile_% ufast xfast fast %_USED_BY %_USES echo_% outputlog buildlog
.PHONY: help_%_python help_%_src help_%_plugins help_%_bin help_%_test help_$(SCRAM_SOURCEDIR)_%
.PHONY: skiptest_%
help_%_python:
	@$(CMD_echo) "Running \"scram build\" here will run rules for pythin i.e. creates sym-links and compiles python modules"
help_%_src:
	@$(CMD_echo) "Running \"scram build\" here normally build a shared library."
help_%_plugins:
	@$(CMD_echo) "Running \"scram build\" here normally build EDM-plugins."
help_%_bin:
	@$(CMD_echo) "Running \"scram build\" here normally build public executables and shared libs (if any)."
help_%_test:
	@$(CMD_echo) "Running \"scram build\" here normally build test executables and shared libs (if any)."
help_$(SCRAM_SOURCEDIR)_%:
	@$(CMD_echo) "Doing \"scram build\" here will build every thing exist under this directory."
all_% runtests_% unittests_% help_% runpython_% compile_% precompile_%:
	@if [ "X$(TARGETDIR)" = "X$*" ] ; then \
	  $(CMD_echo) ">> Nothing to be done for $(THISDIR)";\
	fi
clean_%:
	@if [ "X$($*_objdir)" != "X" ] ; then \
	  dir=`$(CMD_echo) $($*_objdir) | $(CMD_grep) '^$(WORKINGDIR)/' | $(CMD_sed) -e 's|^$(WORKINGDIR)/||'`;\
	  if [ "X$$dir" != "X" ] ; then \
	    if [ -d $(WORKINGDIR)/$$dir ] ; then \
	      $(CMD_echo) "Cleaning up $$dir"; $(call BuildClean,$$dir) ; exit 0;\
	    fi;\
	  fi;\
	elif [ "$(TARGETDIR)" == "$*" ] ; then \
	  $(CMD_echo) "Cleaning up $(THISDIR)"; $(call BuildClean,$(THISDIR));\
	else \
	  $(CMD_echo) "***WARNING: Unknown product $*. Failed to cleanup.";\
	fi
ufast xfast fast:
	@:
%_USED_BY:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USED_BY $(patsubst %_USED_BY,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_USES:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USES $(patsubst %_USES,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_ORIGIN:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) ORIGIN $(patsubst %_ORIGIN,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
echo_%:
	@$(CMD_echo) "$* = $(subst ",\",$($*))"

$(COMMON_WORKINGDIR)/cache/python_symlinks: $(COMMON_WORKINGDIR)/cache/project_links FORCE_TARGET
	@[ -d python ] || $(CMD_mkdir) python &&\
	$(SCRAM_CONFIGDIR)/SCRAM/createPyInitFiles.pl &&\
	$(CMD_touch) python/__init__.py
	@for d in `$(CMD_find) python -name "*" -type l | $(CMD_sed) -e s'|^python/||'`; do \
	  [ -d $(SCRAM_SOURCEDIR)/$$d/python ] || continue ;\
	  for dir in `$(CMD_find) $(SCRAM_SOURCEDIR)/$$d/python -name "*" -type d | $(CMD_grep) -v '/CVS$$\|/CVS/'`; do \
	    if [ ! -f $$dir/__init__.py ] ; then \
	      $(CMD_echo) "#Automatically created by SCRAM" > $$dir/__init__.py;\
              if [ "$$dir" == "$(SCRAM_SOURCEDIR)/$$d/python" ] ; then \
                if [ "X$(SCRAM_NOEDMWRITECONFIG)" = "X" ] ; then \
                  $(CMD_echo) "import os" >> $$dir/__init__.py;\
                  $(CMD_echo) "__path__.append(os.path.dirname(os.path.abspath(__file__).rsplit('/$$d/',1)[0])+'/cfipython/$(SCRAM_ARCH)/$$d')"  >> $$dir/__init__.py;\
                fi;\
              fi;\
	      [ -d $(WORKINGDIR)/$$dir ] || $(CMD_mkdir) -p $(WORKINGDIR)/$$dir ;\
	      cf=$(call AutoCleanFile,$(WORKINGDIR)/$$dir/__init__.py,python) ;\
	      $(CMD_echo) "01:$(CMD_rm) -f $$dir/__init__.py $$dir/__init__.pyc" > $$cf;\
	    fi;\
	  done;\
	  if [ ! -f python/$$d/__init__.py ] ; then $(CMD_rm) -f python/$$d; fi;\
	done
	@[ -f $@ ] || ($(CMD_mkdir) -p $(@D) ; $(CMD_touch) -t $(OLD_TIMESTAMP) $@)
$(WORKINGDIR)/%/productautocleanup: FORCE_TARGET
	@for dir in $(foreach x,$(patsubst productautocleanup,,$(notdir $(patsubst %/,%,$(dir $(wildcard $(@D)/*/AUTOCLEAN.*.clean))))),$(if $(findstring all_$x,$($(subst /,_,$*))),,$x)) ; do \
	  $(call BuildClean,$*/$$dir,0[0-9]);\
	done
	@[ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
	$(CMD_touch) -t $(OLD_TIMESTAMP) $@
bigobj: $(ALL_BIGOBJS)
	@:
outputlog:
	$(eval DO_BUILD_LOG:=)
	@$(call outputlog,,,)
buildlog:
	@for f in `$(CMD_find) $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR) -name "build.log" -type f` ; do \
	  pack=`dirname $$f` &&\
	  for l in `$(CMD_find) $$pack -name "*" -type f | grep -v "$$pack/build.log"` ; do \
	    $(CMD_cat) $$l >> $$f && $(CMD_cat) $$l && $(CMD_rm) -f $$l ;\
	  done;\
	done
runtime:
	@$(CMD_echo) ">> Runtime environment:"; env
skiptest_%:
	@:
updateclassversion: $(filter $(WORKINGDIR)/$(THISDIR)/%,$(ALL_CLASS_VERSION_RULES))
	@:
PostBuild: CompilePython ProjectPluginRefresh
	@:
ifeq ($(strip $(COMPILE_PYTHON_SCRIPTS)),yes)
.PHONY: do_python_symlink PyCompile_%
CompilePython: $(addprefix PyCompile_,$(wildcard cfipython/$(SCRAM_ARCH)$(patsubst $(SCRAM_SOURCEDIR)%,%,$(THISDIR)) python) $(filter $(THISDIR)%,$(addprefix $(SCRAM_SOURCEDIR)/,$(ALL_PYTHON_DIRS))))
	@[ ! -f $(COMMON_WORKINGDIR)/cache/python_error ] || exit 1
	@$(CMD_echo) ">> All python modules compiled"
PyCompile_$(SCRAM_SOURCEDIR)/% PyCompile_cfipython/% PyCompile_%: do_python_symlink
	@$(call compile_python,$(patsubst PyCompile_%,%,$@))
do_python_symlink: $(COMMON_WORKINGDIR)/cache/python_symlinks
	@$(CMD_rm) -f $(COMMON_WORKINGDIR)/cache/python_error
	@$(CMD_echo) ">> Done python_symlink"
else
CompilePython:
	@$(CMD_echo) ">> Skipped python compilation"
endif
ProjectPluginRefresh: FORCE_TARGET $(foreach file,$(addsuffix _cache,$(PLUGIN_REFRESH_CMDS)),$($(file)))
	@$(CMD_echo) ">> Pluging of all type refreshed."
.PHONY: checker FORCE_LLVM_CHECK
FORCE_LLVM_CHECK:
	@:
ifeq ($(strip $(SCRAM_MULTIPLE_COMPILERS)),)
checker:
	@$(CMD_echo) "**** ERROR: Can not run llvm analyzer as this project does not support multiple compilers" && exit 1
else
ifeq ($(strip $(filter $(LLVM_ANALYZER)-$(CXX_TYPE_COMPILER),$(ALL_TOOLS))),)
checker:
	@$(CMD_echo) "**** ERROR: Can not run llvm analyzer as $(LLVM_ANALYZER)-$(CXX_TYPE_COMPILER) tool does not exist" && exit 1
else
ifeq ($(strip $(LLVM_PLUGIN)),)
checker:
	@(CMD_echo) "**** ERROR: LLVM static plugin is not set for this project" && exit 1
else
checker: $(WORKINGDIR)/cache/prod/lib$(LLVM_PLUGIN)
	@+$(CMD_echo) Starting LLVM static checkers $(THISDIR) &&\
	plugin=$(if $(wildcard $(LOCALTOP)/lib/$(SCRAM_ARCH)/$(MODULE_PREFIX)$(LLVM_PLUGIN).$(SHAREDSUFFIX)),$(LOCALTOP)/lib/$(SCRAM_ARCH)/$(MODULE_PREFIX)$(LLVM_PLUGIN).$(SHAREDSUFFIX),$(if $(RELEASETOP),$(wildcard $(RELEASETOP)/lib/$(SCRAM_ARCH)/$(MODULE_PREFIX)$(LLVM_PLUGIN).$(SHAREDSUFFIX)),)) &&\
	if [ "X$$plugin" == "X" ] ; then $(CMD_echo) "**** ERROR: Unable to find $(MODULE_PREFIX)$(LLVM_PLUGIN).$(SHAREDSUFFIX)" ; exit 1; fi ;\
	LLVM_BASE=$($(shell $(CMD_echo) $(LLVM_ANALYZER)-$(CXX_TYPE_COMPILER)_BASE | $(CMD_tr) 'a-z-' 'A-Z_')) &&\
	$(CMD_cd) $(THISDIR) && $(CMD_rm) -rf $(LOCALTOP)/llvm-analysis && $(CMD_mkdir) -p $(LOCALTOP)/llvm-analysis &&\
	$(VERB_ECHO) $$LLVM_BASE/bin/scan-build -o $(LOCALTOP)/llvm-analysis -load-plugin $$plugin $(LLVM_CHECKERS) $(USER_LLVM_CHECKERS) \
	  $(SCRAM) build -f $(if $(strip $(SCRAM_BUILDVERBOSE)),-v,) compile COMPILER=$(LLVM_ANALYZER) SCRAM_IGNORE_MISSING_COMPILERS=yes &&\
	$$LLVM_BASE/bin/scan-build              -o $(LOCALTOP)/llvm-analysis -load-plugin $$plugin $(LLVM_CHECKERS) $(USER_LLVM_CHECKERS) \
	  $(SCRAM) build -f $(if $(strip $(SCRAM_BUILDVERBOSE)),-v,) compile COMPILER=$(LLVM_ANALYZER) SCRAM_IGNORE_MISSING_COMPILERS=yes && $(DO_BUILD_LOG) $(SCRAM) build buildlog &&\
	  $(CMD_rm) -rf $(LOCALTOP)/llvm-analysis/*/failures
endif
endif
endif
%:
	@$(if $(strip $(wildcard $@ $(RELEASETOP)/$@)),true,$(CMD_echo) $(if $(subst undefined,,$(origin $@)),$@ = $($@),Unknow target $@))
