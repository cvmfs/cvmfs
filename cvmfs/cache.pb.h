// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cache.proto

#ifndef PROTOBUF_cache_2eproto__INCLUDED
#define PROTOBUF_cache_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace cvmfs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cache_2eproto();
void protobuf_AssignDesc_cache_2eproto();
void protobuf_ShutdownFile_cache_2eproto();

class MsgHash;
class MsgListRecord;
class MsgBreadcrumb;
class MsgHandshake;
class MsgHandshakeAck;
class MsgQuit;
class MsgIoctl;
class MsgStoreReq;
class MsgStoreAbortReq;
class MsgStoreReply;
class MsgRefcountReq;
class MsgRefcountReply;
class MsgDetach;
class MsgShrinkReq;
class MsgShrinkReply;
class MsgReadReq;
class MsgReadReply;
class MsgInfoReq;
class MsgInfoReply;
class MsgObjectInfoReq;
class MsgObjectInfoReply;
class MsgListReq;
class MsgListReply;
class MsgBreadcrumbStoreReq;
class MsgBreadcrumbLoadReq;
class MsgBreadcrumbReply;
class MsgRpc;

enum EnumStatus {
  STATUS_UNKNOWN = 0,
  STATUS_OK = 1,
  STATUS_NOSUPPORT = 2,
  STATUS_FORBIDDEN = 3,
  STATUS_NOSPACE = 4,
  STATUS_NOENTRY = 5,
  STATUS_MALFORMED = 6,
  STATUS_IOERR = 7,
  STATUS_CORRUPTED = 8,
  STATUS_TIMEOUT = 9,
  STATUS_BADCOUNT = 10,
  STATUS_OUTOFBOUNDS = 11,
  STATUS_PARTIAL = 12
};
bool EnumStatus_IsValid(int value);
const EnumStatus EnumStatus_MIN = STATUS_UNKNOWN;
const EnumStatus EnumStatus_MAX = STATUS_PARTIAL;
const int EnumStatus_ARRAYSIZE = EnumStatus_MAX + 1;

enum EnumHashAlgorithm {
  HASH_UNKNOWN = 0,
  HASH_SHA1 = 1,
  HASH_RIPEMD160 = 2,
  HASH_SHAKE128 = 3
};
bool EnumHashAlgorithm_IsValid(int value);
const EnumHashAlgorithm EnumHashAlgorithm_MIN = HASH_UNKNOWN;
const EnumHashAlgorithm EnumHashAlgorithm_MAX = HASH_SHAKE128;
const int EnumHashAlgorithm_ARRAYSIZE = EnumHashAlgorithm_MAX + 1;

enum EnumObjectType {
  OBJECT_REGULAR = 0,
  OBJECT_CATALOG = 1,
  OBJECT_VOLATILE = 2
};
bool EnumObjectType_IsValid(int value);
const EnumObjectType EnumObjectType_MIN = OBJECT_REGULAR;
const EnumObjectType EnumObjectType_MAX = OBJECT_VOLATILE;
const int EnumObjectType_ARRAYSIZE = EnumObjectType_MAX + 1;

enum EnumCapabilities {
  CAP_NONE = 0,
  CAP_WRITE = 1,
  CAP_REFCOUNT = 2,
  CAP_SHRINK = 4,
  CAP_INFO = 8,
  CAP_SHRINK_RATE = 16,
  CAP_LIST = 32,
  CAP_ALL_V1 = 63,
  CAP_BREADCRUMB = 64,
  CAP_ALL_V2 = 127
};
bool EnumCapabilities_IsValid(int value);
const EnumCapabilities EnumCapabilities_MIN = CAP_NONE;
const EnumCapabilities EnumCapabilities_MAX = CAP_ALL_V2;
const int EnumCapabilities_ARRAYSIZE = EnumCapabilities_MAX + 1;

// ===================================================================

class MsgHash : public ::google::protobuf::MessageLite {
 public:
  MsgHash();
  virtual ~MsgHash();

  MsgHash(const MsgHash& from);

  inline MsgHash& operator=(const MsgHash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgHash& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgHash* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgHash* other);

  // implements Message ----------------------------------------------

  MsgHash* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgHash& from);
  void MergeFrom(const MsgHash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cvmfs.EnumHashAlgorithm algorithm = 1;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 1;
  inline ::cvmfs::EnumHashAlgorithm algorithm() const;
  inline void set_algorithm(::cvmfs::EnumHashAlgorithm value);

  // required bytes digest = 2;
  inline bool has_digest() const;
  inline void clear_digest();
  static const int kDigestFieldNumber = 2;
  inline const ::std::string& digest() const;
  inline void set_digest(const ::std::string& value);
  inline void set_digest(const char* value);
  inline void set_digest(const void* value, size_t size);
  inline ::std::string* mutable_digest();
  inline ::std::string* release_digest();
  inline void set_allocated_digest(::std::string* digest);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgHash)
 private:
  inline void set_has_algorithm();
  inline void clear_has_algorithm();
  inline void set_has_digest();
  inline void clear_has_digest();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* digest_;
  int algorithm_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgHash* default_instance_;
};
// -------------------------------------------------------------------

class MsgListRecord : public ::google::protobuf::MessageLite {
 public:
  MsgListRecord();
  virtual ~MsgListRecord();

  MsgListRecord(const MsgListRecord& from);

  inline MsgListRecord& operator=(const MsgListRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgListRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgListRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgListRecord* other);

  // implements Message ----------------------------------------------

  MsgListRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgListRecord& from);
  void MergeFrom(const MsgListRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cvmfs.MsgHash hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::cvmfs::MsgHash& hash() const;
  inline ::cvmfs::MsgHash* mutable_hash();
  inline ::cvmfs::MsgHash* release_hash();
  inline void set_allocated_hash(::cvmfs::MsgHash* hash);

  // optional bool pinned = 2;
  inline bool has_pinned() const;
  inline void clear_pinned();
  static const int kPinnedFieldNumber = 2;
  inline bool pinned() const;
  inline void set_pinned(bool value);

  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgListRecord)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_pinned();
  inline void clear_has_pinned();
  inline void set_has_description();
  inline void clear_has_description();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cvmfs::MsgHash* hash_;
  ::std::string* description_;
  bool pinned_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgListRecord* default_instance_;
};
// -------------------------------------------------------------------

class MsgBreadcrumb : public ::google::protobuf::MessageLite {
 public:
  MsgBreadcrumb();
  virtual ~MsgBreadcrumb();

  MsgBreadcrumb(const MsgBreadcrumb& from);

  inline MsgBreadcrumb& operator=(const MsgBreadcrumb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgBreadcrumb& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgBreadcrumb* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgBreadcrumb* other);

  // implements Message ----------------------------------------------

  MsgBreadcrumb* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgBreadcrumb& from);
  void MergeFrom(const MsgBreadcrumb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fqrn = 1;
  inline bool has_fqrn() const;
  inline void clear_fqrn();
  static const int kFqrnFieldNumber = 1;
  inline const ::std::string& fqrn() const;
  inline void set_fqrn(const ::std::string& value);
  inline void set_fqrn(const char* value);
  inline void set_fqrn(const char* value, size_t size);
  inline ::std::string* mutable_fqrn();
  inline ::std::string* release_fqrn();
  inline void set_allocated_fqrn(::std::string* fqrn);

  // required .cvmfs.MsgHash hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::cvmfs::MsgHash& hash() const;
  inline ::cvmfs::MsgHash* mutable_hash();
  inline ::cvmfs::MsgHash* release_hash();
  inline void set_allocated_hash(::cvmfs::MsgHash* hash);

  // required uint64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgBreadcrumb)
 private:
  inline void set_has_fqrn();
  inline void clear_has_fqrn();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fqrn_;
  ::cvmfs::MsgHash* hash_;
  ::google::protobuf::uint64 timestamp_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgBreadcrumb* default_instance_;
};
// -------------------------------------------------------------------

class MsgHandshake : public ::google::protobuf::MessageLite {
 public:
  MsgHandshake();
  virtual ~MsgHandshake();

  MsgHandshake(const MsgHandshake& from);

  inline MsgHandshake& operator=(const MsgHandshake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgHandshake& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgHandshake* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgHandshake* other);

  // implements Message ----------------------------------------------

  MsgHandshake* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgHandshake& from);
  void MergeFrom(const MsgHandshake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 protocol_version = 1;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgHandshake)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 protocol_version_;
  ::google::protobuf::uint32 flags_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgHandshake* default_instance_;
};
// -------------------------------------------------------------------

class MsgHandshakeAck : public ::google::protobuf::MessageLite {
 public:
  MsgHandshakeAck();
  virtual ~MsgHandshakeAck();

  MsgHandshakeAck(const MsgHandshakeAck& from);

  inline MsgHandshakeAck& operator=(const MsgHandshakeAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgHandshakeAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgHandshakeAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgHandshakeAck* other);

  // implements Message ----------------------------------------------

  MsgHandshakeAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgHandshakeAck& from);
  void MergeFrom(const MsgHandshakeAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cvmfs.EnumStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 protocol_version = 3;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // required uint64 session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint32 max_object_size = 5;
  inline bool has_max_object_size() const;
  inline void clear_max_object_size();
  static const int kMaxObjectSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 max_object_size() const;
  inline void set_max_object_size(::google::protobuf::uint32 value);

  // required uint64 capabilities = 6;
  inline bool has_capabilities() const;
  inline void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 6;
  inline ::google::protobuf::uint64 capabilities() const;
  inline void set_capabilities(::google::protobuf::uint64 value);

  // optional uint32 flags = 7;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 7;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional uint64 pid = 8;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 8;
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgHandshakeAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_max_object_size();
  inline void clear_has_max_object_size();
  inline void set_has_capabilities();
  inline void clear_has_capabilities();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int status_;
  ::google::protobuf::uint32 protocol_version_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 capabilities_;
  ::google::protobuf::uint32 max_object_size_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint64 pid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgHandshakeAck* default_instance_;
};
// -------------------------------------------------------------------

class MsgQuit : public ::google::protobuf::MessageLite {
 public:
  MsgQuit();
  virtual ~MsgQuit();

  MsgQuit(const MsgQuit& from);

  inline MsgQuit& operator=(const MsgQuit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgQuit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgQuit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgQuit* other);

  // implements Message ----------------------------------------------

  MsgQuit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgQuit& from);
  void MergeFrom(const MsgQuit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgQuit)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgQuit* default_instance_;
};
// -------------------------------------------------------------------

class MsgIoctl : public ::google::protobuf::MessageLite {
 public:
  MsgIoctl();
  virtual ~MsgIoctl();

  MsgIoctl(const MsgIoctl& from);

  inline MsgIoctl& operator=(const MsgIoctl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgIoctl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgIoctl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgIoctl* other);

  // implements Message ----------------------------------------------

  MsgIoctl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgIoctl& from);
  void MergeFrom(const MsgIoctl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // optional sint32 conncnt_change_by = 2;
  inline bool has_conncnt_change_by() const;
  inline void clear_conncnt_change_by();
  static const int kConncntChangeByFieldNumber = 2;
  inline ::google::protobuf::int32 conncnt_change_by() const;
  inline void set_conncnt_change_by(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgIoctl)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_conncnt_change_by();
  inline void clear_has_conncnt_change_by();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::int32 conncnt_change_by_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgIoctl* default_instance_;
};
// -------------------------------------------------------------------

class MsgStoreReq : public ::google::protobuf::MessageLite {
 public:
  MsgStoreReq();
  virtual ~MsgStoreReq();

  MsgStoreReq(const MsgStoreReq& from);

  inline MsgStoreReq& operator=(const MsgStoreReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgStoreReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgStoreReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgStoreReq* other);

  // implements Message ----------------------------------------------

  MsgStoreReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgStoreReq& from);
  void MergeFrom(const MsgStoreReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.MsgHash object_id = 3;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  inline const ::cvmfs::MsgHash& object_id() const;
  inline ::cvmfs::MsgHash* mutable_object_id();
  inline ::cvmfs::MsgHash* release_object_id();
  inline void set_allocated_object_id(::cvmfs::MsgHash* object_id);

  // required uint64 part_nr = 4;
  inline bool has_part_nr() const;
  inline void clear_part_nr();
  static const int kPartNrFieldNumber = 4;
  inline ::google::protobuf::uint64 part_nr() const;
  inline void set_part_nr(::google::protobuf::uint64 value);

  // required bool last_part = 5;
  inline bool has_last_part() const;
  inline void clear_last_part();
  static const int kLastPartFieldNumber = 5;
  inline bool last_part() const;
  inline void set_last_part(bool value);

  // optional uint64 expected_size = 6;
  inline bool has_expected_size() const;
  inline void clear_expected_size();
  static const int kExpectedSizeFieldNumber = 6;
  inline ::google::protobuf::uint64 expected_size() const;
  inline void set_expected_size(::google::protobuf::uint64 value);

  // optional .cvmfs.EnumObjectType object_type = 7;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 7;
  inline ::cvmfs::EnumObjectType object_type() const;
  inline void set_object_type(::cvmfs::EnumObjectType value);

  // optional string description = 8;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 8;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional fixed32 data_crc32 = 9;
  inline bool has_data_crc32() const;
  inline void clear_data_crc32();
  static const int kDataCrc32FieldNumber = 9;
  inline ::google::protobuf::uint32 data_crc32() const;
  inline void set_data_crc32(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgStoreReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_part_nr();
  inline void clear_has_part_nr();
  inline void set_has_last_part();
  inline void clear_has_last_part();
  inline void set_has_expected_size();
  inline void clear_has_expected_size();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_data_crc32();
  inline void clear_has_data_crc32();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::cvmfs::MsgHash* object_id_;
  ::google::protobuf::uint64 part_nr_;
  ::google::protobuf::uint64 expected_size_;
  bool last_part_;
  int object_type_;
  ::std::string* description_;
  ::google::protobuf::uint32 data_crc32_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgStoreReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgStoreAbortReq : public ::google::protobuf::MessageLite {
 public:
  MsgStoreAbortReq();
  virtual ~MsgStoreAbortReq();

  MsgStoreAbortReq(const MsgStoreAbortReq& from);

  inline MsgStoreAbortReq& operator=(const MsgStoreAbortReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgStoreAbortReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgStoreAbortReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgStoreAbortReq* other);

  // implements Message ----------------------------------------------

  MsgStoreAbortReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgStoreAbortReq& from);
  void MergeFrom(const MsgStoreAbortReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.MsgHash object_id = 3;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  inline const ::cvmfs::MsgHash& object_id() const;
  inline ::cvmfs::MsgHash* mutable_object_id();
  inline ::cvmfs::MsgHash* release_object_id();
  inline void set_allocated_object_id(::cvmfs::MsgHash* object_id);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgStoreAbortReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_object_id();
  inline void clear_has_object_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::cvmfs::MsgHash* object_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgStoreAbortReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgStoreReply : public ::google::protobuf::MessageLite {
 public:
  MsgStoreReply();
  virtual ~MsgStoreReply();

  MsgStoreReply(const MsgStoreReply& from);

  inline MsgStoreReply& operator=(const MsgStoreReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgStoreReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgStoreReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgStoreReply* other);

  // implements Message ----------------------------------------------

  MsgStoreReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgStoreReply& from);
  void MergeFrom(const MsgStoreReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // required uint64 part_nr = 3;
  inline bool has_part_nr() const;
  inline void clear_part_nr();
  static const int kPartNrFieldNumber = 3;
  inline ::google::protobuf::uint64 part_nr() const;
  inline void set_part_nr(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgStoreReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_part_nr();
  inline void clear_has_part_nr();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  ::google::protobuf::uint64 part_nr_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgStoreReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgRefcountReq : public ::google::protobuf::MessageLite {
 public:
  MsgRefcountReq();
  virtual ~MsgRefcountReq();

  MsgRefcountReq(const MsgRefcountReq& from);

  inline MsgRefcountReq& operator=(const MsgRefcountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgRefcountReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgRefcountReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgRefcountReq* other);

  // implements Message ----------------------------------------------

  MsgRefcountReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgRefcountReq& from);
  void MergeFrom(const MsgRefcountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.MsgHash object_id = 3;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  inline const ::cvmfs::MsgHash& object_id() const;
  inline ::cvmfs::MsgHash* mutable_object_id();
  inline ::cvmfs::MsgHash* release_object_id();
  inline void set_allocated_object_id(::cvmfs::MsgHash* object_id);

  // required sint32 change_by = 4;
  inline bool has_change_by() const;
  inline void clear_change_by();
  static const int kChangeByFieldNumber = 4;
  inline ::google::protobuf::int32 change_by() const;
  inline void set_change_by(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgRefcountReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_change_by();
  inline void clear_has_change_by();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::cvmfs::MsgHash* object_id_;
  ::google::protobuf::int32 change_by_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgRefcountReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgRefcountReply : public ::google::protobuf::MessageLite {
 public:
  MsgRefcountReply();
  virtual ~MsgRefcountReply();

  MsgRefcountReply(const MsgRefcountReply& from);

  inline MsgRefcountReply& operator=(const MsgRefcountReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgRefcountReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgRefcountReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgRefcountReply* other);

  // implements Message ----------------------------------------------

  MsgRefcountReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgRefcountReply& from);
  void MergeFrom(const MsgRefcountReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgRefcountReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgRefcountReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgDetach : public ::google::protobuf::MessageLite {
 public:
  MsgDetach();
  virtual ~MsgDetach();

  MsgDetach(const MsgDetach& from);

  inline MsgDetach& operator=(const MsgDetach& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgDetach& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgDetach* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgDetach* other);

  // implements Message ----------------------------------------------

  MsgDetach* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgDetach& from);
  void MergeFrom(const MsgDetach& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cvmfs.MsgDetach)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgDetach* default_instance_;
};
// -------------------------------------------------------------------

class MsgShrinkReq : public ::google::protobuf::MessageLite {
 public:
  MsgShrinkReq();
  virtual ~MsgShrinkReq();

  MsgShrinkReq(const MsgShrinkReq& from);

  inline MsgShrinkReq& operator=(const MsgShrinkReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgShrinkReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgShrinkReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgShrinkReq* other);

  // implements Message ----------------------------------------------

  MsgShrinkReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgShrinkReq& from);
  void MergeFrom(const MsgShrinkReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required uint64 shrink_to = 3;
  inline bool has_shrink_to() const;
  inline void clear_shrink_to();
  static const int kShrinkToFieldNumber = 3;
  inline ::google::protobuf::uint64 shrink_to() const;
  inline void set_shrink_to(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgShrinkReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_shrink_to();
  inline void clear_has_shrink_to();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::google::protobuf::uint64 shrink_to_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgShrinkReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgShrinkReply : public ::google::protobuf::MessageLite {
 public:
  MsgShrinkReply();
  virtual ~MsgShrinkReply();

  MsgShrinkReply(const MsgShrinkReply& from);

  inline MsgShrinkReply& operator=(const MsgShrinkReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgShrinkReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgShrinkReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgShrinkReply* other);

  // implements Message ----------------------------------------------

  MsgShrinkReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgShrinkReply& from);
  void MergeFrom(const MsgShrinkReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // required uint64 used_bytes = 3;
  inline bool has_used_bytes() const;
  inline void clear_used_bytes();
  static const int kUsedBytesFieldNumber = 3;
  inline ::google::protobuf::uint64 used_bytes() const;
  inline void set_used_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgShrinkReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_used_bytes();
  inline void clear_has_used_bytes();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  ::google::protobuf::uint64 used_bytes_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgShrinkReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgReadReq : public ::google::protobuf::MessageLite {
 public:
  MsgReadReq();
  virtual ~MsgReadReq();

  MsgReadReq(const MsgReadReq& from);

  inline MsgReadReq& operator=(const MsgReadReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgReadReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgReadReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgReadReq* other);

  // implements Message ----------------------------------------------

  MsgReadReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgReadReq& from);
  void MergeFrom(const MsgReadReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.MsgHash object_id = 3;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  inline const ::cvmfs::MsgHash& object_id() const;
  inline ::cvmfs::MsgHash* mutable_object_id();
  inline ::cvmfs::MsgHash* release_object_id();
  inline void set_allocated_object_id(::cvmfs::MsgHash* object_id);

  // required uint64 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);

  // required uint32 size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgReadReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_size();
  inline void clear_has_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::cvmfs::MsgHash* object_id_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint32 size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgReadReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgReadReply : public ::google::protobuf::MessageLite {
 public:
  MsgReadReply();
  virtual ~MsgReadReply();

  MsgReadReply(const MsgReadReply& from);

  inline MsgReadReply& operator=(const MsgReadReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgReadReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgReadReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgReadReply* other);

  // implements Message ----------------------------------------------

  MsgReadReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgReadReply& from);
  void MergeFrom(const MsgReadReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // optional fixed32 data_crc32 = 3;
  inline bool has_data_crc32() const;
  inline void clear_data_crc32();
  static const int kDataCrc32FieldNumber = 3;
  inline ::google::protobuf::uint32 data_crc32() const;
  inline void set_data_crc32(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgReadReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_data_crc32();
  inline void clear_has_data_crc32();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  int status_;
  ::google::protobuf::uint32 data_crc32_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgReadReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfoReq : public ::google::protobuf::MessageLite {
 public:
  MsgInfoReq();
  virtual ~MsgInfoReq();

  MsgInfoReq(const MsgInfoReq& from);

  inline MsgInfoReq& operator=(const MsgInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgInfoReq* other);

  // implements Message ----------------------------------------------

  MsgInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgInfoReq& from);
  void MergeFrom(const MsgInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // optional uint64 no_shrink_in_period = 3;
  inline bool has_no_shrink_in_period() const;
  inline void clear_no_shrink_in_period();
  static const int kNoShrinkInPeriodFieldNumber = 3;
  inline ::google::protobuf::uint64 no_shrink_in_period() const;
  inline void set_no_shrink_in_period(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgInfoReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_no_shrink_in_period();
  inline void clear_has_no_shrink_in_period();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::google::protobuf::uint64 no_shrink_in_period_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfoReply : public ::google::protobuf::MessageLite {
 public:
  MsgInfoReply();
  virtual ~MsgInfoReply();

  MsgInfoReply(const MsgInfoReply& from);

  inline MsgInfoReply& operator=(const MsgInfoReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgInfoReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgInfoReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgInfoReply* other);

  // implements Message ----------------------------------------------

  MsgInfoReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgInfoReply& from);
  void MergeFrom(const MsgInfoReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // required uint64 size_bytes = 3;
  inline bool has_size_bytes() const;
  inline void clear_size_bytes();
  static const int kSizeBytesFieldNumber = 3;
  inline ::google::protobuf::uint64 size_bytes() const;
  inline void set_size_bytes(::google::protobuf::uint64 value);

  // required uint64 used_bytes = 4;
  inline bool has_used_bytes() const;
  inline void clear_used_bytes();
  static const int kUsedBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 used_bytes() const;
  inline void set_used_bytes(::google::protobuf::uint64 value);

  // required uint64 pinned_bytes = 5;
  inline bool has_pinned_bytes() const;
  inline void clear_pinned_bytes();
  static const int kPinnedBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 pinned_bytes() const;
  inline void set_pinned_bytes(::google::protobuf::uint64 value);

  // required int64 no_shrink = 6;
  inline bool has_no_shrink() const;
  inline void clear_no_shrink();
  static const int kNoShrinkFieldNumber = 6;
  inline ::google::protobuf::int64 no_shrink() const;
  inline void set_no_shrink(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgInfoReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_size_bytes();
  inline void clear_has_size_bytes();
  inline void set_has_used_bytes();
  inline void clear_has_used_bytes();
  inline void set_has_pinned_bytes();
  inline void clear_has_pinned_bytes();
  inline void set_has_no_shrink();
  inline void clear_has_no_shrink();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  ::google::protobuf::uint64 size_bytes_;
  ::google::protobuf::uint64 used_bytes_;
  ::google::protobuf::uint64 pinned_bytes_;
  ::google::protobuf::int64 no_shrink_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectInfoReq : public ::google::protobuf::MessageLite {
 public:
  MsgObjectInfoReq();
  virtual ~MsgObjectInfoReq();

  MsgObjectInfoReq(const MsgObjectInfoReq& from);

  inline MsgObjectInfoReq& operator=(const MsgObjectInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgObjectInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgObjectInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgObjectInfoReq* other);

  // implements Message ----------------------------------------------

  MsgObjectInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgObjectInfoReq& from);
  void MergeFrom(const MsgObjectInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.MsgHash object_id = 3;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  inline const ::cvmfs::MsgHash& object_id() const;
  inline ::cvmfs::MsgHash* mutable_object_id();
  inline ::cvmfs::MsgHash* release_object_id();
  inline void set_allocated_object_id(::cvmfs::MsgHash* object_id);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgObjectInfoReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_object_id();
  inline void clear_has_object_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::cvmfs::MsgHash* object_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgObjectInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgObjectInfoReply : public ::google::protobuf::MessageLite {
 public:
  MsgObjectInfoReply();
  virtual ~MsgObjectInfoReply();

  MsgObjectInfoReply(const MsgObjectInfoReply& from);

  inline MsgObjectInfoReply& operator=(const MsgObjectInfoReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgObjectInfoReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgObjectInfoReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgObjectInfoReply* other);

  // implements Message ----------------------------------------------

  MsgObjectInfoReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgObjectInfoReply& from);
  void MergeFrom(const MsgObjectInfoReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // optional .cvmfs.EnumObjectType object_type = 3;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 3;
  inline ::cvmfs::EnumObjectType object_type() const;
  inline void set_object_type(::cvmfs::EnumObjectType value);

  // optional uint64 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgObjectInfoReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_size();
  inline void clear_has_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  int status_;
  int object_type_;
  ::google::protobuf::uint64 size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgObjectInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgListReq : public ::google::protobuf::MessageLite {
 public:
  MsgListReq();
  virtual ~MsgListReq();

  MsgListReq(const MsgListReq& from);

  inline MsgListReq& operator=(const MsgListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgListReq* other);

  // implements Message ----------------------------------------------

  MsgListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgListReq& from);
  void MergeFrom(const MsgListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required uint64 listing_id = 3;
  inline bool has_listing_id() const;
  inline void clear_listing_id();
  static const int kListingIdFieldNumber = 3;
  inline ::google::protobuf::uint64 listing_id() const;
  inline void set_listing_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumObjectType object_type = 4;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 4;
  inline ::cvmfs::EnumObjectType object_type() const;
  inline void set_object_type(::cvmfs::EnumObjectType value);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgListReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_listing_id();
  inline void clear_has_listing_id();
  inline void set_has_object_type();
  inline void clear_has_object_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::google::protobuf::uint64 listing_id_;
  int object_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgListReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgListReply : public ::google::protobuf::MessageLite {
 public:
  MsgListReply();
  virtual ~MsgListReply();

  MsgListReply(const MsgListReply& from);

  inline MsgListReply& operator=(const MsgListReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgListReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgListReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgListReply* other);

  // implements Message ----------------------------------------------

  MsgListReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgListReply& from);
  void MergeFrom(const MsgListReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // required uint64 listing_id = 3;
  inline bool has_listing_id() const;
  inline void clear_listing_id();
  static const int kListingIdFieldNumber = 3;
  inline ::google::protobuf::uint64 listing_id() const;
  inline void set_listing_id(::google::protobuf::uint64 value);

  // required bool is_last_part = 4;
  inline bool has_is_last_part() const;
  inline void clear_is_last_part();
  static const int kIsLastPartFieldNumber = 4;
  inline bool is_last_part() const;
  inline void set_is_last_part(bool value);

  // repeated .cvmfs.MsgListRecord list_record = 5;
  inline int list_record_size() const;
  inline void clear_list_record();
  static const int kListRecordFieldNumber = 5;
  inline const ::cvmfs::MsgListRecord& list_record(int index) const;
  inline ::cvmfs::MsgListRecord* mutable_list_record(int index);
  inline ::cvmfs::MsgListRecord* add_list_record();
  inline const ::google::protobuf::RepeatedPtrField< ::cvmfs::MsgListRecord >&
      list_record() const;
  inline ::google::protobuf::RepeatedPtrField< ::cvmfs::MsgListRecord >*
      mutable_list_record();

  // @@protoc_insertion_point(class_scope:cvmfs.MsgListReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_listing_id();
  inline void clear_has_listing_id();
  inline void set_has_is_last_part();
  inline void clear_has_is_last_part();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  ::google::protobuf::uint64 listing_id_;
  int status_;
  bool is_last_part_;
  ::google::protobuf::RepeatedPtrField< ::cvmfs::MsgListRecord > list_record_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgListReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgBreadcrumbStoreReq : public ::google::protobuf::MessageLite {
 public:
  MsgBreadcrumbStoreReq();
  virtual ~MsgBreadcrumbStoreReq();

  MsgBreadcrumbStoreReq(const MsgBreadcrumbStoreReq& from);

  inline MsgBreadcrumbStoreReq& operator=(const MsgBreadcrumbStoreReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgBreadcrumbStoreReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgBreadcrumbStoreReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgBreadcrumbStoreReq* other);

  // implements Message ----------------------------------------------

  MsgBreadcrumbStoreReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgBreadcrumbStoreReq& from);
  void MergeFrom(const MsgBreadcrumbStoreReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.MsgBreadcrumb breadcrumb = 3;
  inline bool has_breadcrumb() const;
  inline void clear_breadcrumb();
  static const int kBreadcrumbFieldNumber = 3;
  inline const ::cvmfs::MsgBreadcrumb& breadcrumb() const;
  inline ::cvmfs::MsgBreadcrumb* mutable_breadcrumb();
  inline ::cvmfs::MsgBreadcrumb* release_breadcrumb();
  inline void set_allocated_breadcrumb(::cvmfs::MsgBreadcrumb* breadcrumb);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgBreadcrumbStoreReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_breadcrumb();
  inline void clear_has_breadcrumb();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::cvmfs::MsgBreadcrumb* breadcrumb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgBreadcrumbStoreReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgBreadcrumbLoadReq : public ::google::protobuf::MessageLite {
 public:
  MsgBreadcrumbLoadReq();
  virtual ~MsgBreadcrumbLoadReq();

  MsgBreadcrumbLoadReq(const MsgBreadcrumbLoadReq& from);

  inline MsgBreadcrumbLoadReq& operator=(const MsgBreadcrumbLoadReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgBreadcrumbLoadReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgBreadcrumbLoadReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgBreadcrumbLoadReq* other);

  // implements Message ----------------------------------------------

  MsgBreadcrumbLoadReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgBreadcrumbLoadReq& from);
  void MergeFrom(const MsgBreadcrumbLoadReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 session_id() const;
  inline void set_session_id(::google::protobuf::uint64 value);

  // required uint64 req_id = 2;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required string fqrn = 3;
  inline bool has_fqrn() const;
  inline void clear_fqrn();
  static const int kFqrnFieldNumber = 3;
  inline const ::std::string& fqrn() const;
  inline void set_fqrn(const ::std::string& value);
  inline void set_fqrn(const char* value);
  inline void set_fqrn(const char* value, size_t size);
  inline ::std::string* mutable_fqrn();
  inline ::std::string* release_fqrn();
  inline void set_allocated_fqrn(::std::string* fqrn);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgBreadcrumbLoadReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_fqrn();
  inline void clear_has_fqrn();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 session_id_;
  ::google::protobuf::uint64 req_id_;
  ::std::string* fqrn_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgBreadcrumbLoadReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgBreadcrumbReply : public ::google::protobuf::MessageLite {
 public:
  MsgBreadcrumbReply();
  virtual ~MsgBreadcrumbReply();

  MsgBreadcrumbReply(const MsgBreadcrumbReply& from);

  inline MsgBreadcrumbReply& operator=(const MsgBreadcrumbReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgBreadcrumbReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgBreadcrumbReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgBreadcrumbReply* other);

  // implements Message ----------------------------------------------

  MsgBreadcrumbReply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgBreadcrumbReply& from);
  void MergeFrom(const MsgBreadcrumbReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req_id = 1;
  inline bool has_req_id() const;
  inline void clear_req_id();
  static const int kReqIdFieldNumber = 1;
  inline ::google::protobuf::uint64 req_id() const;
  inline void set_req_id(::google::protobuf::uint64 value);

  // required .cvmfs.EnumStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cvmfs::EnumStatus status() const;
  inline void set_status(::cvmfs::EnumStatus value);

  // optional .cvmfs.MsgBreadcrumb breadcrumb = 3;
  inline bool has_breadcrumb() const;
  inline void clear_breadcrumb();
  static const int kBreadcrumbFieldNumber = 3;
  inline const ::cvmfs::MsgBreadcrumb& breadcrumb() const;
  inline ::cvmfs::MsgBreadcrumb* mutable_breadcrumb();
  inline ::cvmfs::MsgBreadcrumb* release_breadcrumb();
  inline void set_allocated_breadcrumb(::cvmfs::MsgBreadcrumb* breadcrumb);

  // @@protoc_insertion_point(class_scope:cvmfs.MsgBreadcrumbReply)
 private:
  inline void set_has_req_id();
  inline void clear_has_req_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_breadcrumb();
  inline void clear_has_breadcrumb();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 req_id_;
  ::cvmfs::MsgBreadcrumb* breadcrumb_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgBreadcrumbReply* default_instance_;
};
// -------------------------------------------------------------------

class MsgRpc : public ::google::protobuf::MessageLite {
 public:
  MsgRpc();
  virtual ~MsgRpc();

  MsgRpc(const MsgRpc& from);

  inline MsgRpc& operator=(const MsgRpc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgRpc& default_instance();

  enum MessageTypeCase {
    kMsgRefcountReq = 1,
    kMsgRefcountReply = 2,
    kMsgReadReq = 3,
    kMsgReadReply = 4,
    kMsgObjectInfoReq = 5,
    kMsgObjectInfoReply = 6,
    kMsgStoreReq = 7,
    kMsgStoreAbortReq = 8,
    kMsgStoreReply = 9,
    kMsgHandshake = 16,
    kMsgHandshakeAck = 17,
    kMsgQuit = 18,
    kMsgInfoReq = 19,
    kMsgInfoReply = 20,
    kMsgShrinkReq = 21,
    kMsgShrinkReply = 22,
    kMsgListReq = 23,
    kMsgListReply = 24,
    kMsgDetach = 25,
    kMsgIoctl = 26,
    kMsgBreadcrumbStoreReq = 27,
    kMsgBreadcrumbLoadReq = 28,
    kMsgBreadcrumbReply = 29,
    MESSAGE_TYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgRpc* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgRpc* other);

  // implements Message ----------------------------------------------

  MsgRpc* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgRpc& from);
  void MergeFrom(const MsgRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cvmfs.MsgRefcountReq msg_refcount_req = 1;
  inline bool has_msg_refcount_req() const;
  inline void clear_msg_refcount_req();
  static const int kMsgRefcountReqFieldNumber = 1;
  inline const ::cvmfs::MsgRefcountReq& msg_refcount_req() const;
  inline ::cvmfs::MsgRefcountReq* mutable_msg_refcount_req();
  inline ::cvmfs::MsgRefcountReq* release_msg_refcount_req();
  inline void set_allocated_msg_refcount_req(::cvmfs::MsgRefcountReq* msg_refcount_req);

  // optional .cvmfs.MsgRefcountReply msg_refcount_reply = 2;
  inline bool has_msg_refcount_reply() const;
  inline void clear_msg_refcount_reply();
  static const int kMsgRefcountReplyFieldNumber = 2;
  inline const ::cvmfs::MsgRefcountReply& msg_refcount_reply() const;
  inline ::cvmfs::MsgRefcountReply* mutable_msg_refcount_reply();
  inline ::cvmfs::MsgRefcountReply* release_msg_refcount_reply();
  inline void set_allocated_msg_refcount_reply(::cvmfs::MsgRefcountReply* msg_refcount_reply);

  // optional .cvmfs.MsgReadReq msg_read_req = 3;
  inline bool has_msg_read_req() const;
  inline void clear_msg_read_req();
  static const int kMsgReadReqFieldNumber = 3;
  inline const ::cvmfs::MsgReadReq& msg_read_req() const;
  inline ::cvmfs::MsgReadReq* mutable_msg_read_req();
  inline ::cvmfs::MsgReadReq* release_msg_read_req();
  inline void set_allocated_msg_read_req(::cvmfs::MsgReadReq* msg_read_req);

  // optional .cvmfs.MsgReadReply msg_read_reply = 4;
  inline bool has_msg_read_reply() const;
  inline void clear_msg_read_reply();
  static const int kMsgReadReplyFieldNumber = 4;
  inline const ::cvmfs::MsgReadReply& msg_read_reply() const;
  inline ::cvmfs::MsgReadReply* mutable_msg_read_reply();
  inline ::cvmfs::MsgReadReply* release_msg_read_reply();
  inline void set_allocated_msg_read_reply(::cvmfs::MsgReadReply* msg_read_reply);

  // optional .cvmfs.MsgObjectInfoReq msg_object_info_req = 5;
  inline bool has_msg_object_info_req() const;
  inline void clear_msg_object_info_req();
  static const int kMsgObjectInfoReqFieldNumber = 5;
  inline const ::cvmfs::MsgObjectInfoReq& msg_object_info_req() const;
  inline ::cvmfs::MsgObjectInfoReq* mutable_msg_object_info_req();
  inline ::cvmfs::MsgObjectInfoReq* release_msg_object_info_req();
  inline void set_allocated_msg_object_info_req(::cvmfs::MsgObjectInfoReq* msg_object_info_req);

  // optional .cvmfs.MsgObjectInfoReply msg_object_info_reply = 6;
  inline bool has_msg_object_info_reply() const;
  inline void clear_msg_object_info_reply();
  static const int kMsgObjectInfoReplyFieldNumber = 6;
  inline const ::cvmfs::MsgObjectInfoReply& msg_object_info_reply() const;
  inline ::cvmfs::MsgObjectInfoReply* mutable_msg_object_info_reply();
  inline ::cvmfs::MsgObjectInfoReply* release_msg_object_info_reply();
  inline void set_allocated_msg_object_info_reply(::cvmfs::MsgObjectInfoReply* msg_object_info_reply);

  // optional .cvmfs.MsgStoreReq msg_store_req = 7;
  inline bool has_msg_store_req() const;
  inline void clear_msg_store_req();
  static const int kMsgStoreReqFieldNumber = 7;
  inline const ::cvmfs::MsgStoreReq& msg_store_req() const;
  inline ::cvmfs::MsgStoreReq* mutable_msg_store_req();
  inline ::cvmfs::MsgStoreReq* release_msg_store_req();
  inline void set_allocated_msg_store_req(::cvmfs::MsgStoreReq* msg_store_req);

  // optional .cvmfs.MsgStoreAbortReq msg_store_abort_req = 8;
  inline bool has_msg_store_abort_req() const;
  inline void clear_msg_store_abort_req();
  static const int kMsgStoreAbortReqFieldNumber = 8;
  inline const ::cvmfs::MsgStoreAbortReq& msg_store_abort_req() const;
  inline ::cvmfs::MsgStoreAbortReq* mutable_msg_store_abort_req();
  inline ::cvmfs::MsgStoreAbortReq* release_msg_store_abort_req();
  inline void set_allocated_msg_store_abort_req(::cvmfs::MsgStoreAbortReq* msg_store_abort_req);

  // optional .cvmfs.MsgStoreReply msg_store_reply = 9;
  inline bool has_msg_store_reply() const;
  inline void clear_msg_store_reply();
  static const int kMsgStoreReplyFieldNumber = 9;
  inline const ::cvmfs::MsgStoreReply& msg_store_reply() const;
  inline ::cvmfs::MsgStoreReply* mutable_msg_store_reply();
  inline ::cvmfs::MsgStoreReply* release_msg_store_reply();
  inline void set_allocated_msg_store_reply(::cvmfs::MsgStoreReply* msg_store_reply);

  // optional .cvmfs.MsgHandshake msg_handshake = 16;
  inline bool has_msg_handshake() const;
  inline void clear_msg_handshake();
  static const int kMsgHandshakeFieldNumber = 16;
  inline const ::cvmfs::MsgHandshake& msg_handshake() const;
  inline ::cvmfs::MsgHandshake* mutable_msg_handshake();
  inline ::cvmfs::MsgHandshake* release_msg_handshake();
  inline void set_allocated_msg_handshake(::cvmfs::MsgHandshake* msg_handshake);

  // optional .cvmfs.MsgHandshakeAck msg_handshake_ack = 17;
  inline bool has_msg_handshake_ack() const;
  inline void clear_msg_handshake_ack();
  static const int kMsgHandshakeAckFieldNumber = 17;
  inline const ::cvmfs::MsgHandshakeAck& msg_handshake_ack() const;
  inline ::cvmfs::MsgHandshakeAck* mutable_msg_handshake_ack();
  inline ::cvmfs::MsgHandshakeAck* release_msg_handshake_ack();
  inline void set_allocated_msg_handshake_ack(::cvmfs::MsgHandshakeAck* msg_handshake_ack);

  // optional .cvmfs.MsgQuit msg_quit = 18;
  inline bool has_msg_quit() const;
  inline void clear_msg_quit();
  static const int kMsgQuitFieldNumber = 18;
  inline const ::cvmfs::MsgQuit& msg_quit() const;
  inline ::cvmfs::MsgQuit* mutable_msg_quit();
  inline ::cvmfs::MsgQuit* release_msg_quit();
  inline void set_allocated_msg_quit(::cvmfs::MsgQuit* msg_quit);

  // optional .cvmfs.MsgInfoReq msg_info_req = 19;
  inline bool has_msg_info_req() const;
  inline void clear_msg_info_req();
  static const int kMsgInfoReqFieldNumber = 19;
  inline const ::cvmfs::MsgInfoReq& msg_info_req() const;
  inline ::cvmfs::MsgInfoReq* mutable_msg_info_req();
  inline ::cvmfs::MsgInfoReq* release_msg_info_req();
  inline void set_allocated_msg_info_req(::cvmfs::MsgInfoReq* msg_info_req);

  // optional .cvmfs.MsgInfoReply msg_info_reply = 20;
  inline bool has_msg_info_reply() const;
  inline void clear_msg_info_reply();
  static const int kMsgInfoReplyFieldNumber = 20;
  inline const ::cvmfs::MsgInfoReply& msg_info_reply() const;
  inline ::cvmfs::MsgInfoReply* mutable_msg_info_reply();
  inline ::cvmfs::MsgInfoReply* release_msg_info_reply();
  inline void set_allocated_msg_info_reply(::cvmfs::MsgInfoReply* msg_info_reply);

  // optional .cvmfs.MsgShrinkReq msg_shrink_req = 21;
  inline bool has_msg_shrink_req() const;
  inline void clear_msg_shrink_req();
  static const int kMsgShrinkReqFieldNumber = 21;
  inline const ::cvmfs::MsgShrinkReq& msg_shrink_req() const;
  inline ::cvmfs::MsgShrinkReq* mutable_msg_shrink_req();
  inline ::cvmfs::MsgShrinkReq* release_msg_shrink_req();
  inline void set_allocated_msg_shrink_req(::cvmfs::MsgShrinkReq* msg_shrink_req);

  // optional .cvmfs.MsgShrinkReply msg_shrink_reply = 22;
  inline bool has_msg_shrink_reply() const;
  inline void clear_msg_shrink_reply();
  static const int kMsgShrinkReplyFieldNumber = 22;
  inline const ::cvmfs::MsgShrinkReply& msg_shrink_reply() const;
  inline ::cvmfs::MsgShrinkReply* mutable_msg_shrink_reply();
  inline ::cvmfs::MsgShrinkReply* release_msg_shrink_reply();
  inline void set_allocated_msg_shrink_reply(::cvmfs::MsgShrinkReply* msg_shrink_reply);

  // optional .cvmfs.MsgListReq msg_list_req = 23;
  inline bool has_msg_list_req() const;
  inline void clear_msg_list_req();
  static const int kMsgListReqFieldNumber = 23;
  inline const ::cvmfs::MsgListReq& msg_list_req() const;
  inline ::cvmfs::MsgListReq* mutable_msg_list_req();
  inline ::cvmfs::MsgListReq* release_msg_list_req();
  inline void set_allocated_msg_list_req(::cvmfs::MsgListReq* msg_list_req);

  // optional .cvmfs.MsgListReply msg_list_reply = 24;
  inline bool has_msg_list_reply() const;
  inline void clear_msg_list_reply();
  static const int kMsgListReplyFieldNumber = 24;
  inline const ::cvmfs::MsgListReply& msg_list_reply() const;
  inline ::cvmfs::MsgListReply* mutable_msg_list_reply();
  inline ::cvmfs::MsgListReply* release_msg_list_reply();
  inline void set_allocated_msg_list_reply(::cvmfs::MsgListReply* msg_list_reply);

  // optional .cvmfs.MsgDetach msg_detach = 25;
  inline bool has_msg_detach() const;
  inline void clear_msg_detach();
  static const int kMsgDetachFieldNumber = 25;
  inline const ::cvmfs::MsgDetach& msg_detach() const;
  inline ::cvmfs::MsgDetach* mutable_msg_detach();
  inline ::cvmfs::MsgDetach* release_msg_detach();
  inline void set_allocated_msg_detach(::cvmfs::MsgDetach* msg_detach);

  // optional .cvmfs.MsgIoctl msg_ioctl = 26;
  inline bool has_msg_ioctl() const;
  inline void clear_msg_ioctl();
  static const int kMsgIoctlFieldNumber = 26;
  inline const ::cvmfs::MsgIoctl& msg_ioctl() const;
  inline ::cvmfs::MsgIoctl* mutable_msg_ioctl();
  inline ::cvmfs::MsgIoctl* release_msg_ioctl();
  inline void set_allocated_msg_ioctl(::cvmfs::MsgIoctl* msg_ioctl);

  // optional .cvmfs.MsgBreadcrumbStoreReq msg_breadcrumb_store_req = 27;
  inline bool has_msg_breadcrumb_store_req() const;
  inline void clear_msg_breadcrumb_store_req();
  static const int kMsgBreadcrumbStoreReqFieldNumber = 27;
  inline const ::cvmfs::MsgBreadcrumbStoreReq& msg_breadcrumb_store_req() const;
  inline ::cvmfs::MsgBreadcrumbStoreReq* mutable_msg_breadcrumb_store_req();
  inline ::cvmfs::MsgBreadcrumbStoreReq* release_msg_breadcrumb_store_req();
  inline void set_allocated_msg_breadcrumb_store_req(::cvmfs::MsgBreadcrumbStoreReq* msg_breadcrumb_store_req);

  // optional .cvmfs.MsgBreadcrumbLoadReq msg_breadcrumb_load_req = 28;
  inline bool has_msg_breadcrumb_load_req() const;
  inline void clear_msg_breadcrumb_load_req();
  static const int kMsgBreadcrumbLoadReqFieldNumber = 28;
  inline const ::cvmfs::MsgBreadcrumbLoadReq& msg_breadcrumb_load_req() const;
  inline ::cvmfs::MsgBreadcrumbLoadReq* mutable_msg_breadcrumb_load_req();
  inline ::cvmfs::MsgBreadcrumbLoadReq* release_msg_breadcrumb_load_req();
  inline void set_allocated_msg_breadcrumb_load_req(::cvmfs::MsgBreadcrumbLoadReq* msg_breadcrumb_load_req);

  // optional .cvmfs.MsgBreadcrumbReply msg_breadcrumb_reply = 29;
  inline bool has_msg_breadcrumb_reply() const;
  inline void clear_msg_breadcrumb_reply();
  static const int kMsgBreadcrumbReplyFieldNumber = 29;
  inline const ::cvmfs::MsgBreadcrumbReply& msg_breadcrumb_reply() const;
  inline ::cvmfs::MsgBreadcrumbReply* mutable_msg_breadcrumb_reply();
  inline ::cvmfs::MsgBreadcrumbReply* release_msg_breadcrumb_reply();
  inline void set_allocated_msg_breadcrumb_reply(::cvmfs::MsgBreadcrumbReply* msg_breadcrumb_reply);

  inline MessageTypeCase message_type_case() const;
  // @@protoc_insertion_point(class_scope:cvmfs.MsgRpc)
 private:
  inline void set_has_msg_refcount_req();
  inline void set_has_msg_refcount_reply();
  inline void set_has_msg_read_req();
  inline void set_has_msg_read_reply();
  inline void set_has_msg_object_info_req();
  inline void set_has_msg_object_info_reply();
  inline void set_has_msg_store_req();
  inline void set_has_msg_store_abort_req();
  inline void set_has_msg_store_reply();
  inline void set_has_msg_handshake();
  inline void set_has_msg_handshake_ack();
  inline void set_has_msg_quit();
  inline void set_has_msg_info_req();
  inline void set_has_msg_info_reply();
  inline void set_has_msg_shrink_req();
  inline void set_has_msg_shrink_reply();
  inline void set_has_msg_list_req();
  inline void set_has_msg_list_reply();
  inline void set_has_msg_detach();
  inline void set_has_msg_ioctl();
  inline void set_has_msg_breadcrumb_store_req();
  inline void set_has_msg_breadcrumb_load_req();
  inline void set_has_msg_breadcrumb_reply();

  inline bool has_message_type();
  void clear_message_type();
  inline void clear_has_message_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union MessageTypeUnion {
    ::cvmfs::MsgRefcountReq* msg_refcount_req_;
    ::cvmfs::MsgRefcountReply* msg_refcount_reply_;
    ::cvmfs::MsgReadReq* msg_read_req_;
    ::cvmfs::MsgReadReply* msg_read_reply_;
    ::cvmfs::MsgObjectInfoReq* msg_object_info_req_;
    ::cvmfs::MsgObjectInfoReply* msg_object_info_reply_;
    ::cvmfs::MsgStoreReq* msg_store_req_;
    ::cvmfs::MsgStoreAbortReq* msg_store_abort_req_;
    ::cvmfs::MsgStoreReply* msg_store_reply_;
    ::cvmfs::MsgHandshake* msg_handshake_;
    ::cvmfs::MsgHandshakeAck* msg_handshake_ack_;
    ::cvmfs::MsgQuit* msg_quit_;
    ::cvmfs::MsgInfoReq* msg_info_req_;
    ::cvmfs::MsgInfoReply* msg_info_reply_;
    ::cvmfs::MsgShrinkReq* msg_shrink_req_;
    ::cvmfs::MsgShrinkReply* msg_shrink_reply_;
    ::cvmfs::MsgListReq* msg_list_req_;
    ::cvmfs::MsgListReply* msg_list_reply_;
    ::cvmfs::MsgDetach* msg_detach_;
    ::cvmfs::MsgIoctl* msg_ioctl_;
    ::cvmfs::MsgBreadcrumbStoreReq* msg_breadcrumb_store_req_;
    ::cvmfs::MsgBreadcrumbLoadReq* msg_breadcrumb_load_req_;
    ::cvmfs::MsgBreadcrumbReply* msg_breadcrumb_reply_;
  } message_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cache_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cache_2eproto();
  #endif
  friend void protobuf_AssignDesc_cache_2eproto();
  friend void protobuf_ShutdownFile_cache_2eproto();

  void InitAsDefaultInstance();
  static MsgRpc* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgHash

// required .cvmfs.EnumHashAlgorithm algorithm = 1;
inline bool MsgHash::has_algorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHash::set_has_algorithm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHash::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHash::clear_algorithm() {
  algorithm_ = 0;
  clear_has_algorithm();
}
inline ::cvmfs::EnumHashAlgorithm MsgHash::algorithm() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHash.algorithm)
  return static_cast< ::cvmfs::EnumHashAlgorithm >(algorithm_);
}
inline void MsgHash::set_algorithm(::cvmfs::EnumHashAlgorithm value) {
  assert(::cvmfs::EnumHashAlgorithm_IsValid(value));
  set_has_algorithm();
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHash.algorithm)
}

// required bytes digest = 2;
inline bool MsgHash::has_digest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHash::set_has_digest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHash::clear_has_digest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHash::clear_digest() {
  if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_->clear();
  }
  clear_has_digest();
}
inline const ::std::string& MsgHash::digest() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHash.digest)
  return *digest_;
}
inline void MsgHash::set_digest(const ::std::string& value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
  // @@protoc_insertion_point(field_set:cvmfs.MsgHash.digest)
}
inline void MsgHash::set_digest(const char* value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
  // @@protoc_insertion_point(field_set_char:cvmfs.MsgHash.digest)
}
inline void MsgHash::set_digest(const void* value, size_t size) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cvmfs.MsgHash.digest)
}
inline ::std::string* MsgHash::mutable_digest() {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgHash.digest)
  return digest_;
}
inline ::std::string* MsgHash::release_digest() {
  clear_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = digest_;
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgHash::set_allocated_digest(::std::string* digest) {
  if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete digest_;
  }
  if (digest) {
    set_has_digest();
    digest_ = digest;
  } else {
    clear_has_digest();
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgHash.digest)
}

// -------------------------------------------------------------------

// MsgListRecord

// required .cvmfs.MsgHash hash = 1;
inline bool MsgListRecord::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgListRecord::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgListRecord::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgListRecord::clear_hash() {
  if (hash_ != NULL) hash_->::cvmfs::MsgHash::Clear();
  clear_has_hash();
}
inline const ::cvmfs::MsgHash& MsgListRecord::hash() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListRecord.hash)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hash_ != NULL ? *hash_ : *default_instance().hash_;
#else
  return hash_ != NULL ? *hash_ : *default_instance_->hash_;
#endif
}
inline ::cvmfs::MsgHash* MsgListRecord::mutable_hash() {
  set_has_hash();
  if (hash_ == NULL) hash_ = new ::cvmfs::MsgHash;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgListRecord.hash)
  return hash_;
}
inline ::cvmfs::MsgHash* MsgListRecord::release_hash() {
  clear_has_hash();
  ::cvmfs::MsgHash* temp = hash_;
  hash_ = NULL;
  return temp;
}
inline void MsgListRecord::set_allocated_hash(::cvmfs::MsgHash* hash) {
  delete hash_;
  hash_ = hash;
  if (hash) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgListRecord.hash)
}

// optional bool pinned = 2;
inline bool MsgListRecord::has_pinned() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgListRecord::set_has_pinned() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgListRecord::clear_has_pinned() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgListRecord::clear_pinned() {
  pinned_ = false;
  clear_has_pinned();
}
inline bool MsgListRecord::pinned() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListRecord.pinned)
  return pinned_;
}
inline void MsgListRecord::set_pinned(bool value) {
  set_has_pinned();
  pinned_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListRecord.pinned)
}

// optional string description = 3;
inline bool MsgListRecord::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgListRecord::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgListRecord::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgListRecord::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& MsgListRecord::description() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListRecord.description)
  return *description_;
}
inline void MsgListRecord::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:cvmfs.MsgListRecord.description)
}
inline void MsgListRecord::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:cvmfs.MsgListRecord.description)
}
inline void MsgListRecord::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cvmfs.MsgListRecord.description)
}
inline ::std::string* MsgListRecord::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgListRecord.description)
  return description_;
}
inline ::std::string* MsgListRecord::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgListRecord::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgListRecord.description)
}

// -------------------------------------------------------------------

// MsgBreadcrumb

// required string fqrn = 1;
inline bool MsgBreadcrumb::has_fqrn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBreadcrumb::set_has_fqrn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBreadcrumb::clear_has_fqrn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBreadcrumb::clear_fqrn() {
  if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_->clear();
  }
  clear_has_fqrn();
}
inline const ::std::string& MsgBreadcrumb::fqrn() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumb.fqrn)
  return *fqrn_;
}
inline void MsgBreadcrumb::set_fqrn(const ::std::string& value) {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  fqrn_->assign(value);
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumb.fqrn)
}
inline void MsgBreadcrumb::set_fqrn(const char* value) {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  fqrn_->assign(value);
  // @@protoc_insertion_point(field_set_char:cvmfs.MsgBreadcrumb.fqrn)
}
inline void MsgBreadcrumb::set_fqrn(const char* value, size_t size) {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  fqrn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cvmfs.MsgBreadcrumb.fqrn)
}
inline ::std::string* MsgBreadcrumb::mutable_fqrn() {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgBreadcrumb.fqrn)
  return fqrn_;
}
inline ::std::string* MsgBreadcrumb::release_fqrn() {
  clear_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fqrn_;
    fqrn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgBreadcrumb::set_allocated_fqrn(::std::string* fqrn) {
  if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fqrn_;
  }
  if (fqrn) {
    set_has_fqrn();
    fqrn_ = fqrn;
  } else {
    clear_has_fqrn();
    fqrn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgBreadcrumb.fqrn)
}

// required .cvmfs.MsgHash hash = 2;
inline bool MsgBreadcrumb::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBreadcrumb::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBreadcrumb::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBreadcrumb::clear_hash() {
  if (hash_ != NULL) hash_->::cvmfs::MsgHash::Clear();
  clear_has_hash();
}
inline const ::cvmfs::MsgHash& MsgBreadcrumb::hash() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumb.hash)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hash_ != NULL ? *hash_ : *default_instance().hash_;
#else
  return hash_ != NULL ? *hash_ : *default_instance_->hash_;
#endif
}
inline ::cvmfs::MsgHash* MsgBreadcrumb::mutable_hash() {
  set_has_hash();
  if (hash_ == NULL) hash_ = new ::cvmfs::MsgHash;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgBreadcrumb.hash)
  return hash_;
}
inline ::cvmfs::MsgHash* MsgBreadcrumb::release_hash() {
  clear_has_hash();
  ::cvmfs::MsgHash* temp = hash_;
  hash_ = NULL;
  return temp;
}
inline void MsgBreadcrumb::set_allocated_hash(::cvmfs::MsgHash* hash) {
  delete hash_;
  hash_ = hash;
  if (hash) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgBreadcrumb.hash)
}

// required uint64 timestamp = 3;
inline bool MsgBreadcrumb::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgBreadcrumb::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgBreadcrumb::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgBreadcrumb::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 MsgBreadcrumb::timestamp() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumb.timestamp)
  return timestamp_;
}
inline void MsgBreadcrumb::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumb.timestamp)
}

// -------------------------------------------------------------------

// MsgHandshake

// required uint32 protocol_version = 1;
inline bool MsgHandshake::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHandshake::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHandshake::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHandshake::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 MsgHandshake::protocol_version() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshake.protocol_version)
  return protocol_version_;
}
inline void MsgHandshake::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshake.protocol_version)
}

// optional string name = 2;
inline bool MsgHandshake::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHandshake::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHandshake::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHandshake::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MsgHandshake::name() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshake.name)
  return *name_;
}
inline void MsgHandshake::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshake.name)
}
inline void MsgHandshake::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:cvmfs.MsgHandshake.name)
}
inline void MsgHandshake::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cvmfs.MsgHandshake.name)
}
inline ::std::string* MsgHandshake::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgHandshake.name)
  return name_;
}
inline ::std::string* MsgHandshake::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgHandshake::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgHandshake.name)
}

// optional uint32 flags = 3;
inline bool MsgHandshake::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgHandshake::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgHandshake::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgHandshake::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MsgHandshake::flags() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshake.flags)
  return flags_;
}
inline void MsgHandshake::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshake.flags)
}

// -------------------------------------------------------------------

// MsgHandshakeAck

// required .cvmfs.EnumStatus status = 1;
inline bool MsgHandshakeAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHandshakeAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHandshakeAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHandshakeAck::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgHandshakeAck::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgHandshakeAck::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.status)
}

// required string name = 2;
inline bool MsgHandshakeAck::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHandshakeAck::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHandshakeAck::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHandshakeAck::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MsgHandshakeAck::name() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.name)
  return *name_;
}
inline void MsgHandshakeAck::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.name)
}
inline void MsgHandshakeAck::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:cvmfs.MsgHandshakeAck.name)
}
inline void MsgHandshakeAck::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cvmfs.MsgHandshakeAck.name)
}
inline ::std::string* MsgHandshakeAck::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgHandshakeAck.name)
  return name_;
}
inline ::std::string* MsgHandshakeAck::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgHandshakeAck::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgHandshakeAck.name)
}

// required uint32 protocol_version = 3;
inline bool MsgHandshakeAck::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgHandshakeAck::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgHandshakeAck::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgHandshakeAck::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 MsgHandshakeAck::protocol_version() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.protocol_version)
  return protocol_version_;
}
inline void MsgHandshakeAck::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.protocol_version)
}

// required uint64 session_id = 4;
inline bool MsgHandshakeAck::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgHandshakeAck::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgHandshakeAck::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgHandshakeAck::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgHandshakeAck::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.session_id)
  return session_id_;
}
inline void MsgHandshakeAck::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.session_id)
}

// required uint32 max_object_size = 5;
inline bool MsgHandshakeAck::has_max_object_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgHandshakeAck::set_has_max_object_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgHandshakeAck::clear_has_max_object_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgHandshakeAck::clear_max_object_size() {
  max_object_size_ = 0u;
  clear_has_max_object_size();
}
inline ::google::protobuf::uint32 MsgHandshakeAck::max_object_size() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.max_object_size)
  return max_object_size_;
}
inline void MsgHandshakeAck::set_max_object_size(::google::protobuf::uint32 value) {
  set_has_max_object_size();
  max_object_size_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.max_object_size)
}

// required uint64 capabilities = 6;
inline bool MsgHandshakeAck::has_capabilities() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgHandshakeAck::set_has_capabilities() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgHandshakeAck::clear_has_capabilities() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgHandshakeAck::clear_capabilities() {
  capabilities_ = GOOGLE_ULONGLONG(0);
  clear_has_capabilities();
}
inline ::google::protobuf::uint64 MsgHandshakeAck::capabilities() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.capabilities)
  return capabilities_;
}
inline void MsgHandshakeAck::set_capabilities(::google::protobuf::uint64 value) {
  set_has_capabilities();
  capabilities_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.capabilities)
}

// optional uint32 flags = 7;
inline bool MsgHandshakeAck::has_flags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgHandshakeAck::set_has_flags() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgHandshakeAck::clear_has_flags() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgHandshakeAck::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MsgHandshakeAck::flags() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.flags)
  return flags_;
}
inline void MsgHandshakeAck::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.flags)
}

// optional uint64 pid = 8;
inline bool MsgHandshakeAck::has_pid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgHandshakeAck::set_has_pid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgHandshakeAck::clear_has_pid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgHandshakeAck::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 MsgHandshakeAck::pid() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgHandshakeAck.pid)
  return pid_;
}
inline void MsgHandshakeAck::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgHandshakeAck.pid)
}

// -------------------------------------------------------------------

// MsgQuit

// required uint64 session_id = 1;
inline bool MsgQuit::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgQuit::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgQuit::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgQuit::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgQuit::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgQuit.session_id)
  return session_id_;
}
inline void MsgQuit::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgQuit.session_id)
}

// -------------------------------------------------------------------

// MsgIoctl

// required uint64 session_id = 1;
inline bool MsgIoctl::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgIoctl::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgIoctl::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgIoctl::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgIoctl::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgIoctl.session_id)
  return session_id_;
}
inline void MsgIoctl::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgIoctl.session_id)
}

// optional sint32 conncnt_change_by = 2;
inline bool MsgIoctl::has_conncnt_change_by() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgIoctl::set_has_conncnt_change_by() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgIoctl::clear_has_conncnt_change_by() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgIoctl::clear_conncnt_change_by() {
  conncnt_change_by_ = 0;
  clear_has_conncnt_change_by();
}
inline ::google::protobuf::int32 MsgIoctl::conncnt_change_by() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgIoctl.conncnt_change_by)
  return conncnt_change_by_;
}
inline void MsgIoctl::set_conncnt_change_by(::google::protobuf::int32 value) {
  set_has_conncnt_change_by();
  conncnt_change_by_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgIoctl.conncnt_change_by)
}

// -------------------------------------------------------------------

// MsgStoreReq

// required uint64 session_id = 1;
inline bool MsgStoreReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgStoreReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgStoreReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgStoreReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgStoreReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.session_id)
  return session_id_;
}
inline void MsgStoreReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgStoreReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgStoreReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgStoreReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgStoreReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgStoreReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.req_id)
  return req_id_;
}
inline void MsgStoreReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.req_id)
}

// required .cvmfs.MsgHash object_id = 3;
inline bool MsgStoreReq::has_object_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgStoreReq::set_has_object_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgStoreReq::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgStoreReq::clear_object_id() {
  if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
  clear_has_object_id();
}
inline const ::cvmfs::MsgHash& MsgStoreReq::object_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
  return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
}
inline ::cvmfs::MsgHash* MsgStoreReq::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) object_id_ = new ::cvmfs::MsgHash;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgStoreReq.object_id)
  return object_id_;
}
inline ::cvmfs::MsgHash* MsgStoreReq::release_object_id() {
  clear_has_object_id();
  ::cvmfs::MsgHash* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline void MsgStoreReq::set_allocated_object_id(::cvmfs::MsgHash* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgStoreReq.object_id)
}

// required uint64 part_nr = 4;
inline bool MsgStoreReq::has_part_nr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgStoreReq::set_has_part_nr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgStoreReq::clear_has_part_nr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgStoreReq::clear_part_nr() {
  part_nr_ = GOOGLE_ULONGLONG(0);
  clear_has_part_nr();
}
inline ::google::protobuf::uint64 MsgStoreReq::part_nr() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.part_nr)
  return part_nr_;
}
inline void MsgStoreReq::set_part_nr(::google::protobuf::uint64 value) {
  set_has_part_nr();
  part_nr_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.part_nr)
}

// required bool last_part = 5;
inline bool MsgStoreReq::has_last_part() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgStoreReq::set_has_last_part() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgStoreReq::clear_has_last_part() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgStoreReq::clear_last_part() {
  last_part_ = false;
  clear_has_last_part();
}
inline bool MsgStoreReq::last_part() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.last_part)
  return last_part_;
}
inline void MsgStoreReq::set_last_part(bool value) {
  set_has_last_part();
  last_part_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.last_part)
}

// optional uint64 expected_size = 6;
inline bool MsgStoreReq::has_expected_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgStoreReq::set_has_expected_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgStoreReq::clear_has_expected_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgStoreReq::clear_expected_size() {
  expected_size_ = GOOGLE_ULONGLONG(0);
  clear_has_expected_size();
}
inline ::google::protobuf::uint64 MsgStoreReq::expected_size() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.expected_size)
  return expected_size_;
}
inline void MsgStoreReq::set_expected_size(::google::protobuf::uint64 value) {
  set_has_expected_size();
  expected_size_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.expected_size)
}

// optional .cvmfs.EnumObjectType object_type = 7;
inline bool MsgStoreReq::has_object_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgStoreReq::set_has_object_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgStoreReq::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgStoreReq::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::cvmfs::EnumObjectType MsgStoreReq::object_type() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.object_type)
  return static_cast< ::cvmfs::EnumObjectType >(object_type_);
}
inline void MsgStoreReq::set_object_type(::cvmfs::EnumObjectType value) {
  assert(::cvmfs::EnumObjectType_IsValid(value));
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.object_type)
}

// optional string description = 8;
inline bool MsgStoreReq::has_description() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgStoreReq::set_has_description() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgStoreReq::clear_has_description() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgStoreReq::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& MsgStoreReq::description() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.description)
  return *description_;
}
inline void MsgStoreReq::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.description)
}
inline void MsgStoreReq::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:cvmfs.MsgStoreReq.description)
}
inline void MsgStoreReq::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cvmfs.MsgStoreReq.description)
}
inline ::std::string* MsgStoreReq::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgStoreReq.description)
  return description_;
}
inline ::std::string* MsgStoreReq::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgStoreReq::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgStoreReq.description)
}

// optional fixed32 data_crc32 = 9;
inline bool MsgStoreReq::has_data_crc32() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgStoreReq::set_has_data_crc32() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgStoreReq::clear_has_data_crc32() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgStoreReq::clear_data_crc32() {
  data_crc32_ = 0u;
  clear_has_data_crc32();
}
inline ::google::protobuf::uint32 MsgStoreReq::data_crc32() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReq.data_crc32)
  return data_crc32_;
}
inline void MsgStoreReq::set_data_crc32(::google::protobuf::uint32 value) {
  set_has_data_crc32();
  data_crc32_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReq.data_crc32)
}

// -------------------------------------------------------------------

// MsgStoreAbortReq

// required uint64 session_id = 1;
inline bool MsgStoreAbortReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgStoreAbortReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgStoreAbortReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgStoreAbortReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgStoreAbortReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreAbortReq.session_id)
  return session_id_;
}
inline void MsgStoreAbortReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreAbortReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgStoreAbortReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgStoreAbortReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgStoreAbortReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgStoreAbortReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgStoreAbortReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreAbortReq.req_id)
  return req_id_;
}
inline void MsgStoreAbortReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreAbortReq.req_id)
}

// required .cvmfs.MsgHash object_id = 3;
inline bool MsgStoreAbortReq::has_object_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgStoreAbortReq::set_has_object_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgStoreAbortReq::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgStoreAbortReq::clear_object_id() {
  if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
  clear_has_object_id();
}
inline const ::cvmfs::MsgHash& MsgStoreAbortReq::object_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreAbortReq.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
  return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
}
inline ::cvmfs::MsgHash* MsgStoreAbortReq::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) object_id_ = new ::cvmfs::MsgHash;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgStoreAbortReq.object_id)
  return object_id_;
}
inline ::cvmfs::MsgHash* MsgStoreAbortReq::release_object_id() {
  clear_has_object_id();
  ::cvmfs::MsgHash* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline void MsgStoreAbortReq::set_allocated_object_id(::cvmfs::MsgHash* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgStoreAbortReq.object_id)
}

// -------------------------------------------------------------------

// MsgStoreReply

// required uint64 req_id = 1;
inline bool MsgStoreReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgStoreReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgStoreReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgStoreReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgStoreReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReply.req_id)
  return req_id_;
}
inline void MsgStoreReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgStoreReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgStoreReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgStoreReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgStoreReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgStoreReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgStoreReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReply.status)
}

// required uint64 part_nr = 3;
inline bool MsgStoreReply::has_part_nr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgStoreReply::set_has_part_nr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgStoreReply::clear_has_part_nr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgStoreReply::clear_part_nr() {
  part_nr_ = GOOGLE_ULONGLONG(0);
  clear_has_part_nr();
}
inline ::google::protobuf::uint64 MsgStoreReply::part_nr() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgStoreReply.part_nr)
  return part_nr_;
}
inline void MsgStoreReply::set_part_nr(::google::protobuf::uint64 value) {
  set_has_part_nr();
  part_nr_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgStoreReply.part_nr)
}

// -------------------------------------------------------------------

// MsgRefcountReq

// required uint64 session_id = 1;
inline bool MsgRefcountReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgRefcountReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgRefcountReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgRefcountReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgRefcountReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgRefcountReq.session_id)
  return session_id_;
}
inline void MsgRefcountReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgRefcountReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgRefcountReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgRefcountReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgRefcountReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgRefcountReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgRefcountReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgRefcountReq.req_id)
  return req_id_;
}
inline void MsgRefcountReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgRefcountReq.req_id)
}

// required .cvmfs.MsgHash object_id = 3;
inline bool MsgRefcountReq::has_object_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgRefcountReq::set_has_object_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgRefcountReq::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgRefcountReq::clear_object_id() {
  if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
  clear_has_object_id();
}
inline const ::cvmfs::MsgHash& MsgRefcountReq::object_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgRefcountReq.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
  return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
}
inline ::cvmfs::MsgHash* MsgRefcountReq::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) object_id_ = new ::cvmfs::MsgHash;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgRefcountReq.object_id)
  return object_id_;
}
inline ::cvmfs::MsgHash* MsgRefcountReq::release_object_id() {
  clear_has_object_id();
  ::cvmfs::MsgHash* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline void MsgRefcountReq::set_allocated_object_id(::cvmfs::MsgHash* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgRefcountReq.object_id)
}

// required sint32 change_by = 4;
inline bool MsgRefcountReq::has_change_by() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgRefcountReq::set_has_change_by() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgRefcountReq::clear_has_change_by() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgRefcountReq::clear_change_by() {
  change_by_ = 0;
  clear_has_change_by();
}
inline ::google::protobuf::int32 MsgRefcountReq::change_by() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgRefcountReq.change_by)
  return change_by_;
}
inline void MsgRefcountReq::set_change_by(::google::protobuf::int32 value) {
  set_has_change_by();
  change_by_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgRefcountReq.change_by)
}

// -------------------------------------------------------------------

// MsgRefcountReply

// required uint64 req_id = 1;
inline bool MsgRefcountReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgRefcountReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgRefcountReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgRefcountReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgRefcountReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgRefcountReply.req_id)
  return req_id_;
}
inline void MsgRefcountReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgRefcountReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgRefcountReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgRefcountReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgRefcountReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgRefcountReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgRefcountReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgRefcountReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgRefcountReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgRefcountReply.status)
}

// -------------------------------------------------------------------

// MsgDetach

// -------------------------------------------------------------------

// MsgShrinkReq

// required uint64 session_id = 1;
inline bool MsgShrinkReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgShrinkReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgShrinkReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgShrinkReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgShrinkReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgShrinkReq.session_id)
  return session_id_;
}
inline void MsgShrinkReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgShrinkReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgShrinkReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgShrinkReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgShrinkReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgShrinkReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgShrinkReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgShrinkReq.req_id)
  return req_id_;
}
inline void MsgShrinkReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgShrinkReq.req_id)
}

// required uint64 shrink_to = 3;
inline bool MsgShrinkReq::has_shrink_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgShrinkReq::set_has_shrink_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgShrinkReq::clear_has_shrink_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgShrinkReq::clear_shrink_to() {
  shrink_to_ = GOOGLE_ULONGLONG(0);
  clear_has_shrink_to();
}
inline ::google::protobuf::uint64 MsgShrinkReq::shrink_to() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgShrinkReq.shrink_to)
  return shrink_to_;
}
inline void MsgShrinkReq::set_shrink_to(::google::protobuf::uint64 value) {
  set_has_shrink_to();
  shrink_to_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgShrinkReq.shrink_to)
}

// -------------------------------------------------------------------

// MsgShrinkReply

// required uint64 req_id = 1;
inline bool MsgShrinkReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgShrinkReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgShrinkReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgShrinkReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgShrinkReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgShrinkReply.req_id)
  return req_id_;
}
inline void MsgShrinkReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgShrinkReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgShrinkReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgShrinkReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgShrinkReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgShrinkReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgShrinkReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgShrinkReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgShrinkReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgShrinkReply.status)
}

// required uint64 used_bytes = 3;
inline bool MsgShrinkReply::has_used_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgShrinkReply::set_has_used_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgShrinkReply::clear_has_used_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgShrinkReply::clear_used_bytes() {
  used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_used_bytes();
}
inline ::google::protobuf::uint64 MsgShrinkReply::used_bytes() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgShrinkReply.used_bytes)
  return used_bytes_;
}
inline void MsgShrinkReply::set_used_bytes(::google::protobuf::uint64 value) {
  set_has_used_bytes();
  used_bytes_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgShrinkReply.used_bytes)
}

// -------------------------------------------------------------------

// MsgReadReq

// required uint64 session_id = 1;
inline bool MsgReadReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgReadReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgReadReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgReadReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgReadReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReq.session_id)
  return session_id_;
}
inline void MsgReadReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgReadReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgReadReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgReadReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgReadReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgReadReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgReadReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReq.req_id)
  return req_id_;
}
inline void MsgReadReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgReadReq.req_id)
}

// required .cvmfs.MsgHash object_id = 3;
inline bool MsgReadReq::has_object_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgReadReq::set_has_object_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgReadReq::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgReadReq::clear_object_id() {
  if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
  clear_has_object_id();
}
inline const ::cvmfs::MsgHash& MsgReadReq::object_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReq.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
  return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
}
inline ::cvmfs::MsgHash* MsgReadReq::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) object_id_ = new ::cvmfs::MsgHash;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgReadReq.object_id)
  return object_id_;
}
inline ::cvmfs::MsgHash* MsgReadReq::release_object_id() {
  clear_has_object_id();
  ::cvmfs::MsgHash* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline void MsgReadReq::set_allocated_object_id(::cvmfs::MsgHash* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgReadReq.object_id)
}

// required uint64 offset = 4;
inline bool MsgReadReq::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgReadReq::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgReadReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgReadReq::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 MsgReadReq::offset() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReq.offset)
  return offset_;
}
inline void MsgReadReq::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgReadReq.offset)
}

// required uint32 size = 5;
inline bool MsgReadReq::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgReadReq::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgReadReq::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgReadReq::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 MsgReadReq::size() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReq.size)
  return size_;
}
inline void MsgReadReq::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgReadReq.size)
}

// -------------------------------------------------------------------

// MsgReadReply

// required uint64 req_id = 1;
inline bool MsgReadReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgReadReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgReadReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgReadReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgReadReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReply.req_id)
  return req_id_;
}
inline void MsgReadReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgReadReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgReadReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgReadReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgReadReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgReadReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgReadReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgReadReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgReadReply.status)
}

// optional fixed32 data_crc32 = 3;
inline bool MsgReadReply::has_data_crc32() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgReadReply::set_has_data_crc32() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgReadReply::clear_has_data_crc32() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgReadReply::clear_data_crc32() {
  data_crc32_ = 0u;
  clear_has_data_crc32();
}
inline ::google::protobuf::uint32 MsgReadReply::data_crc32() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgReadReply.data_crc32)
  return data_crc32_;
}
inline void MsgReadReply::set_data_crc32(::google::protobuf::uint32 value) {
  set_has_data_crc32();
  data_crc32_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgReadReply.data_crc32)
}

// -------------------------------------------------------------------

// MsgInfoReq

// required uint64 session_id = 1;
inline bool MsgInfoReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfoReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfoReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfoReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgInfoReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReq.session_id)
  return session_id_;
}
inline void MsgInfoReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgInfoReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfoReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfoReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfoReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgInfoReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReq.req_id)
  return req_id_;
}
inline void MsgInfoReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReq.req_id)
}

// optional uint64 no_shrink_in_period = 3;
inline bool MsgInfoReq::has_no_shrink_in_period() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfoReq::set_has_no_shrink_in_period() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfoReq::clear_has_no_shrink_in_period() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfoReq::clear_no_shrink_in_period() {
  no_shrink_in_period_ = GOOGLE_ULONGLONG(0);
  clear_has_no_shrink_in_period();
}
inline ::google::protobuf::uint64 MsgInfoReq::no_shrink_in_period() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReq.no_shrink_in_period)
  return no_shrink_in_period_;
}
inline void MsgInfoReq::set_no_shrink_in_period(::google::protobuf::uint64 value) {
  set_has_no_shrink_in_period();
  no_shrink_in_period_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReq.no_shrink_in_period)
}

// -------------------------------------------------------------------

// MsgInfoReply

// required uint64 req_id = 1;
inline bool MsgInfoReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfoReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfoReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfoReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgInfoReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReply.req_id)
  return req_id_;
}
inline void MsgInfoReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgInfoReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfoReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfoReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfoReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgInfoReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgInfoReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReply.status)
}

// required uint64 size_bytes = 3;
inline bool MsgInfoReply::has_size_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfoReply::set_has_size_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfoReply::clear_has_size_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfoReply::clear_size_bytes() {
  size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_size_bytes();
}
inline ::google::protobuf::uint64 MsgInfoReply::size_bytes() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReply.size_bytes)
  return size_bytes_;
}
inline void MsgInfoReply::set_size_bytes(::google::protobuf::uint64 value) {
  set_has_size_bytes();
  size_bytes_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReply.size_bytes)
}

// required uint64 used_bytes = 4;
inline bool MsgInfoReply::has_used_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfoReply::set_has_used_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfoReply::clear_has_used_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfoReply::clear_used_bytes() {
  used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_used_bytes();
}
inline ::google::protobuf::uint64 MsgInfoReply::used_bytes() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReply.used_bytes)
  return used_bytes_;
}
inline void MsgInfoReply::set_used_bytes(::google::protobuf::uint64 value) {
  set_has_used_bytes();
  used_bytes_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReply.used_bytes)
}

// required uint64 pinned_bytes = 5;
inline bool MsgInfoReply::has_pinned_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfoReply::set_has_pinned_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfoReply::clear_has_pinned_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfoReply::clear_pinned_bytes() {
  pinned_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_pinned_bytes();
}
inline ::google::protobuf::uint64 MsgInfoReply::pinned_bytes() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReply.pinned_bytes)
  return pinned_bytes_;
}
inline void MsgInfoReply::set_pinned_bytes(::google::protobuf::uint64 value) {
  set_has_pinned_bytes();
  pinned_bytes_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReply.pinned_bytes)
}

// required int64 no_shrink = 6;
inline bool MsgInfoReply::has_no_shrink() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgInfoReply::set_has_no_shrink() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgInfoReply::clear_has_no_shrink() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgInfoReply::clear_no_shrink() {
  no_shrink_ = GOOGLE_LONGLONG(0);
  clear_has_no_shrink();
}
inline ::google::protobuf::int64 MsgInfoReply::no_shrink() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgInfoReply.no_shrink)
  return no_shrink_;
}
inline void MsgInfoReply::set_no_shrink(::google::protobuf::int64 value) {
  set_has_no_shrink();
  no_shrink_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgInfoReply.no_shrink)
}

// -------------------------------------------------------------------

// MsgObjectInfoReq

// required uint64 session_id = 1;
inline bool MsgObjectInfoReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgObjectInfoReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgObjectInfoReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgObjectInfoReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgObjectInfoReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgObjectInfoReq.session_id)
  return session_id_;
}
inline void MsgObjectInfoReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgObjectInfoReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgObjectInfoReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgObjectInfoReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgObjectInfoReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgObjectInfoReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgObjectInfoReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgObjectInfoReq.req_id)
  return req_id_;
}
inline void MsgObjectInfoReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgObjectInfoReq.req_id)
}

// required .cvmfs.MsgHash object_id = 3;
inline bool MsgObjectInfoReq::has_object_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgObjectInfoReq::set_has_object_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgObjectInfoReq::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgObjectInfoReq::clear_object_id() {
  if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
  clear_has_object_id();
}
inline const ::cvmfs::MsgHash& MsgObjectInfoReq::object_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgObjectInfoReq.object_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return object_id_ != NULL ? *object_id_ : *default_instance().object_id_;
#else
  return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
#endif
}
inline ::cvmfs::MsgHash* MsgObjectInfoReq::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) object_id_ = new ::cvmfs::MsgHash;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgObjectInfoReq.object_id)
  return object_id_;
}
inline ::cvmfs::MsgHash* MsgObjectInfoReq::release_object_id() {
  clear_has_object_id();
  ::cvmfs::MsgHash* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline void MsgObjectInfoReq::set_allocated_object_id(::cvmfs::MsgHash* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgObjectInfoReq.object_id)
}

// -------------------------------------------------------------------

// MsgObjectInfoReply

// required uint64 req_id = 1;
inline bool MsgObjectInfoReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgObjectInfoReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgObjectInfoReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgObjectInfoReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgObjectInfoReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgObjectInfoReply.req_id)
  return req_id_;
}
inline void MsgObjectInfoReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgObjectInfoReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgObjectInfoReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgObjectInfoReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgObjectInfoReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgObjectInfoReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgObjectInfoReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgObjectInfoReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgObjectInfoReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgObjectInfoReply.status)
}

// optional .cvmfs.EnumObjectType object_type = 3;
inline bool MsgObjectInfoReply::has_object_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgObjectInfoReply::set_has_object_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgObjectInfoReply::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgObjectInfoReply::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::cvmfs::EnumObjectType MsgObjectInfoReply::object_type() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgObjectInfoReply.object_type)
  return static_cast< ::cvmfs::EnumObjectType >(object_type_);
}
inline void MsgObjectInfoReply::set_object_type(::cvmfs::EnumObjectType value) {
  assert(::cvmfs::EnumObjectType_IsValid(value));
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgObjectInfoReply.object_type)
}

// optional uint64 size = 4;
inline bool MsgObjectInfoReply::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgObjectInfoReply::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgObjectInfoReply::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgObjectInfoReply::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 MsgObjectInfoReply::size() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgObjectInfoReply.size)
  return size_;
}
inline void MsgObjectInfoReply::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgObjectInfoReply.size)
}

// -------------------------------------------------------------------

// MsgListReq

// required uint64 session_id = 1;
inline bool MsgListReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgListReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgListReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgListReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgListReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReq.session_id)
  return session_id_;
}
inline void MsgListReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgListReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgListReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgListReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgListReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgListReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReq.req_id)
  return req_id_;
}
inline void MsgListReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReq.req_id)
}

// required uint64 listing_id = 3;
inline bool MsgListReq::has_listing_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgListReq::set_has_listing_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgListReq::clear_has_listing_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgListReq::clear_listing_id() {
  listing_id_ = GOOGLE_ULONGLONG(0);
  clear_has_listing_id();
}
inline ::google::protobuf::uint64 MsgListReq::listing_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReq.listing_id)
  return listing_id_;
}
inline void MsgListReq::set_listing_id(::google::protobuf::uint64 value) {
  set_has_listing_id();
  listing_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReq.listing_id)
}

// required .cvmfs.EnumObjectType object_type = 4;
inline bool MsgListReq::has_object_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgListReq::set_has_object_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgListReq::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgListReq::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::cvmfs::EnumObjectType MsgListReq::object_type() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReq.object_type)
  return static_cast< ::cvmfs::EnumObjectType >(object_type_);
}
inline void MsgListReq::set_object_type(::cvmfs::EnumObjectType value) {
  assert(::cvmfs::EnumObjectType_IsValid(value));
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReq.object_type)
}

// -------------------------------------------------------------------

// MsgListReply

// required uint64 req_id = 1;
inline bool MsgListReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgListReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgListReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgListReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgListReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReply.req_id)
  return req_id_;
}
inline void MsgListReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgListReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgListReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgListReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgListReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgListReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgListReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReply.status)
}

// required uint64 listing_id = 3;
inline bool MsgListReply::has_listing_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgListReply::set_has_listing_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgListReply::clear_has_listing_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgListReply::clear_listing_id() {
  listing_id_ = GOOGLE_ULONGLONG(0);
  clear_has_listing_id();
}
inline ::google::protobuf::uint64 MsgListReply::listing_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReply.listing_id)
  return listing_id_;
}
inline void MsgListReply::set_listing_id(::google::protobuf::uint64 value) {
  set_has_listing_id();
  listing_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReply.listing_id)
}

// required bool is_last_part = 4;
inline bool MsgListReply::has_is_last_part() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgListReply::set_has_is_last_part() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgListReply::clear_has_is_last_part() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgListReply::clear_is_last_part() {
  is_last_part_ = false;
  clear_has_is_last_part();
}
inline bool MsgListReply::is_last_part() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReply.is_last_part)
  return is_last_part_;
}
inline void MsgListReply::set_is_last_part(bool value) {
  set_has_is_last_part();
  is_last_part_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgListReply.is_last_part)
}

// repeated .cvmfs.MsgListRecord list_record = 5;
inline int MsgListReply::list_record_size() const {
  return list_record_.size();
}
inline void MsgListReply::clear_list_record() {
  list_record_.Clear();
}
inline const ::cvmfs::MsgListRecord& MsgListReply::list_record(int index) const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgListReply.list_record)
  return list_record_.Get(index);
}
inline ::cvmfs::MsgListRecord* MsgListReply::mutable_list_record(int index) {
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgListReply.list_record)
  return list_record_.Mutable(index);
}
inline ::cvmfs::MsgListRecord* MsgListReply::add_list_record() {
  // @@protoc_insertion_point(field_add:cvmfs.MsgListReply.list_record)
  return list_record_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cvmfs::MsgListRecord >&
MsgListReply::list_record() const {
  // @@protoc_insertion_point(field_list:cvmfs.MsgListReply.list_record)
  return list_record_;
}
inline ::google::protobuf::RepeatedPtrField< ::cvmfs::MsgListRecord >*
MsgListReply::mutable_list_record() {
  // @@protoc_insertion_point(field_mutable_list:cvmfs.MsgListReply.list_record)
  return &list_record_;
}

// -------------------------------------------------------------------

// MsgBreadcrumbStoreReq

// required uint64 session_id = 1;
inline bool MsgBreadcrumbStoreReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBreadcrumbStoreReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBreadcrumbStoreReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBreadcrumbStoreReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgBreadcrumbStoreReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbStoreReq.session_id)
  return session_id_;
}
inline void MsgBreadcrumbStoreReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumbStoreReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgBreadcrumbStoreReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBreadcrumbStoreReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBreadcrumbStoreReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBreadcrumbStoreReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgBreadcrumbStoreReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbStoreReq.req_id)
  return req_id_;
}
inline void MsgBreadcrumbStoreReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumbStoreReq.req_id)
}

// required .cvmfs.MsgBreadcrumb breadcrumb = 3;
inline bool MsgBreadcrumbStoreReq::has_breadcrumb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgBreadcrumbStoreReq::set_has_breadcrumb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgBreadcrumbStoreReq::clear_has_breadcrumb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgBreadcrumbStoreReq::clear_breadcrumb() {
  if (breadcrumb_ != NULL) breadcrumb_->::cvmfs::MsgBreadcrumb::Clear();
  clear_has_breadcrumb();
}
inline const ::cvmfs::MsgBreadcrumb& MsgBreadcrumbStoreReq::breadcrumb() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbStoreReq.breadcrumb)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return breadcrumb_ != NULL ? *breadcrumb_ : *default_instance().breadcrumb_;
#else
  return breadcrumb_ != NULL ? *breadcrumb_ : *default_instance_->breadcrumb_;
#endif
}
inline ::cvmfs::MsgBreadcrumb* MsgBreadcrumbStoreReq::mutable_breadcrumb() {
  set_has_breadcrumb();
  if (breadcrumb_ == NULL) breadcrumb_ = new ::cvmfs::MsgBreadcrumb;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgBreadcrumbStoreReq.breadcrumb)
  return breadcrumb_;
}
inline ::cvmfs::MsgBreadcrumb* MsgBreadcrumbStoreReq::release_breadcrumb() {
  clear_has_breadcrumb();
  ::cvmfs::MsgBreadcrumb* temp = breadcrumb_;
  breadcrumb_ = NULL;
  return temp;
}
inline void MsgBreadcrumbStoreReq::set_allocated_breadcrumb(::cvmfs::MsgBreadcrumb* breadcrumb) {
  delete breadcrumb_;
  breadcrumb_ = breadcrumb;
  if (breadcrumb) {
    set_has_breadcrumb();
  } else {
    clear_has_breadcrumb();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgBreadcrumbStoreReq.breadcrumb)
}

// -------------------------------------------------------------------

// MsgBreadcrumbLoadReq

// required uint64 session_id = 1;
inline bool MsgBreadcrumbLoadReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBreadcrumbLoadReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBreadcrumbLoadReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBreadcrumbLoadReq::clear_session_id() {
  session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::uint64 MsgBreadcrumbLoadReq::session_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbLoadReq.session_id)
  return session_id_;
}
inline void MsgBreadcrumbLoadReq::set_session_id(::google::protobuf::uint64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumbLoadReq.session_id)
}

// required uint64 req_id = 2;
inline bool MsgBreadcrumbLoadReq::has_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBreadcrumbLoadReq::set_has_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBreadcrumbLoadReq::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBreadcrumbLoadReq::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgBreadcrumbLoadReq::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbLoadReq.req_id)
  return req_id_;
}
inline void MsgBreadcrumbLoadReq::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumbLoadReq.req_id)
}

// required string fqrn = 3;
inline bool MsgBreadcrumbLoadReq::has_fqrn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgBreadcrumbLoadReq::set_has_fqrn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgBreadcrumbLoadReq::clear_has_fqrn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgBreadcrumbLoadReq::clear_fqrn() {
  if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_->clear();
  }
  clear_has_fqrn();
}
inline const ::std::string& MsgBreadcrumbLoadReq::fqrn() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbLoadReq.fqrn)
  return *fqrn_;
}
inline void MsgBreadcrumbLoadReq::set_fqrn(const ::std::string& value) {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  fqrn_->assign(value);
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumbLoadReq.fqrn)
}
inline void MsgBreadcrumbLoadReq::set_fqrn(const char* value) {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  fqrn_->assign(value);
  // @@protoc_insertion_point(field_set_char:cvmfs.MsgBreadcrumbLoadReq.fqrn)
}
inline void MsgBreadcrumbLoadReq::set_fqrn(const char* value, size_t size) {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  fqrn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cvmfs.MsgBreadcrumbLoadReq.fqrn)
}
inline ::std::string* MsgBreadcrumbLoadReq::mutable_fqrn() {
  set_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fqrn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgBreadcrumbLoadReq.fqrn)
  return fqrn_;
}
inline ::std::string* MsgBreadcrumbLoadReq::release_fqrn() {
  clear_has_fqrn();
  if (fqrn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fqrn_;
    fqrn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgBreadcrumbLoadReq::set_allocated_fqrn(::std::string* fqrn) {
  if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fqrn_;
  }
  if (fqrn) {
    set_has_fqrn();
    fqrn_ = fqrn;
  } else {
    clear_has_fqrn();
    fqrn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgBreadcrumbLoadReq.fqrn)
}

// -------------------------------------------------------------------

// MsgBreadcrumbReply

// required uint64 req_id = 1;
inline bool MsgBreadcrumbReply::has_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBreadcrumbReply::set_has_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBreadcrumbReply::clear_has_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBreadcrumbReply::clear_req_id() {
  req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_req_id();
}
inline ::google::protobuf::uint64 MsgBreadcrumbReply::req_id() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbReply.req_id)
  return req_id_;
}
inline void MsgBreadcrumbReply::set_req_id(::google::protobuf::uint64 value) {
  set_has_req_id();
  req_id_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumbReply.req_id)
}

// required .cvmfs.EnumStatus status = 2;
inline bool MsgBreadcrumbReply::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBreadcrumbReply::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBreadcrumbReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBreadcrumbReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cvmfs::EnumStatus MsgBreadcrumbReply::status() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbReply.status)
  return static_cast< ::cvmfs::EnumStatus >(status_);
}
inline void MsgBreadcrumbReply::set_status(::cvmfs::EnumStatus value) {
  assert(::cvmfs::EnumStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cvmfs.MsgBreadcrumbReply.status)
}

// optional .cvmfs.MsgBreadcrumb breadcrumb = 3;
inline bool MsgBreadcrumbReply::has_breadcrumb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgBreadcrumbReply::set_has_breadcrumb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgBreadcrumbReply::clear_has_breadcrumb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgBreadcrumbReply::clear_breadcrumb() {
  if (breadcrumb_ != NULL) breadcrumb_->::cvmfs::MsgBreadcrumb::Clear();
  clear_has_breadcrumb();
}
inline const ::cvmfs::MsgBreadcrumb& MsgBreadcrumbReply::breadcrumb() const {
  // @@protoc_insertion_point(field_get:cvmfs.MsgBreadcrumbReply.breadcrumb)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return breadcrumb_ != NULL ? *breadcrumb_ : *default_instance().breadcrumb_;
#else
  return breadcrumb_ != NULL ? *breadcrumb_ : *default_instance_->breadcrumb_;
#endif
}
inline ::cvmfs::MsgBreadcrumb* MsgBreadcrumbReply::mutable_breadcrumb() {
  set_has_breadcrumb();
  if (breadcrumb_ == NULL) breadcrumb_ = new ::cvmfs::MsgBreadcrumb;
  // @@protoc_insertion_point(field_mutable:cvmfs.MsgBreadcrumbReply.breadcrumb)
  return breadcrumb_;
}
inline ::cvmfs::MsgBreadcrumb* MsgBreadcrumbReply::release_breadcrumb() {
  clear_has_breadcrumb();
  ::cvmfs::MsgBreadcrumb* temp = breadcrumb_;
  breadcrumb_ = NULL;
  return temp;
}
inline void MsgBreadcrumbReply::set_allocated_breadcrumb(::cvmfs::MsgBreadcrumb* breadcrumb) {
  delete breadcrumb_;
  breadcrumb_ = breadcrumb;
  if (breadcrumb) {
    set_has_breadcrumb();
  } else {
    clear_has_breadcrumb();
  }
  // @@protoc_insertion_point(field_set_allocated:cvmfs.MsgBreadcrumbReply.breadcrumb)
}

// -------------------------------------------------------------------

// MsgRpc

// optional .cvmfs.MsgRefcountReq msg_refcount_req = 1;
inline bool MsgRpc::has_msg_refcount_req() const {
  return message_type_case() == kMsgRefcountReq;
}
inline void MsgRpc::set_has_msg_refcount_req() {
  _oneof_case_[0] = kMsgRefcountReq;
}
inline void MsgRpc::clear_msg_refcount_req() {
  if (has_msg_refcount_req()) {
    delete message_type_.msg_refcount_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgRefcountReq& MsgRpc::msg_refcount_req() const {
  return has_msg_refcount_req() ? *message_type_.msg_refcount_req_
                      : ::cvmfs::MsgRefcountReq::default_instance();
}
inline ::cvmfs::MsgRefcountReq* MsgRpc::mutable_msg_refcount_req() {
  if (!has_msg_refcount_req()) {
    clear_message_type();
    set_has_msg_refcount_req();
    message_type_.msg_refcount_req_ = new ::cvmfs::MsgRefcountReq;
  }
  return message_type_.msg_refcount_req_;
}
inline ::cvmfs::MsgRefcountReq* MsgRpc::release_msg_refcount_req() {
  if (has_msg_refcount_req()) {
    clear_has_message_type();
    ::cvmfs::MsgRefcountReq* temp = message_type_.msg_refcount_req_;
    message_type_.msg_refcount_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_refcount_req(::cvmfs::MsgRefcountReq* msg_refcount_req) {
  clear_message_type();
  if (msg_refcount_req) {
    set_has_msg_refcount_req();
    message_type_.msg_refcount_req_ = msg_refcount_req;
  }
}

// optional .cvmfs.MsgRefcountReply msg_refcount_reply = 2;
inline bool MsgRpc::has_msg_refcount_reply() const {
  return message_type_case() == kMsgRefcountReply;
}
inline void MsgRpc::set_has_msg_refcount_reply() {
  _oneof_case_[0] = kMsgRefcountReply;
}
inline void MsgRpc::clear_msg_refcount_reply() {
  if (has_msg_refcount_reply()) {
    delete message_type_.msg_refcount_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgRefcountReply& MsgRpc::msg_refcount_reply() const {
  return has_msg_refcount_reply() ? *message_type_.msg_refcount_reply_
                      : ::cvmfs::MsgRefcountReply::default_instance();
}
inline ::cvmfs::MsgRefcountReply* MsgRpc::mutable_msg_refcount_reply() {
  if (!has_msg_refcount_reply()) {
    clear_message_type();
    set_has_msg_refcount_reply();
    message_type_.msg_refcount_reply_ = new ::cvmfs::MsgRefcountReply;
  }
  return message_type_.msg_refcount_reply_;
}
inline ::cvmfs::MsgRefcountReply* MsgRpc::release_msg_refcount_reply() {
  if (has_msg_refcount_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgRefcountReply* temp = message_type_.msg_refcount_reply_;
    message_type_.msg_refcount_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_refcount_reply(::cvmfs::MsgRefcountReply* msg_refcount_reply) {
  clear_message_type();
  if (msg_refcount_reply) {
    set_has_msg_refcount_reply();
    message_type_.msg_refcount_reply_ = msg_refcount_reply;
  }
}

// optional .cvmfs.MsgReadReq msg_read_req = 3;
inline bool MsgRpc::has_msg_read_req() const {
  return message_type_case() == kMsgReadReq;
}
inline void MsgRpc::set_has_msg_read_req() {
  _oneof_case_[0] = kMsgReadReq;
}
inline void MsgRpc::clear_msg_read_req() {
  if (has_msg_read_req()) {
    delete message_type_.msg_read_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgReadReq& MsgRpc::msg_read_req() const {
  return has_msg_read_req() ? *message_type_.msg_read_req_
                      : ::cvmfs::MsgReadReq::default_instance();
}
inline ::cvmfs::MsgReadReq* MsgRpc::mutable_msg_read_req() {
  if (!has_msg_read_req()) {
    clear_message_type();
    set_has_msg_read_req();
    message_type_.msg_read_req_ = new ::cvmfs::MsgReadReq;
  }
  return message_type_.msg_read_req_;
}
inline ::cvmfs::MsgReadReq* MsgRpc::release_msg_read_req() {
  if (has_msg_read_req()) {
    clear_has_message_type();
    ::cvmfs::MsgReadReq* temp = message_type_.msg_read_req_;
    message_type_.msg_read_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_read_req(::cvmfs::MsgReadReq* msg_read_req) {
  clear_message_type();
  if (msg_read_req) {
    set_has_msg_read_req();
    message_type_.msg_read_req_ = msg_read_req;
  }
}

// optional .cvmfs.MsgReadReply msg_read_reply = 4;
inline bool MsgRpc::has_msg_read_reply() const {
  return message_type_case() == kMsgReadReply;
}
inline void MsgRpc::set_has_msg_read_reply() {
  _oneof_case_[0] = kMsgReadReply;
}
inline void MsgRpc::clear_msg_read_reply() {
  if (has_msg_read_reply()) {
    delete message_type_.msg_read_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgReadReply& MsgRpc::msg_read_reply() const {
  return has_msg_read_reply() ? *message_type_.msg_read_reply_
                      : ::cvmfs::MsgReadReply::default_instance();
}
inline ::cvmfs::MsgReadReply* MsgRpc::mutable_msg_read_reply() {
  if (!has_msg_read_reply()) {
    clear_message_type();
    set_has_msg_read_reply();
    message_type_.msg_read_reply_ = new ::cvmfs::MsgReadReply;
  }
  return message_type_.msg_read_reply_;
}
inline ::cvmfs::MsgReadReply* MsgRpc::release_msg_read_reply() {
  if (has_msg_read_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgReadReply* temp = message_type_.msg_read_reply_;
    message_type_.msg_read_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_read_reply(::cvmfs::MsgReadReply* msg_read_reply) {
  clear_message_type();
  if (msg_read_reply) {
    set_has_msg_read_reply();
    message_type_.msg_read_reply_ = msg_read_reply;
  }
}

// optional .cvmfs.MsgObjectInfoReq msg_object_info_req = 5;
inline bool MsgRpc::has_msg_object_info_req() const {
  return message_type_case() == kMsgObjectInfoReq;
}
inline void MsgRpc::set_has_msg_object_info_req() {
  _oneof_case_[0] = kMsgObjectInfoReq;
}
inline void MsgRpc::clear_msg_object_info_req() {
  if (has_msg_object_info_req()) {
    delete message_type_.msg_object_info_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgObjectInfoReq& MsgRpc::msg_object_info_req() const {
  return has_msg_object_info_req() ? *message_type_.msg_object_info_req_
                      : ::cvmfs::MsgObjectInfoReq::default_instance();
}
inline ::cvmfs::MsgObjectInfoReq* MsgRpc::mutable_msg_object_info_req() {
  if (!has_msg_object_info_req()) {
    clear_message_type();
    set_has_msg_object_info_req();
    message_type_.msg_object_info_req_ = new ::cvmfs::MsgObjectInfoReq;
  }
  return message_type_.msg_object_info_req_;
}
inline ::cvmfs::MsgObjectInfoReq* MsgRpc::release_msg_object_info_req() {
  if (has_msg_object_info_req()) {
    clear_has_message_type();
    ::cvmfs::MsgObjectInfoReq* temp = message_type_.msg_object_info_req_;
    message_type_.msg_object_info_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_object_info_req(::cvmfs::MsgObjectInfoReq* msg_object_info_req) {
  clear_message_type();
  if (msg_object_info_req) {
    set_has_msg_object_info_req();
    message_type_.msg_object_info_req_ = msg_object_info_req;
  }
}

// optional .cvmfs.MsgObjectInfoReply msg_object_info_reply = 6;
inline bool MsgRpc::has_msg_object_info_reply() const {
  return message_type_case() == kMsgObjectInfoReply;
}
inline void MsgRpc::set_has_msg_object_info_reply() {
  _oneof_case_[0] = kMsgObjectInfoReply;
}
inline void MsgRpc::clear_msg_object_info_reply() {
  if (has_msg_object_info_reply()) {
    delete message_type_.msg_object_info_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgObjectInfoReply& MsgRpc::msg_object_info_reply() const {
  return has_msg_object_info_reply() ? *message_type_.msg_object_info_reply_
                      : ::cvmfs::MsgObjectInfoReply::default_instance();
}
inline ::cvmfs::MsgObjectInfoReply* MsgRpc::mutable_msg_object_info_reply() {
  if (!has_msg_object_info_reply()) {
    clear_message_type();
    set_has_msg_object_info_reply();
    message_type_.msg_object_info_reply_ = new ::cvmfs::MsgObjectInfoReply;
  }
  return message_type_.msg_object_info_reply_;
}
inline ::cvmfs::MsgObjectInfoReply* MsgRpc::release_msg_object_info_reply() {
  if (has_msg_object_info_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgObjectInfoReply* temp = message_type_.msg_object_info_reply_;
    message_type_.msg_object_info_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_object_info_reply(::cvmfs::MsgObjectInfoReply* msg_object_info_reply) {
  clear_message_type();
  if (msg_object_info_reply) {
    set_has_msg_object_info_reply();
    message_type_.msg_object_info_reply_ = msg_object_info_reply;
  }
}

// optional .cvmfs.MsgStoreReq msg_store_req = 7;
inline bool MsgRpc::has_msg_store_req() const {
  return message_type_case() == kMsgStoreReq;
}
inline void MsgRpc::set_has_msg_store_req() {
  _oneof_case_[0] = kMsgStoreReq;
}
inline void MsgRpc::clear_msg_store_req() {
  if (has_msg_store_req()) {
    delete message_type_.msg_store_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgStoreReq& MsgRpc::msg_store_req() const {
  return has_msg_store_req() ? *message_type_.msg_store_req_
                      : ::cvmfs::MsgStoreReq::default_instance();
}
inline ::cvmfs::MsgStoreReq* MsgRpc::mutable_msg_store_req() {
  if (!has_msg_store_req()) {
    clear_message_type();
    set_has_msg_store_req();
    message_type_.msg_store_req_ = new ::cvmfs::MsgStoreReq;
  }
  return message_type_.msg_store_req_;
}
inline ::cvmfs::MsgStoreReq* MsgRpc::release_msg_store_req() {
  if (has_msg_store_req()) {
    clear_has_message_type();
    ::cvmfs::MsgStoreReq* temp = message_type_.msg_store_req_;
    message_type_.msg_store_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_store_req(::cvmfs::MsgStoreReq* msg_store_req) {
  clear_message_type();
  if (msg_store_req) {
    set_has_msg_store_req();
    message_type_.msg_store_req_ = msg_store_req;
  }
}

// optional .cvmfs.MsgStoreAbortReq msg_store_abort_req = 8;
inline bool MsgRpc::has_msg_store_abort_req() const {
  return message_type_case() == kMsgStoreAbortReq;
}
inline void MsgRpc::set_has_msg_store_abort_req() {
  _oneof_case_[0] = kMsgStoreAbortReq;
}
inline void MsgRpc::clear_msg_store_abort_req() {
  if (has_msg_store_abort_req()) {
    delete message_type_.msg_store_abort_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgStoreAbortReq& MsgRpc::msg_store_abort_req() const {
  return has_msg_store_abort_req() ? *message_type_.msg_store_abort_req_
                      : ::cvmfs::MsgStoreAbortReq::default_instance();
}
inline ::cvmfs::MsgStoreAbortReq* MsgRpc::mutable_msg_store_abort_req() {
  if (!has_msg_store_abort_req()) {
    clear_message_type();
    set_has_msg_store_abort_req();
    message_type_.msg_store_abort_req_ = new ::cvmfs::MsgStoreAbortReq;
  }
  return message_type_.msg_store_abort_req_;
}
inline ::cvmfs::MsgStoreAbortReq* MsgRpc::release_msg_store_abort_req() {
  if (has_msg_store_abort_req()) {
    clear_has_message_type();
    ::cvmfs::MsgStoreAbortReq* temp = message_type_.msg_store_abort_req_;
    message_type_.msg_store_abort_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_store_abort_req(::cvmfs::MsgStoreAbortReq* msg_store_abort_req) {
  clear_message_type();
  if (msg_store_abort_req) {
    set_has_msg_store_abort_req();
    message_type_.msg_store_abort_req_ = msg_store_abort_req;
  }
}

// optional .cvmfs.MsgStoreReply msg_store_reply = 9;
inline bool MsgRpc::has_msg_store_reply() const {
  return message_type_case() == kMsgStoreReply;
}
inline void MsgRpc::set_has_msg_store_reply() {
  _oneof_case_[0] = kMsgStoreReply;
}
inline void MsgRpc::clear_msg_store_reply() {
  if (has_msg_store_reply()) {
    delete message_type_.msg_store_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgStoreReply& MsgRpc::msg_store_reply() const {
  return has_msg_store_reply() ? *message_type_.msg_store_reply_
                      : ::cvmfs::MsgStoreReply::default_instance();
}
inline ::cvmfs::MsgStoreReply* MsgRpc::mutable_msg_store_reply() {
  if (!has_msg_store_reply()) {
    clear_message_type();
    set_has_msg_store_reply();
    message_type_.msg_store_reply_ = new ::cvmfs::MsgStoreReply;
  }
  return message_type_.msg_store_reply_;
}
inline ::cvmfs::MsgStoreReply* MsgRpc::release_msg_store_reply() {
  if (has_msg_store_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgStoreReply* temp = message_type_.msg_store_reply_;
    message_type_.msg_store_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_store_reply(::cvmfs::MsgStoreReply* msg_store_reply) {
  clear_message_type();
  if (msg_store_reply) {
    set_has_msg_store_reply();
    message_type_.msg_store_reply_ = msg_store_reply;
  }
}

// optional .cvmfs.MsgHandshake msg_handshake = 16;
inline bool MsgRpc::has_msg_handshake() const {
  return message_type_case() == kMsgHandshake;
}
inline void MsgRpc::set_has_msg_handshake() {
  _oneof_case_[0] = kMsgHandshake;
}
inline void MsgRpc::clear_msg_handshake() {
  if (has_msg_handshake()) {
    delete message_type_.msg_handshake_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgHandshake& MsgRpc::msg_handshake() const {
  return has_msg_handshake() ? *message_type_.msg_handshake_
                      : ::cvmfs::MsgHandshake::default_instance();
}
inline ::cvmfs::MsgHandshake* MsgRpc::mutable_msg_handshake() {
  if (!has_msg_handshake()) {
    clear_message_type();
    set_has_msg_handshake();
    message_type_.msg_handshake_ = new ::cvmfs::MsgHandshake;
  }
  return message_type_.msg_handshake_;
}
inline ::cvmfs::MsgHandshake* MsgRpc::release_msg_handshake() {
  if (has_msg_handshake()) {
    clear_has_message_type();
    ::cvmfs::MsgHandshake* temp = message_type_.msg_handshake_;
    message_type_.msg_handshake_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_handshake(::cvmfs::MsgHandshake* msg_handshake) {
  clear_message_type();
  if (msg_handshake) {
    set_has_msg_handshake();
    message_type_.msg_handshake_ = msg_handshake;
  }
}

// optional .cvmfs.MsgHandshakeAck msg_handshake_ack = 17;
inline bool MsgRpc::has_msg_handshake_ack() const {
  return message_type_case() == kMsgHandshakeAck;
}
inline void MsgRpc::set_has_msg_handshake_ack() {
  _oneof_case_[0] = kMsgHandshakeAck;
}
inline void MsgRpc::clear_msg_handshake_ack() {
  if (has_msg_handshake_ack()) {
    delete message_type_.msg_handshake_ack_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgHandshakeAck& MsgRpc::msg_handshake_ack() const {
  return has_msg_handshake_ack() ? *message_type_.msg_handshake_ack_
                      : ::cvmfs::MsgHandshakeAck::default_instance();
}
inline ::cvmfs::MsgHandshakeAck* MsgRpc::mutable_msg_handshake_ack() {
  if (!has_msg_handshake_ack()) {
    clear_message_type();
    set_has_msg_handshake_ack();
    message_type_.msg_handshake_ack_ = new ::cvmfs::MsgHandshakeAck;
  }
  return message_type_.msg_handshake_ack_;
}
inline ::cvmfs::MsgHandshakeAck* MsgRpc::release_msg_handshake_ack() {
  if (has_msg_handshake_ack()) {
    clear_has_message_type();
    ::cvmfs::MsgHandshakeAck* temp = message_type_.msg_handshake_ack_;
    message_type_.msg_handshake_ack_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_handshake_ack(::cvmfs::MsgHandshakeAck* msg_handshake_ack) {
  clear_message_type();
  if (msg_handshake_ack) {
    set_has_msg_handshake_ack();
    message_type_.msg_handshake_ack_ = msg_handshake_ack;
  }
}

// optional .cvmfs.MsgQuit msg_quit = 18;
inline bool MsgRpc::has_msg_quit() const {
  return message_type_case() == kMsgQuit;
}
inline void MsgRpc::set_has_msg_quit() {
  _oneof_case_[0] = kMsgQuit;
}
inline void MsgRpc::clear_msg_quit() {
  if (has_msg_quit()) {
    delete message_type_.msg_quit_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgQuit& MsgRpc::msg_quit() const {
  return has_msg_quit() ? *message_type_.msg_quit_
                      : ::cvmfs::MsgQuit::default_instance();
}
inline ::cvmfs::MsgQuit* MsgRpc::mutable_msg_quit() {
  if (!has_msg_quit()) {
    clear_message_type();
    set_has_msg_quit();
    message_type_.msg_quit_ = new ::cvmfs::MsgQuit;
  }
  return message_type_.msg_quit_;
}
inline ::cvmfs::MsgQuit* MsgRpc::release_msg_quit() {
  if (has_msg_quit()) {
    clear_has_message_type();
    ::cvmfs::MsgQuit* temp = message_type_.msg_quit_;
    message_type_.msg_quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_quit(::cvmfs::MsgQuit* msg_quit) {
  clear_message_type();
  if (msg_quit) {
    set_has_msg_quit();
    message_type_.msg_quit_ = msg_quit;
  }
}

// optional .cvmfs.MsgInfoReq msg_info_req = 19;
inline bool MsgRpc::has_msg_info_req() const {
  return message_type_case() == kMsgInfoReq;
}
inline void MsgRpc::set_has_msg_info_req() {
  _oneof_case_[0] = kMsgInfoReq;
}
inline void MsgRpc::clear_msg_info_req() {
  if (has_msg_info_req()) {
    delete message_type_.msg_info_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgInfoReq& MsgRpc::msg_info_req() const {
  return has_msg_info_req() ? *message_type_.msg_info_req_
                      : ::cvmfs::MsgInfoReq::default_instance();
}
inline ::cvmfs::MsgInfoReq* MsgRpc::mutable_msg_info_req() {
  if (!has_msg_info_req()) {
    clear_message_type();
    set_has_msg_info_req();
    message_type_.msg_info_req_ = new ::cvmfs::MsgInfoReq;
  }
  return message_type_.msg_info_req_;
}
inline ::cvmfs::MsgInfoReq* MsgRpc::release_msg_info_req() {
  if (has_msg_info_req()) {
    clear_has_message_type();
    ::cvmfs::MsgInfoReq* temp = message_type_.msg_info_req_;
    message_type_.msg_info_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_info_req(::cvmfs::MsgInfoReq* msg_info_req) {
  clear_message_type();
  if (msg_info_req) {
    set_has_msg_info_req();
    message_type_.msg_info_req_ = msg_info_req;
  }
}

// optional .cvmfs.MsgInfoReply msg_info_reply = 20;
inline bool MsgRpc::has_msg_info_reply() const {
  return message_type_case() == kMsgInfoReply;
}
inline void MsgRpc::set_has_msg_info_reply() {
  _oneof_case_[0] = kMsgInfoReply;
}
inline void MsgRpc::clear_msg_info_reply() {
  if (has_msg_info_reply()) {
    delete message_type_.msg_info_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgInfoReply& MsgRpc::msg_info_reply() const {
  return has_msg_info_reply() ? *message_type_.msg_info_reply_
                      : ::cvmfs::MsgInfoReply::default_instance();
}
inline ::cvmfs::MsgInfoReply* MsgRpc::mutable_msg_info_reply() {
  if (!has_msg_info_reply()) {
    clear_message_type();
    set_has_msg_info_reply();
    message_type_.msg_info_reply_ = new ::cvmfs::MsgInfoReply;
  }
  return message_type_.msg_info_reply_;
}
inline ::cvmfs::MsgInfoReply* MsgRpc::release_msg_info_reply() {
  if (has_msg_info_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgInfoReply* temp = message_type_.msg_info_reply_;
    message_type_.msg_info_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_info_reply(::cvmfs::MsgInfoReply* msg_info_reply) {
  clear_message_type();
  if (msg_info_reply) {
    set_has_msg_info_reply();
    message_type_.msg_info_reply_ = msg_info_reply;
  }
}

// optional .cvmfs.MsgShrinkReq msg_shrink_req = 21;
inline bool MsgRpc::has_msg_shrink_req() const {
  return message_type_case() == kMsgShrinkReq;
}
inline void MsgRpc::set_has_msg_shrink_req() {
  _oneof_case_[0] = kMsgShrinkReq;
}
inline void MsgRpc::clear_msg_shrink_req() {
  if (has_msg_shrink_req()) {
    delete message_type_.msg_shrink_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgShrinkReq& MsgRpc::msg_shrink_req() const {
  return has_msg_shrink_req() ? *message_type_.msg_shrink_req_
                      : ::cvmfs::MsgShrinkReq::default_instance();
}
inline ::cvmfs::MsgShrinkReq* MsgRpc::mutable_msg_shrink_req() {
  if (!has_msg_shrink_req()) {
    clear_message_type();
    set_has_msg_shrink_req();
    message_type_.msg_shrink_req_ = new ::cvmfs::MsgShrinkReq;
  }
  return message_type_.msg_shrink_req_;
}
inline ::cvmfs::MsgShrinkReq* MsgRpc::release_msg_shrink_req() {
  if (has_msg_shrink_req()) {
    clear_has_message_type();
    ::cvmfs::MsgShrinkReq* temp = message_type_.msg_shrink_req_;
    message_type_.msg_shrink_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_shrink_req(::cvmfs::MsgShrinkReq* msg_shrink_req) {
  clear_message_type();
  if (msg_shrink_req) {
    set_has_msg_shrink_req();
    message_type_.msg_shrink_req_ = msg_shrink_req;
  }
}

// optional .cvmfs.MsgShrinkReply msg_shrink_reply = 22;
inline bool MsgRpc::has_msg_shrink_reply() const {
  return message_type_case() == kMsgShrinkReply;
}
inline void MsgRpc::set_has_msg_shrink_reply() {
  _oneof_case_[0] = kMsgShrinkReply;
}
inline void MsgRpc::clear_msg_shrink_reply() {
  if (has_msg_shrink_reply()) {
    delete message_type_.msg_shrink_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgShrinkReply& MsgRpc::msg_shrink_reply() const {
  return has_msg_shrink_reply() ? *message_type_.msg_shrink_reply_
                      : ::cvmfs::MsgShrinkReply::default_instance();
}
inline ::cvmfs::MsgShrinkReply* MsgRpc::mutable_msg_shrink_reply() {
  if (!has_msg_shrink_reply()) {
    clear_message_type();
    set_has_msg_shrink_reply();
    message_type_.msg_shrink_reply_ = new ::cvmfs::MsgShrinkReply;
  }
  return message_type_.msg_shrink_reply_;
}
inline ::cvmfs::MsgShrinkReply* MsgRpc::release_msg_shrink_reply() {
  if (has_msg_shrink_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgShrinkReply* temp = message_type_.msg_shrink_reply_;
    message_type_.msg_shrink_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_shrink_reply(::cvmfs::MsgShrinkReply* msg_shrink_reply) {
  clear_message_type();
  if (msg_shrink_reply) {
    set_has_msg_shrink_reply();
    message_type_.msg_shrink_reply_ = msg_shrink_reply;
  }
}

// optional .cvmfs.MsgListReq msg_list_req = 23;
inline bool MsgRpc::has_msg_list_req() const {
  return message_type_case() == kMsgListReq;
}
inline void MsgRpc::set_has_msg_list_req() {
  _oneof_case_[0] = kMsgListReq;
}
inline void MsgRpc::clear_msg_list_req() {
  if (has_msg_list_req()) {
    delete message_type_.msg_list_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgListReq& MsgRpc::msg_list_req() const {
  return has_msg_list_req() ? *message_type_.msg_list_req_
                      : ::cvmfs::MsgListReq::default_instance();
}
inline ::cvmfs::MsgListReq* MsgRpc::mutable_msg_list_req() {
  if (!has_msg_list_req()) {
    clear_message_type();
    set_has_msg_list_req();
    message_type_.msg_list_req_ = new ::cvmfs::MsgListReq;
  }
  return message_type_.msg_list_req_;
}
inline ::cvmfs::MsgListReq* MsgRpc::release_msg_list_req() {
  if (has_msg_list_req()) {
    clear_has_message_type();
    ::cvmfs::MsgListReq* temp = message_type_.msg_list_req_;
    message_type_.msg_list_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_list_req(::cvmfs::MsgListReq* msg_list_req) {
  clear_message_type();
  if (msg_list_req) {
    set_has_msg_list_req();
    message_type_.msg_list_req_ = msg_list_req;
  }
}

// optional .cvmfs.MsgListReply msg_list_reply = 24;
inline bool MsgRpc::has_msg_list_reply() const {
  return message_type_case() == kMsgListReply;
}
inline void MsgRpc::set_has_msg_list_reply() {
  _oneof_case_[0] = kMsgListReply;
}
inline void MsgRpc::clear_msg_list_reply() {
  if (has_msg_list_reply()) {
    delete message_type_.msg_list_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgListReply& MsgRpc::msg_list_reply() const {
  return has_msg_list_reply() ? *message_type_.msg_list_reply_
                      : ::cvmfs::MsgListReply::default_instance();
}
inline ::cvmfs::MsgListReply* MsgRpc::mutable_msg_list_reply() {
  if (!has_msg_list_reply()) {
    clear_message_type();
    set_has_msg_list_reply();
    message_type_.msg_list_reply_ = new ::cvmfs::MsgListReply;
  }
  return message_type_.msg_list_reply_;
}
inline ::cvmfs::MsgListReply* MsgRpc::release_msg_list_reply() {
  if (has_msg_list_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgListReply* temp = message_type_.msg_list_reply_;
    message_type_.msg_list_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_list_reply(::cvmfs::MsgListReply* msg_list_reply) {
  clear_message_type();
  if (msg_list_reply) {
    set_has_msg_list_reply();
    message_type_.msg_list_reply_ = msg_list_reply;
  }
}

// optional .cvmfs.MsgDetach msg_detach = 25;
inline bool MsgRpc::has_msg_detach() const {
  return message_type_case() == kMsgDetach;
}
inline void MsgRpc::set_has_msg_detach() {
  _oneof_case_[0] = kMsgDetach;
}
inline void MsgRpc::clear_msg_detach() {
  if (has_msg_detach()) {
    delete message_type_.msg_detach_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgDetach& MsgRpc::msg_detach() const {
  return has_msg_detach() ? *message_type_.msg_detach_
                      : ::cvmfs::MsgDetach::default_instance();
}
inline ::cvmfs::MsgDetach* MsgRpc::mutable_msg_detach() {
  if (!has_msg_detach()) {
    clear_message_type();
    set_has_msg_detach();
    message_type_.msg_detach_ = new ::cvmfs::MsgDetach;
  }
  return message_type_.msg_detach_;
}
inline ::cvmfs::MsgDetach* MsgRpc::release_msg_detach() {
  if (has_msg_detach()) {
    clear_has_message_type();
    ::cvmfs::MsgDetach* temp = message_type_.msg_detach_;
    message_type_.msg_detach_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_detach(::cvmfs::MsgDetach* msg_detach) {
  clear_message_type();
  if (msg_detach) {
    set_has_msg_detach();
    message_type_.msg_detach_ = msg_detach;
  }
}

// optional .cvmfs.MsgIoctl msg_ioctl = 26;
inline bool MsgRpc::has_msg_ioctl() const {
  return message_type_case() == kMsgIoctl;
}
inline void MsgRpc::set_has_msg_ioctl() {
  _oneof_case_[0] = kMsgIoctl;
}
inline void MsgRpc::clear_msg_ioctl() {
  if (has_msg_ioctl()) {
    delete message_type_.msg_ioctl_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgIoctl& MsgRpc::msg_ioctl() const {
  return has_msg_ioctl() ? *message_type_.msg_ioctl_
                      : ::cvmfs::MsgIoctl::default_instance();
}
inline ::cvmfs::MsgIoctl* MsgRpc::mutable_msg_ioctl() {
  if (!has_msg_ioctl()) {
    clear_message_type();
    set_has_msg_ioctl();
    message_type_.msg_ioctl_ = new ::cvmfs::MsgIoctl;
  }
  return message_type_.msg_ioctl_;
}
inline ::cvmfs::MsgIoctl* MsgRpc::release_msg_ioctl() {
  if (has_msg_ioctl()) {
    clear_has_message_type();
    ::cvmfs::MsgIoctl* temp = message_type_.msg_ioctl_;
    message_type_.msg_ioctl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_ioctl(::cvmfs::MsgIoctl* msg_ioctl) {
  clear_message_type();
  if (msg_ioctl) {
    set_has_msg_ioctl();
    message_type_.msg_ioctl_ = msg_ioctl;
  }
}

// optional .cvmfs.MsgBreadcrumbStoreReq msg_breadcrumb_store_req = 27;
inline bool MsgRpc::has_msg_breadcrumb_store_req() const {
  return message_type_case() == kMsgBreadcrumbStoreReq;
}
inline void MsgRpc::set_has_msg_breadcrumb_store_req() {
  _oneof_case_[0] = kMsgBreadcrumbStoreReq;
}
inline void MsgRpc::clear_msg_breadcrumb_store_req() {
  if (has_msg_breadcrumb_store_req()) {
    delete message_type_.msg_breadcrumb_store_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgBreadcrumbStoreReq& MsgRpc::msg_breadcrumb_store_req() const {
  return has_msg_breadcrumb_store_req() ? *message_type_.msg_breadcrumb_store_req_
                      : ::cvmfs::MsgBreadcrumbStoreReq::default_instance();
}
inline ::cvmfs::MsgBreadcrumbStoreReq* MsgRpc::mutable_msg_breadcrumb_store_req() {
  if (!has_msg_breadcrumb_store_req()) {
    clear_message_type();
    set_has_msg_breadcrumb_store_req();
    message_type_.msg_breadcrumb_store_req_ = new ::cvmfs::MsgBreadcrumbStoreReq;
  }
  return message_type_.msg_breadcrumb_store_req_;
}
inline ::cvmfs::MsgBreadcrumbStoreReq* MsgRpc::release_msg_breadcrumb_store_req() {
  if (has_msg_breadcrumb_store_req()) {
    clear_has_message_type();
    ::cvmfs::MsgBreadcrumbStoreReq* temp = message_type_.msg_breadcrumb_store_req_;
    message_type_.msg_breadcrumb_store_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_breadcrumb_store_req(::cvmfs::MsgBreadcrumbStoreReq* msg_breadcrumb_store_req) {
  clear_message_type();
  if (msg_breadcrumb_store_req) {
    set_has_msg_breadcrumb_store_req();
    message_type_.msg_breadcrumb_store_req_ = msg_breadcrumb_store_req;
  }
}

// optional .cvmfs.MsgBreadcrumbLoadReq msg_breadcrumb_load_req = 28;
inline bool MsgRpc::has_msg_breadcrumb_load_req() const {
  return message_type_case() == kMsgBreadcrumbLoadReq;
}
inline void MsgRpc::set_has_msg_breadcrumb_load_req() {
  _oneof_case_[0] = kMsgBreadcrumbLoadReq;
}
inline void MsgRpc::clear_msg_breadcrumb_load_req() {
  if (has_msg_breadcrumb_load_req()) {
    delete message_type_.msg_breadcrumb_load_req_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgBreadcrumbLoadReq& MsgRpc::msg_breadcrumb_load_req() const {
  return has_msg_breadcrumb_load_req() ? *message_type_.msg_breadcrumb_load_req_
                      : ::cvmfs::MsgBreadcrumbLoadReq::default_instance();
}
inline ::cvmfs::MsgBreadcrumbLoadReq* MsgRpc::mutable_msg_breadcrumb_load_req() {
  if (!has_msg_breadcrumb_load_req()) {
    clear_message_type();
    set_has_msg_breadcrumb_load_req();
    message_type_.msg_breadcrumb_load_req_ = new ::cvmfs::MsgBreadcrumbLoadReq;
  }
  return message_type_.msg_breadcrumb_load_req_;
}
inline ::cvmfs::MsgBreadcrumbLoadReq* MsgRpc::release_msg_breadcrumb_load_req() {
  if (has_msg_breadcrumb_load_req()) {
    clear_has_message_type();
    ::cvmfs::MsgBreadcrumbLoadReq* temp = message_type_.msg_breadcrumb_load_req_;
    message_type_.msg_breadcrumb_load_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_breadcrumb_load_req(::cvmfs::MsgBreadcrumbLoadReq* msg_breadcrumb_load_req) {
  clear_message_type();
  if (msg_breadcrumb_load_req) {
    set_has_msg_breadcrumb_load_req();
    message_type_.msg_breadcrumb_load_req_ = msg_breadcrumb_load_req;
  }
}

// optional .cvmfs.MsgBreadcrumbReply msg_breadcrumb_reply = 29;
inline bool MsgRpc::has_msg_breadcrumb_reply() const {
  return message_type_case() == kMsgBreadcrumbReply;
}
inline void MsgRpc::set_has_msg_breadcrumb_reply() {
  _oneof_case_[0] = kMsgBreadcrumbReply;
}
inline void MsgRpc::clear_msg_breadcrumb_reply() {
  if (has_msg_breadcrumb_reply()) {
    delete message_type_.msg_breadcrumb_reply_;
    clear_has_message_type();
  }
}
inline const ::cvmfs::MsgBreadcrumbReply& MsgRpc::msg_breadcrumb_reply() const {
  return has_msg_breadcrumb_reply() ? *message_type_.msg_breadcrumb_reply_
                      : ::cvmfs::MsgBreadcrumbReply::default_instance();
}
inline ::cvmfs::MsgBreadcrumbReply* MsgRpc::mutable_msg_breadcrumb_reply() {
  if (!has_msg_breadcrumb_reply()) {
    clear_message_type();
    set_has_msg_breadcrumb_reply();
    message_type_.msg_breadcrumb_reply_ = new ::cvmfs::MsgBreadcrumbReply;
  }
  return message_type_.msg_breadcrumb_reply_;
}
inline ::cvmfs::MsgBreadcrumbReply* MsgRpc::release_msg_breadcrumb_reply() {
  if (has_msg_breadcrumb_reply()) {
    clear_has_message_type();
    ::cvmfs::MsgBreadcrumbReply* temp = message_type_.msg_breadcrumb_reply_;
    message_type_.msg_breadcrumb_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MsgRpc::set_allocated_msg_breadcrumb_reply(::cvmfs::MsgBreadcrumbReply* msg_breadcrumb_reply) {
  clear_message_type();
  if (msg_breadcrumb_reply) {
    set_has_msg_breadcrumb_reply();
    message_type_.msg_breadcrumb_reply_ = msg_breadcrumb_reply;
  }
}

inline bool MsgRpc::has_message_type() {
  return message_type_case() != MESSAGE_TYPE_NOT_SET;
}
inline void MsgRpc::clear_has_message_type() {
  _oneof_case_[0] = MESSAGE_TYPE_NOT_SET;
}
inline MsgRpc::MessageTypeCase MsgRpc::message_type_case() const {
  return MsgRpc::MessageTypeCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace cvmfs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cache_2eproto__INCLUDED
