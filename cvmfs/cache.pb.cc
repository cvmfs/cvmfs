// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cache.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cache.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace cvmfs {

void protobuf_ShutdownFile_cache_2eproto() {
  delete MsgHash::default_instance_;
  delete MsgListRecord::default_instance_;
  delete MsgBreadcrumb::default_instance_;
  delete MsgHandshake::default_instance_;
  delete MsgHandshakeAck::default_instance_;
  delete MsgQuit::default_instance_;
  delete MsgIoctl::default_instance_;
  delete MsgStoreReq::default_instance_;
  delete MsgStoreAbortReq::default_instance_;
  delete MsgStoreReply::default_instance_;
  delete MsgRefcountReq::default_instance_;
  delete MsgRefcountReply::default_instance_;
  delete MsgDetach::default_instance_;
  delete MsgShrinkReq::default_instance_;
  delete MsgShrinkReply::default_instance_;
  delete MsgReadReq::default_instance_;
  delete MsgReadReply::default_instance_;
  delete MsgInfoReq::default_instance_;
  delete MsgInfoReply::default_instance_;
  delete MsgObjectInfoReq::default_instance_;
  delete MsgObjectInfoReply::default_instance_;
  delete MsgListReq::default_instance_;
  delete MsgListReply::default_instance_;
  delete MsgBreadcrumbStoreReq::default_instance_;
  delete MsgBreadcrumbLoadReq::default_instance_;
  delete MsgBreadcrumbReply::default_instance_;
  delete MsgRpc::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_cache_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_cache_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  MsgHash::default_instance_ = new MsgHash();
  MsgListRecord::default_instance_ = new MsgListRecord();
  MsgBreadcrumb::default_instance_ = new MsgBreadcrumb();
  MsgHandshake::default_instance_ = new MsgHandshake();
  MsgHandshakeAck::default_instance_ = new MsgHandshakeAck();
  MsgQuit::default_instance_ = new MsgQuit();
  MsgIoctl::default_instance_ = new MsgIoctl();
  MsgStoreReq::default_instance_ = new MsgStoreReq();
  MsgStoreAbortReq::default_instance_ = new MsgStoreAbortReq();
  MsgStoreReply::default_instance_ = new MsgStoreReply();
  MsgRefcountReq::default_instance_ = new MsgRefcountReq();
  MsgRefcountReply::default_instance_ = new MsgRefcountReply();
  MsgDetach::default_instance_ = new MsgDetach();
  MsgShrinkReq::default_instance_ = new MsgShrinkReq();
  MsgShrinkReply::default_instance_ = new MsgShrinkReply();
  MsgReadReq::default_instance_ = new MsgReadReq();
  MsgReadReply::default_instance_ = new MsgReadReply();
  MsgInfoReq::default_instance_ = new MsgInfoReq();
  MsgInfoReply::default_instance_ = new MsgInfoReply();
  MsgObjectInfoReq::default_instance_ = new MsgObjectInfoReq();
  MsgObjectInfoReply::default_instance_ = new MsgObjectInfoReply();
  MsgListReq::default_instance_ = new MsgListReq();
  MsgListReply::default_instance_ = new MsgListReply();
  MsgBreadcrumbStoreReq::default_instance_ = new MsgBreadcrumbStoreReq();
  MsgBreadcrumbLoadReq::default_instance_ = new MsgBreadcrumbLoadReq();
  MsgBreadcrumbReply::default_instance_ = new MsgBreadcrumbReply();
  MsgRpc::default_instance_ = new MsgRpc();
  MsgHash::default_instance_->InitAsDefaultInstance();
  MsgListRecord::default_instance_->InitAsDefaultInstance();
  MsgBreadcrumb::default_instance_->InitAsDefaultInstance();
  MsgHandshake::default_instance_->InitAsDefaultInstance();
  MsgHandshakeAck::default_instance_->InitAsDefaultInstance();
  MsgQuit::default_instance_->InitAsDefaultInstance();
  MsgIoctl::default_instance_->InitAsDefaultInstance();
  MsgStoreReq::default_instance_->InitAsDefaultInstance();
  MsgStoreAbortReq::default_instance_->InitAsDefaultInstance();
  MsgStoreReply::default_instance_->InitAsDefaultInstance();
  MsgRefcountReq::default_instance_->InitAsDefaultInstance();
  MsgRefcountReply::default_instance_->InitAsDefaultInstance();
  MsgDetach::default_instance_->InitAsDefaultInstance();
  MsgShrinkReq::default_instance_->InitAsDefaultInstance();
  MsgShrinkReply::default_instance_->InitAsDefaultInstance();
  MsgReadReq::default_instance_->InitAsDefaultInstance();
  MsgReadReply::default_instance_->InitAsDefaultInstance();
  MsgInfoReq::default_instance_->InitAsDefaultInstance();
  MsgInfoReply::default_instance_->InitAsDefaultInstance();
  MsgObjectInfoReq::default_instance_->InitAsDefaultInstance();
  MsgObjectInfoReply::default_instance_->InitAsDefaultInstance();
  MsgListReq::default_instance_->InitAsDefaultInstance();
  MsgListReply::default_instance_->InitAsDefaultInstance();
  MsgBreadcrumbStoreReq::default_instance_->InitAsDefaultInstance();
  MsgBreadcrumbLoadReq::default_instance_->InitAsDefaultInstance();
  MsgBreadcrumbReply::default_instance_->InitAsDefaultInstance();
  MsgRpc::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cache_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_cache_2eproto_once_);
void protobuf_AddDesc_cache_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_cache_2eproto_once_,
                 &protobuf_AddDesc_cache_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cache_2eproto {
  StaticDescriptorInitializer_cache_2eproto() {
    protobuf_AddDesc_cache_2eproto();
  }
} static_descriptor_initializer_cache_2eproto_;
#endif
bool EnumStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

bool EnumHashAlgorithm_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool EnumObjectType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool EnumCapabilities_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 63:
    case 64:
    case 127:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MsgHash::kAlgorithmFieldNumber;
const int MsgHash::kDigestFieldNumber;
#endif  // !_MSC_VER

MsgHash::MsgHash()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgHash)
}

void MsgHash::InitAsDefaultInstance() {
}

MsgHash::MsgHash(const MsgHash& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgHash)
}

void MsgHash::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  algorithm_ = 0;
  digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgHash::~MsgHash() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgHash)
  SharedDtor();
}

void MsgHash::SharedDtor() {
  if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete digest_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgHash::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgHash& MsgHash::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgHash* MsgHash::default_instance_ = NULL;

MsgHash* MsgHash::New() const {
  return new MsgHash;
}

void MsgHash::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    algorithm_ = 0;
    if (has_digest()) {
      if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        digest_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgHash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgHash)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cvmfs.EnumHashAlgorithm algorithm = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumHashAlgorithm_IsValid(value)) {
            set_algorithm(static_cast< ::cvmfs::EnumHashAlgorithm >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_digest;
        break;
      }

      // required bytes digest = 2;
      case 2: {
        if (tag == 18) {
         parse_digest:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_digest()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgHash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgHash)
  return false;
#undef DO_
}

void MsgHash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgHash)
  // required .cvmfs.EnumHashAlgorithm algorithm = 1;
  if (has_algorithm()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->algorithm(), output);
  }

  // required bytes digest = 2;
  if (has_digest()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->digest(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgHash)
}

int MsgHash::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cvmfs.EnumHashAlgorithm algorithm = 1;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->algorithm());
    }

    // required bytes digest = 2;
    if (has_digest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->digest());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgHash::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgHash*>(&from));
}

void MsgHash::MergeFrom(const MsgHash& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_algorithm()) {
      set_algorithm(from.algorithm());
    }
    if (from.has_digest()) {
      set_digest(from.digest());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgHash::CopyFrom(const MsgHash& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgHash::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MsgHash::Swap(MsgHash* other) {
  if (other != this) {
    std::swap(algorithm_, other->algorithm_);
    std::swap(digest_, other->digest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgHash::GetTypeName() const {
  return "cvmfs.MsgHash";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgListRecord::kHashFieldNumber;
const int MsgListRecord::kPinnedFieldNumber;
const int MsgListRecord::kDescriptionFieldNumber;
#endif  // !_MSC_VER

MsgListRecord::MsgListRecord()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgListRecord)
}

void MsgListRecord::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  hash_ = const_cast< ::cvmfs::MsgHash*>(
      ::cvmfs::MsgHash::internal_default_instance());
#else
  hash_ = const_cast< ::cvmfs::MsgHash*>(&::cvmfs::MsgHash::default_instance());
#endif
}

MsgListRecord::MsgListRecord(const MsgListRecord& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgListRecord)
}

void MsgListRecord::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hash_ = NULL;
  pinned_ = false;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgListRecord::~MsgListRecord() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgListRecord)
  SharedDtor();
}

void MsgListRecord::SharedDtor() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete hash_;
  }
}

void MsgListRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgListRecord& MsgListRecord::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgListRecord* MsgListRecord::default_instance_ = NULL;

MsgListRecord* MsgListRecord::New() const {
  return new MsgListRecord;
}

void MsgListRecord::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_hash()) {
      if (hash_ != NULL) hash_->::cvmfs::MsgHash::Clear();
    }
    pinned_ = false;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        description_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgListRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgListRecord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cvmfs.MsgHash hash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pinned;
        break;
      }

      // optional bool pinned = 2;
      case 2: {
        if (tag == 16) {
         parse_pinned:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pinned_)));
          set_has_pinned();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_description;
        break;
      }

      // optional string description = 3;
      case 3: {
        if (tag == 26) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgListRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgListRecord)
  return false;
#undef DO_
}

void MsgListRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgListRecord)
  // required .cvmfs.MsgHash hash = 1;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->hash(), output);
  }

  // optional bool pinned = 2;
  if (has_pinned()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->pinned(), output);
  }

  // optional string description = 3;
  if (has_description()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->description(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgListRecord)
}

int MsgListRecord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cvmfs.MsgHash hash = 1;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hash());
    }

    // optional bool pinned = 2;
    if (has_pinned()) {
      total_size += 1 + 1;
    }

    // optional string description = 3;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgListRecord::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgListRecord*>(&from));
}

void MsgListRecord::MergeFrom(const MsgListRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hash()) {
      mutable_hash()->::cvmfs::MsgHash::MergeFrom(from.hash());
    }
    if (from.has_pinned()) {
      set_pinned(from.pinned());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgListRecord::CopyFrom(const MsgListRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgListRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_hash()) {
    if (!this->hash().IsInitialized()) return false;
  }
  return true;
}

void MsgListRecord::Swap(MsgListRecord* other) {
  if (other != this) {
    std::swap(hash_, other->hash_);
    std::swap(pinned_, other->pinned_);
    std::swap(description_, other->description_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgListRecord::GetTypeName() const {
  return "cvmfs.MsgListRecord";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgBreadcrumb::kFqrnFieldNumber;
const int MsgBreadcrumb::kHashFieldNumber;
const int MsgBreadcrumb::kTimestampFieldNumber;
#endif  // !_MSC_VER

MsgBreadcrumb::MsgBreadcrumb()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgBreadcrumb)
}

void MsgBreadcrumb::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  hash_ = const_cast< ::cvmfs::MsgHash*>(
      ::cvmfs::MsgHash::internal_default_instance());
#else
  hash_ = const_cast< ::cvmfs::MsgHash*>(&::cvmfs::MsgHash::default_instance());
#endif
}

MsgBreadcrumb::MsgBreadcrumb(const MsgBreadcrumb& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgBreadcrumb)
}

void MsgBreadcrumb::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  fqrn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hash_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgBreadcrumb::~MsgBreadcrumb() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgBreadcrumb)
  SharedDtor();
}

void MsgBreadcrumb::SharedDtor() {
  if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fqrn_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete hash_;
  }
}

void MsgBreadcrumb::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgBreadcrumb& MsgBreadcrumb::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgBreadcrumb* MsgBreadcrumb::default_instance_ = NULL;

MsgBreadcrumb* MsgBreadcrumb::New() const {
  return new MsgBreadcrumb;
}

void MsgBreadcrumb::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_fqrn()) {
      if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        fqrn_->clear();
      }
    }
    if (has_hash()) {
      if (hash_ != NULL) hash_->::cvmfs::MsgHash::Clear();
    }
    timestamp_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgBreadcrumb::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgBreadcrumb)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string fqrn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fqrn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_hash;
        break;
      }

      // required .cvmfs.MsgHash hash = 2;
      case 2: {
        if (tag == 18) {
         parse_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_timestamp;
        break;
      }

      // required uint64 timestamp = 3;
      case 3: {
        if (tag == 24) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgBreadcrumb)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgBreadcrumb)
  return false;
#undef DO_
}

void MsgBreadcrumb::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgBreadcrumb)
  // required string fqrn = 1;
  if (has_fqrn()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->fqrn(), output);
  }

  // required .cvmfs.MsgHash hash = 2;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->hash(), output);
  }

  // required uint64 timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->timestamp(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgBreadcrumb)
}

int MsgBreadcrumb::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string fqrn = 1;
    if (has_fqrn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fqrn());
    }

    // required .cvmfs.MsgHash hash = 2;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hash());
    }

    // required uint64 timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgBreadcrumb::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgBreadcrumb*>(&from));
}

void MsgBreadcrumb::MergeFrom(const MsgBreadcrumb& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fqrn()) {
      set_fqrn(from.fqrn());
    }
    if (from.has_hash()) {
      mutable_hash()->::cvmfs::MsgHash::MergeFrom(from.hash());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgBreadcrumb::CopyFrom(const MsgBreadcrumb& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgBreadcrumb::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_hash()) {
    if (!this->hash().IsInitialized()) return false;
  }
  return true;
}

void MsgBreadcrumb::Swap(MsgBreadcrumb* other) {
  if (other != this) {
    std::swap(fqrn_, other->fqrn_);
    std::swap(hash_, other->hash_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgBreadcrumb::GetTypeName() const {
  return "cvmfs.MsgBreadcrumb";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgHandshake::kProtocolVersionFieldNumber;
const int MsgHandshake::kNameFieldNumber;
const int MsgHandshake::kFlagsFieldNumber;
#endif  // !_MSC_VER

MsgHandshake::MsgHandshake()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgHandshake)
}

void MsgHandshake::InitAsDefaultInstance() {
}

MsgHandshake::MsgHandshake(const MsgHandshake& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgHandshake)
}

void MsgHandshake::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  protocol_version_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  flags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgHandshake::~MsgHandshake() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgHandshake)
  SharedDtor();
}

void MsgHandshake::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgHandshake::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgHandshake& MsgHandshake::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgHandshake* MsgHandshake::default_instance_ = NULL;

MsgHandshake* MsgHandshake::New() const {
  return new MsgHandshake;
}

void MsgHandshake::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgHandshake*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(protocol_version_, flags_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgHandshake::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgHandshake)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 protocol_version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protocol_version_)));
          set_has_protocol_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 3;
      case 3: {
        if (tag == 24) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgHandshake)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgHandshake)
  return false;
#undef DO_
}

void MsgHandshake::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgHandshake)
  // required uint32 protocol_version = 1;
  if (has_protocol_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->protocol_version(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional uint32 flags = 3;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->flags(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgHandshake)
}

int MsgHandshake::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 protocol_version = 1;
    if (has_protocol_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->protocol_version());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 flags = 3;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgHandshake::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgHandshake*>(&from));
}

void MsgHandshake::MergeFrom(const MsgHandshake& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol_version()) {
      set_protocol_version(from.protocol_version());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgHandshake::CopyFrom(const MsgHandshake& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgHandshake::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MsgHandshake::Swap(MsgHandshake* other) {
  if (other != this) {
    std::swap(protocol_version_, other->protocol_version_);
    std::swap(name_, other->name_);
    std::swap(flags_, other->flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgHandshake::GetTypeName() const {
  return "cvmfs.MsgHandshake";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgHandshakeAck::kStatusFieldNumber;
const int MsgHandshakeAck::kNameFieldNumber;
const int MsgHandshakeAck::kProtocolVersionFieldNumber;
const int MsgHandshakeAck::kSessionIdFieldNumber;
const int MsgHandshakeAck::kMaxObjectSizeFieldNumber;
const int MsgHandshakeAck::kCapabilitiesFieldNumber;
const int MsgHandshakeAck::kFlagsFieldNumber;
const int MsgHandshakeAck::kPidFieldNumber;
#endif  // !_MSC_VER

MsgHandshakeAck::MsgHandshakeAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgHandshakeAck)
}

void MsgHandshakeAck::InitAsDefaultInstance() {
}

MsgHandshakeAck::MsgHandshakeAck(const MsgHandshakeAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgHandshakeAck)
}

void MsgHandshakeAck::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  status_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_version_ = 0u;
  session_id_ = GOOGLE_ULONGLONG(0);
  max_object_size_ = 0u;
  capabilities_ = GOOGLE_ULONGLONG(0);
  flags_ = 0u;
  pid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgHandshakeAck::~MsgHandshakeAck() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgHandshakeAck)
  SharedDtor();
}

void MsgHandshakeAck::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgHandshakeAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgHandshakeAck& MsgHandshakeAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgHandshakeAck* MsgHandshakeAck::default_instance_ = NULL;

MsgHandshakeAck* MsgHandshakeAck::New() const {
  return new MsgHandshakeAck;
}

void MsgHandshakeAck::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgHandshakeAck*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(status_, pid_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgHandshakeAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgHandshakeAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cvmfs.EnumStatus status = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_protocol_version;
        break;
      }

      // required uint32 protocol_version = 3;
      case 3: {
        if (tag == 24) {
         parse_protocol_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protocol_version_)));
          set_has_protocol_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_session_id;
        break;
      }

      // required uint64 session_id = 4;
      case 4: {
        if (tag == 32) {
         parse_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_max_object_size;
        break;
      }

      // required uint32 max_object_size = 5;
      case 5: {
        if (tag == 40) {
         parse_max_object_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_object_size_)));
          set_has_max_object_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_capabilities;
        break;
      }

      // required uint64 capabilities = 6;
      case 6: {
        if (tag == 48) {
         parse_capabilities:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &capabilities_)));
          set_has_capabilities();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 7;
      case 7: {
        if (tag == 56) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_pid;
        break;
      }

      // optional uint64 pid = 8;
      case 8: {
        if (tag == 64) {
         parse_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgHandshakeAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgHandshakeAck)
  return false;
#undef DO_
}

void MsgHandshakeAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgHandshakeAck)
  // required .cvmfs.EnumStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required uint32 protocol_version = 3;
  if (has_protocol_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->protocol_version(), output);
  }

  // required uint64 session_id = 4;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->session_id(), output);
  }

  // required uint32 max_object_size = 5;
  if (has_max_object_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->max_object_size(), output);
  }

  // required uint64 capabilities = 6;
  if (has_capabilities()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->capabilities(), output);
  }

  // optional uint32 flags = 7;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->flags(), output);
  }

  // optional uint64 pid = 8;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->pid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgHandshakeAck)
}

int MsgHandshakeAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cvmfs.EnumStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 protocol_version = 3;
    if (has_protocol_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->protocol_version());
    }

    // required uint64 session_id = 4;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint32 max_object_size = 5;
    if (has_max_object_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_object_size());
    }

    // required uint64 capabilities = 6;
    if (has_capabilities()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->capabilities());
    }

    // optional uint32 flags = 7;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint64 pid = 8;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgHandshakeAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgHandshakeAck*>(&from));
}

void MsgHandshakeAck::MergeFrom(const MsgHandshakeAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_protocol_version()) {
      set_protocol_version(from.protocol_version());
    }
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_max_object_size()) {
      set_max_object_size(from.max_object_size());
    }
    if (from.has_capabilities()) {
      set_capabilities(from.capabilities());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgHandshakeAck::CopyFrom(const MsgHandshakeAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgHandshakeAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void MsgHandshakeAck::Swap(MsgHandshakeAck* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(name_, other->name_);
    std::swap(protocol_version_, other->protocol_version_);
    std::swap(session_id_, other->session_id_);
    std::swap(max_object_size_, other->max_object_size_);
    std::swap(capabilities_, other->capabilities_);
    std::swap(flags_, other->flags_);
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgHandshakeAck::GetTypeName() const {
  return "cvmfs.MsgHandshakeAck";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgQuit::kSessionIdFieldNumber;
#endif  // !_MSC_VER

MsgQuit::MsgQuit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgQuit)
}

void MsgQuit::InitAsDefaultInstance() {
}

MsgQuit::MsgQuit(const MsgQuit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgQuit)
}

void MsgQuit::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgQuit::~MsgQuit() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgQuit)
  SharedDtor();
}

void MsgQuit::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgQuit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgQuit& MsgQuit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgQuit* MsgQuit::default_instance_ = NULL;

MsgQuit* MsgQuit::New() const {
  return new MsgQuit;
}

void MsgQuit::Clear() {
  session_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgQuit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgQuit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgQuit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgQuit)
  return false;
#undef DO_
}

void MsgQuit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgQuit)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgQuit)
}

int MsgQuit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgQuit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgQuit*>(&from));
}

void MsgQuit::MergeFrom(const MsgQuit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgQuit::CopyFrom(const MsgQuit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgQuit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MsgQuit::Swap(MsgQuit* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgQuit::GetTypeName() const {
  return "cvmfs.MsgQuit";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgIoctl::kSessionIdFieldNumber;
const int MsgIoctl::kConncntChangeByFieldNumber;
#endif  // !_MSC_VER

MsgIoctl::MsgIoctl()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgIoctl)
}

void MsgIoctl::InitAsDefaultInstance() {
}

MsgIoctl::MsgIoctl(const MsgIoctl& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgIoctl)
}

void MsgIoctl::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  conncnt_change_by_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgIoctl::~MsgIoctl() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgIoctl)
  SharedDtor();
}

void MsgIoctl::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgIoctl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgIoctl& MsgIoctl::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgIoctl* MsgIoctl::default_instance_ = NULL;

MsgIoctl* MsgIoctl::New() const {
  return new MsgIoctl;
}

void MsgIoctl::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgIoctl*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(session_id_, conncnt_change_by_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgIoctl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgIoctl)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_conncnt_change_by;
        break;
      }

      // optional sint32 conncnt_change_by = 2;
      case 2: {
        if (tag == 16) {
         parse_conncnt_change_by:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &conncnt_change_by_)));
          set_has_conncnt_change_by();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgIoctl)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgIoctl)
  return false;
#undef DO_
}

void MsgIoctl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgIoctl)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // optional sint32 conncnt_change_by = 2;
  if (has_conncnt_change_by()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->conncnt_change_by(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgIoctl)
}

int MsgIoctl::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // optional sint32 conncnt_change_by = 2;
    if (has_conncnt_change_by()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->conncnt_change_by());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgIoctl::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgIoctl*>(&from));
}

void MsgIoctl::MergeFrom(const MsgIoctl& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_conncnt_change_by()) {
      set_conncnt_change_by(from.conncnt_change_by());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgIoctl::CopyFrom(const MsgIoctl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgIoctl::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MsgIoctl::Swap(MsgIoctl* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(conncnt_change_by_, other->conncnt_change_by_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgIoctl::GetTypeName() const {
  return "cvmfs.MsgIoctl";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgStoreReq::kSessionIdFieldNumber;
const int MsgStoreReq::kReqIdFieldNumber;
const int MsgStoreReq::kObjectIdFieldNumber;
const int MsgStoreReq::kPartNrFieldNumber;
const int MsgStoreReq::kLastPartFieldNumber;
const int MsgStoreReq::kExpectedSizeFieldNumber;
const int MsgStoreReq::kObjectTypeFieldNumber;
const int MsgStoreReq::kDescriptionFieldNumber;
const int MsgStoreReq::kDataCrc32FieldNumber;
#endif  // !_MSC_VER

MsgStoreReq::MsgStoreReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgStoreReq)
}

void MsgStoreReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  object_id_ = const_cast< ::cvmfs::MsgHash*>(
      ::cvmfs::MsgHash::internal_default_instance());
#else
  object_id_ = const_cast< ::cvmfs::MsgHash*>(&::cvmfs::MsgHash::default_instance());
#endif
}

MsgStoreReq::MsgStoreReq(const MsgStoreReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgStoreReq)
}

void MsgStoreReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  object_id_ = NULL;
  part_nr_ = GOOGLE_ULONGLONG(0);
  last_part_ = false;
  expected_size_ = GOOGLE_ULONGLONG(0);
  object_type_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_crc32_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgStoreReq::~MsgStoreReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgStoreReq)
  SharedDtor();
}

void MsgStoreReq::SharedDtor() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete object_id_;
  }
}

void MsgStoreReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgStoreReq& MsgStoreReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgStoreReq* MsgStoreReq::default_instance_ = NULL;

MsgStoreReq* MsgStoreReq::New() const {
  return new MsgStoreReq;
}

void MsgStoreReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgStoreReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(session_id_, req_id_);
    ZR_(part_nr_, object_type_);
    if (has_object_id()) {
      if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        description_->clear();
      }
    }
  }
  data_crc32_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgStoreReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgStoreReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_object_id;
        break;
      }

      // required .cvmfs.MsgHash object_id = 3;
      case 3: {
        if (tag == 26) {
         parse_object_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_part_nr;
        break;
      }

      // required uint64 part_nr = 4;
      case 4: {
        if (tag == 32) {
         parse_part_nr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &part_nr_)));
          set_has_part_nr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_last_part;
        break;
      }

      // required bool last_part = 5;
      case 5: {
        if (tag == 40) {
         parse_last_part:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &last_part_)));
          set_has_last_part();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_expected_size;
        break;
      }

      // optional uint64 expected_size = 6;
      case 6: {
        if (tag == 48) {
         parse_expected_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &expected_size_)));
          set_has_expected_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_object_type;
        break;
      }

      // optional .cvmfs.EnumObjectType object_type = 7;
      case 7: {
        if (tag == 56) {
         parse_object_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumObjectType_IsValid(value)) {
            set_object_type(static_cast< ::cvmfs::EnumObjectType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_description;
        break;
      }

      // optional string description = 8;
      case 8: {
        if (tag == 66) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_data_crc32;
        break;
      }

      // optional fixed32 data_crc32 = 9;
      case 9: {
        if (tag == 77) {
         parse_data_crc32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &data_crc32_)));
          set_has_data_crc32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgStoreReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgStoreReq)
  return false;
#undef DO_
}

void MsgStoreReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgStoreReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required .cvmfs.MsgHash object_id = 3;
  if (has_object_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->object_id(), output);
  }

  // required uint64 part_nr = 4;
  if (has_part_nr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->part_nr(), output);
  }

  // required bool last_part = 5;
  if (has_last_part()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->last_part(), output);
  }

  // optional uint64 expected_size = 6;
  if (has_expected_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->expected_size(), output);
  }

  // optional .cvmfs.EnumObjectType object_type = 7;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->object_type(), output);
  }

  // optional string description = 8;
  if (has_description()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->description(), output);
  }

  // optional fixed32 data_crc32 = 9;
  if (has_data_crc32()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(9, this->data_crc32(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgStoreReq)
}

int MsgStoreReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.MsgHash object_id = 3;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->object_id());
    }

    // required uint64 part_nr = 4;
    if (has_part_nr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->part_nr());
    }

    // required bool last_part = 5;
    if (has_last_part()) {
      total_size += 1 + 1;
    }

    // optional uint64 expected_size = 6;
    if (has_expected_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->expected_size());
    }

    // optional .cvmfs.EnumObjectType object_type = 7;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
    }

    // optional string description = 8;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional fixed32 data_crc32 = 9;
    if (has_data_crc32()) {
      total_size += 1 + 4;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgStoreReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgStoreReq*>(&from));
}

void MsgStoreReq::MergeFrom(const MsgStoreReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_object_id()) {
      mutable_object_id()->::cvmfs::MsgHash::MergeFrom(from.object_id());
    }
    if (from.has_part_nr()) {
      set_part_nr(from.part_nr());
    }
    if (from.has_last_part()) {
      set_last_part(from.last_part());
    }
    if (from.has_expected_size()) {
      set_expected_size(from.expected_size());
    }
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_data_crc32()) {
      set_data_crc32(from.data_crc32());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgStoreReq::CopyFrom(const MsgStoreReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgStoreReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_object_id()) {
    if (!this->object_id().IsInitialized()) return false;
  }
  return true;
}

void MsgStoreReq::Swap(MsgStoreReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(object_id_, other->object_id_);
    std::swap(part_nr_, other->part_nr_);
    std::swap(last_part_, other->last_part_);
    std::swap(expected_size_, other->expected_size_);
    std::swap(object_type_, other->object_type_);
    std::swap(description_, other->description_);
    std::swap(data_crc32_, other->data_crc32_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgStoreReq::GetTypeName() const {
  return "cvmfs.MsgStoreReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgStoreAbortReq::kSessionIdFieldNumber;
const int MsgStoreAbortReq::kReqIdFieldNumber;
const int MsgStoreAbortReq::kObjectIdFieldNumber;
#endif  // !_MSC_VER

MsgStoreAbortReq::MsgStoreAbortReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgStoreAbortReq)
}

void MsgStoreAbortReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  object_id_ = const_cast< ::cvmfs::MsgHash*>(
      ::cvmfs::MsgHash::internal_default_instance());
#else
  object_id_ = const_cast< ::cvmfs::MsgHash*>(&::cvmfs::MsgHash::default_instance());
#endif
}

MsgStoreAbortReq::MsgStoreAbortReq(const MsgStoreAbortReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgStoreAbortReq)
}

void MsgStoreAbortReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  object_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgStoreAbortReq::~MsgStoreAbortReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgStoreAbortReq)
  SharedDtor();
}

void MsgStoreAbortReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete object_id_;
  }
}

void MsgStoreAbortReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgStoreAbortReq& MsgStoreAbortReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgStoreAbortReq* MsgStoreAbortReq::default_instance_ = NULL;

MsgStoreAbortReq* MsgStoreAbortReq::New() const {
  return new MsgStoreAbortReq;
}

void MsgStoreAbortReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgStoreAbortReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(session_id_, req_id_);
    if (has_object_id()) {
      if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgStoreAbortReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgStoreAbortReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_object_id;
        break;
      }

      // required .cvmfs.MsgHash object_id = 3;
      case 3: {
        if (tag == 26) {
         parse_object_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgStoreAbortReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgStoreAbortReq)
  return false;
#undef DO_
}

void MsgStoreAbortReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgStoreAbortReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required .cvmfs.MsgHash object_id = 3;
  if (has_object_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->object_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgStoreAbortReq)
}

int MsgStoreAbortReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.MsgHash object_id = 3;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->object_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgStoreAbortReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgStoreAbortReq*>(&from));
}

void MsgStoreAbortReq::MergeFrom(const MsgStoreAbortReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_object_id()) {
      mutable_object_id()->::cvmfs::MsgHash::MergeFrom(from.object_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgStoreAbortReq::CopyFrom(const MsgStoreAbortReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgStoreAbortReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_object_id()) {
    if (!this->object_id().IsInitialized()) return false;
  }
  return true;
}

void MsgStoreAbortReq::Swap(MsgStoreAbortReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(object_id_, other->object_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgStoreAbortReq::GetTypeName() const {
  return "cvmfs.MsgStoreAbortReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgStoreReply::kReqIdFieldNumber;
const int MsgStoreReply::kStatusFieldNumber;
const int MsgStoreReply::kPartNrFieldNumber;
#endif  // !_MSC_VER

MsgStoreReply::MsgStoreReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgStoreReply)
}

void MsgStoreReply::InitAsDefaultInstance() {
}

MsgStoreReply::MsgStoreReply(const MsgStoreReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgStoreReply)
}

void MsgStoreReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  part_nr_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgStoreReply::~MsgStoreReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgStoreReply)
  SharedDtor();
}

void MsgStoreReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgStoreReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgStoreReply& MsgStoreReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgStoreReply* MsgStoreReply::default_instance_ = NULL;

MsgStoreReply* MsgStoreReply::New() const {
  return new MsgStoreReply;
}

void MsgStoreReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgStoreReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_id_, status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgStoreReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgStoreReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_part_nr;
        break;
      }

      // required uint64 part_nr = 3;
      case 3: {
        if (tag == 24) {
         parse_part_nr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &part_nr_)));
          set_has_part_nr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgStoreReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgStoreReply)
  return false;
#undef DO_
}

void MsgStoreReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgStoreReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // required uint64 part_nr = 3;
  if (has_part_nr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->part_nr(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgStoreReply)
}

int MsgStoreReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // required uint64 part_nr = 3;
    if (has_part_nr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->part_nr());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgStoreReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgStoreReply*>(&from));
}

void MsgStoreReply::MergeFrom(const MsgStoreReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_part_nr()) {
      set_part_nr(from.part_nr());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgStoreReply::CopyFrom(const MsgStoreReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgStoreReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MsgStoreReply::Swap(MsgStoreReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(part_nr_, other->part_nr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgStoreReply::GetTypeName() const {
  return "cvmfs.MsgStoreReply";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRefcountReq::kSessionIdFieldNumber;
const int MsgRefcountReq::kReqIdFieldNumber;
const int MsgRefcountReq::kObjectIdFieldNumber;
const int MsgRefcountReq::kChangeByFieldNumber;
#endif  // !_MSC_VER

MsgRefcountReq::MsgRefcountReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgRefcountReq)
}

void MsgRefcountReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  object_id_ = const_cast< ::cvmfs::MsgHash*>(
      ::cvmfs::MsgHash::internal_default_instance());
#else
  object_id_ = const_cast< ::cvmfs::MsgHash*>(&::cvmfs::MsgHash::default_instance());
#endif
}

MsgRefcountReq::MsgRefcountReq(const MsgRefcountReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgRefcountReq)
}

void MsgRefcountReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  object_id_ = NULL;
  change_by_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRefcountReq::~MsgRefcountReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgRefcountReq)
  SharedDtor();
}

void MsgRefcountReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete object_id_;
  }
}

void MsgRefcountReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgRefcountReq& MsgRefcountReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgRefcountReq* MsgRefcountReq::default_instance_ = NULL;

MsgRefcountReq* MsgRefcountReq::New() const {
  return new MsgRefcountReq;
}

void MsgRefcountReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgRefcountReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(session_id_, req_id_);
    if (has_object_id()) {
      if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
    }
    change_by_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgRefcountReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgRefcountReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_object_id;
        break;
      }

      // required .cvmfs.MsgHash object_id = 3;
      case 3: {
        if (tag == 26) {
         parse_object_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_change_by;
        break;
      }

      // required sint32 change_by = 4;
      case 4: {
        if (tag == 32) {
         parse_change_by:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &change_by_)));
          set_has_change_by();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgRefcountReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgRefcountReq)
  return false;
#undef DO_
}

void MsgRefcountReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgRefcountReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required .cvmfs.MsgHash object_id = 3;
  if (has_object_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->object_id(), output);
  }

  // required sint32 change_by = 4;
  if (has_change_by()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->change_by(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgRefcountReq)
}

int MsgRefcountReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.MsgHash object_id = 3;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->object_id());
    }

    // required sint32 change_by = 4;
    if (has_change_by()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->change_by());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRefcountReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgRefcountReq*>(&from));
}

void MsgRefcountReq::MergeFrom(const MsgRefcountReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_object_id()) {
      mutable_object_id()->::cvmfs::MsgHash::MergeFrom(from.object_id());
    }
    if (from.has_change_by()) {
      set_change_by(from.change_by());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgRefcountReq::CopyFrom(const MsgRefcountReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRefcountReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_object_id()) {
    if (!this->object_id().IsInitialized()) return false;
  }
  return true;
}

void MsgRefcountReq::Swap(MsgRefcountReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(object_id_, other->object_id_);
    std::swap(change_by_, other->change_by_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgRefcountReq::GetTypeName() const {
  return "cvmfs.MsgRefcountReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRefcountReply::kReqIdFieldNumber;
const int MsgRefcountReply::kStatusFieldNumber;
#endif  // !_MSC_VER

MsgRefcountReply::MsgRefcountReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgRefcountReply)
}

void MsgRefcountReply::InitAsDefaultInstance() {
}

MsgRefcountReply::MsgRefcountReply(const MsgRefcountReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgRefcountReply)
}

void MsgRefcountReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRefcountReply::~MsgRefcountReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgRefcountReply)
  SharedDtor();
}

void MsgRefcountReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgRefcountReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgRefcountReply& MsgRefcountReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgRefcountReply* MsgRefcountReply::default_instance_ = NULL;

MsgRefcountReply* MsgRefcountReply::New() const {
  return new MsgRefcountReply;
}

void MsgRefcountReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgRefcountReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_id_, status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgRefcountReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgRefcountReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgRefcountReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgRefcountReply)
  return false;
#undef DO_
}

void MsgRefcountReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgRefcountReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgRefcountReply)
}

int MsgRefcountReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRefcountReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgRefcountReply*>(&from));
}

void MsgRefcountReply::MergeFrom(const MsgRefcountReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgRefcountReply::CopyFrom(const MsgRefcountReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRefcountReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MsgRefcountReply::Swap(MsgRefcountReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgRefcountReply::GetTypeName() const {
  return "cvmfs.MsgRefcountReply";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

MsgDetach::MsgDetach()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgDetach)
}

void MsgDetach::InitAsDefaultInstance() {
}

MsgDetach::MsgDetach(const MsgDetach& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgDetach)
}

void MsgDetach::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgDetach::~MsgDetach() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgDetach)
  SharedDtor();
}

void MsgDetach::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgDetach::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgDetach& MsgDetach::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgDetach* MsgDetach::default_instance_ = NULL;

MsgDetach* MsgDetach::New() const {
  return new MsgDetach;
}

void MsgDetach::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgDetach::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgDetach)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgDetach)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgDetach)
  return false;
#undef DO_
}

void MsgDetach::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgDetach)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgDetach)
}

int MsgDetach::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgDetach::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgDetach*>(&from));
}

void MsgDetach::MergeFrom(const MsgDetach& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgDetach::CopyFrom(const MsgDetach& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgDetach::IsInitialized() const {

  return true;
}

void MsgDetach::Swap(MsgDetach* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgDetach::GetTypeName() const {
  return "cvmfs.MsgDetach";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgShrinkReq::kSessionIdFieldNumber;
const int MsgShrinkReq::kReqIdFieldNumber;
const int MsgShrinkReq::kShrinkToFieldNumber;
#endif  // !_MSC_VER

MsgShrinkReq::MsgShrinkReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgShrinkReq)
}

void MsgShrinkReq::InitAsDefaultInstance() {
}

MsgShrinkReq::MsgShrinkReq(const MsgShrinkReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgShrinkReq)
}

void MsgShrinkReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  shrink_to_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgShrinkReq::~MsgShrinkReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgShrinkReq)
  SharedDtor();
}

void MsgShrinkReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgShrinkReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgShrinkReq& MsgShrinkReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgShrinkReq* MsgShrinkReq::default_instance_ = NULL;

MsgShrinkReq* MsgShrinkReq::New() const {
  return new MsgShrinkReq;
}

void MsgShrinkReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgShrinkReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(session_id_, shrink_to_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgShrinkReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgShrinkReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_shrink_to;
        break;
      }

      // required uint64 shrink_to = 3;
      case 3: {
        if (tag == 24) {
         parse_shrink_to:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &shrink_to_)));
          set_has_shrink_to();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgShrinkReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgShrinkReq)
  return false;
#undef DO_
}

void MsgShrinkReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgShrinkReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required uint64 shrink_to = 3;
  if (has_shrink_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->shrink_to(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgShrinkReq)
}

int MsgShrinkReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required uint64 shrink_to = 3;
    if (has_shrink_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->shrink_to());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgShrinkReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgShrinkReq*>(&from));
}

void MsgShrinkReq::MergeFrom(const MsgShrinkReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_shrink_to()) {
      set_shrink_to(from.shrink_to());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgShrinkReq::CopyFrom(const MsgShrinkReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgShrinkReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MsgShrinkReq::Swap(MsgShrinkReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(shrink_to_, other->shrink_to_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgShrinkReq::GetTypeName() const {
  return "cvmfs.MsgShrinkReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgShrinkReply::kReqIdFieldNumber;
const int MsgShrinkReply::kStatusFieldNumber;
const int MsgShrinkReply::kUsedBytesFieldNumber;
#endif  // !_MSC_VER

MsgShrinkReply::MsgShrinkReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgShrinkReply)
}

void MsgShrinkReply::InitAsDefaultInstance() {
}

MsgShrinkReply::MsgShrinkReply(const MsgShrinkReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgShrinkReply)
}

void MsgShrinkReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  used_bytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgShrinkReply::~MsgShrinkReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgShrinkReply)
  SharedDtor();
}

void MsgShrinkReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgShrinkReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgShrinkReply& MsgShrinkReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgShrinkReply* MsgShrinkReply::default_instance_ = NULL;

MsgShrinkReply* MsgShrinkReply::New() const {
  return new MsgShrinkReply;
}

void MsgShrinkReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgShrinkReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_id_, status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgShrinkReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgShrinkReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_used_bytes;
        break;
      }

      // required uint64 used_bytes = 3;
      case 3: {
        if (tag == 24) {
         parse_used_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &used_bytes_)));
          set_has_used_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgShrinkReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgShrinkReply)
  return false;
#undef DO_
}

void MsgShrinkReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgShrinkReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // required uint64 used_bytes = 3;
  if (has_used_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->used_bytes(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgShrinkReply)
}

int MsgShrinkReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // required uint64 used_bytes = 3;
    if (has_used_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->used_bytes());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgShrinkReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgShrinkReply*>(&from));
}

void MsgShrinkReply::MergeFrom(const MsgShrinkReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_used_bytes()) {
      set_used_bytes(from.used_bytes());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgShrinkReply::CopyFrom(const MsgShrinkReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgShrinkReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MsgShrinkReply::Swap(MsgShrinkReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(used_bytes_, other->used_bytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgShrinkReply::GetTypeName() const {
  return "cvmfs.MsgShrinkReply";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgReadReq::kSessionIdFieldNumber;
const int MsgReadReq::kReqIdFieldNumber;
const int MsgReadReq::kObjectIdFieldNumber;
const int MsgReadReq::kOffsetFieldNumber;
const int MsgReadReq::kSizeFieldNumber;
#endif  // !_MSC_VER

MsgReadReq::MsgReadReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgReadReq)
}

void MsgReadReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  object_id_ = const_cast< ::cvmfs::MsgHash*>(
      ::cvmfs::MsgHash::internal_default_instance());
#else
  object_id_ = const_cast< ::cvmfs::MsgHash*>(&::cvmfs::MsgHash::default_instance());
#endif
}

MsgReadReq::MsgReadReq(const MsgReadReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgReadReq)
}

void MsgReadReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  object_id_ = NULL;
  offset_ = GOOGLE_ULONGLONG(0);
  size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgReadReq::~MsgReadReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgReadReq)
  SharedDtor();
}

void MsgReadReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete object_id_;
  }
}

void MsgReadReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgReadReq& MsgReadReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgReadReq* MsgReadReq::default_instance_ = NULL;

MsgReadReq* MsgReadReq::New() const {
  return new MsgReadReq;
}

void MsgReadReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgReadReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(session_id_, req_id_);
    ZR_(offset_, size_);
    if (has_object_id()) {
      if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgReadReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgReadReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_object_id;
        break;
      }

      // required .cvmfs.MsgHash object_id = 3;
      case 3: {
        if (tag == 26) {
         parse_object_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_offset;
        break;
      }

      // required uint64 offset = 4;
      case 4: {
        if (tag == 32) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_size;
        break;
      }

      // required uint32 size = 5;
      case 5: {
        if (tag == 40) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgReadReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgReadReq)
  return false;
#undef DO_
}

void MsgReadReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgReadReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required .cvmfs.MsgHash object_id = 3;
  if (has_object_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->object_id(), output);
  }

  // required uint64 offset = 4;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->offset(), output);
  }

  // required uint32 size = 5;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->size(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgReadReq)
}

int MsgReadReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.MsgHash object_id = 3;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->object_id());
    }

    // required uint64 offset = 4;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

    // required uint32 size = 5;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgReadReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgReadReq*>(&from));
}

void MsgReadReq::MergeFrom(const MsgReadReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_object_id()) {
      mutable_object_id()->::cvmfs::MsgHash::MergeFrom(from.object_id());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgReadReq::CopyFrom(const MsgReadReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgReadReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_object_id()) {
    if (!this->object_id().IsInitialized()) return false;
  }
  return true;
}

void MsgReadReq::Swap(MsgReadReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(object_id_, other->object_id_);
    std::swap(offset_, other->offset_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgReadReq::GetTypeName() const {
  return "cvmfs.MsgReadReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgReadReply::kReqIdFieldNumber;
const int MsgReadReply::kStatusFieldNumber;
const int MsgReadReply::kDataCrc32FieldNumber;
#endif  // !_MSC_VER

MsgReadReply::MsgReadReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgReadReply)
}

void MsgReadReply::InitAsDefaultInstance() {
}

MsgReadReply::MsgReadReply(const MsgReadReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgReadReply)
}

void MsgReadReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  data_crc32_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgReadReply::~MsgReadReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgReadReply)
  SharedDtor();
}

void MsgReadReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgReadReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgReadReply& MsgReadReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgReadReply* MsgReadReply::default_instance_ = NULL;

MsgReadReply* MsgReadReply::New() const {
  return new MsgReadReply;
}

void MsgReadReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgReadReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_id_, data_crc32_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgReadReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgReadReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_data_crc32;
        break;
      }

      // optional fixed32 data_crc32 = 3;
      case 3: {
        if (tag == 29) {
         parse_data_crc32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &data_crc32_)));
          set_has_data_crc32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgReadReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgReadReply)
  return false;
#undef DO_
}

void MsgReadReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgReadReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional fixed32 data_crc32 = 3;
  if (has_data_crc32()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->data_crc32(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgReadReply)
}

int MsgReadReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional fixed32 data_crc32 = 3;
    if (has_data_crc32()) {
      total_size += 1 + 4;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgReadReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgReadReply*>(&from));
}

void MsgReadReply::MergeFrom(const MsgReadReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_data_crc32()) {
      set_data_crc32(from.data_crc32());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgReadReply::CopyFrom(const MsgReadReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgReadReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MsgReadReply::Swap(MsgReadReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(data_crc32_, other->data_crc32_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgReadReply::GetTypeName() const {
  return "cvmfs.MsgReadReply";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgInfoReq::kSessionIdFieldNumber;
const int MsgInfoReq::kReqIdFieldNumber;
const int MsgInfoReq::kNoShrinkInPeriodFieldNumber;
#endif  // !_MSC_VER

MsgInfoReq::MsgInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgInfoReq)
}

void MsgInfoReq::InitAsDefaultInstance() {
}

MsgInfoReq::MsgInfoReq(const MsgInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgInfoReq)
}

void MsgInfoReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  no_shrink_in_period_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgInfoReq::~MsgInfoReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgInfoReq)
  SharedDtor();
}

void MsgInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgInfoReq& MsgInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgInfoReq* MsgInfoReq::default_instance_ = NULL;

MsgInfoReq* MsgInfoReq::New() const {
  return new MsgInfoReq;
}

void MsgInfoReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgInfoReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(session_id_, no_shrink_in_period_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_no_shrink_in_period;
        break;
      }

      // optional uint64 no_shrink_in_period = 3;
      case 3: {
        if (tag == 24) {
         parse_no_shrink_in_period:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &no_shrink_in_period_)));
          set_has_no_shrink_in_period();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgInfoReq)
  return false;
#undef DO_
}

void MsgInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgInfoReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // optional uint64 no_shrink_in_period = 3;
  if (has_no_shrink_in_period()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->no_shrink_in_period(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgInfoReq)
}

int MsgInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // optional uint64 no_shrink_in_period = 3;
    if (has_no_shrink_in_period()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->no_shrink_in_period());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgInfoReq*>(&from));
}

void MsgInfoReq::MergeFrom(const MsgInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_no_shrink_in_period()) {
      set_no_shrink_in_period(from.no_shrink_in_period());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgInfoReq::CopyFrom(const MsgInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MsgInfoReq::Swap(MsgInfoReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(no_shrink_in_period_, other->no_shrink_in_period_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgInfoReq::GetTypeName() const {
  return "cvmfs.MsgInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgInfoReply::kReqIdFieldNumber;
const int MsgInfoReply::kStatusFieldNumber;
const int MsgInfoReply::kSizeBytesFieldNumber;
const int MsgInfoReply::kUsedBytesFieldNumber;
const int MsgInfoReply::kPinnedBytesFieldNumber;
const int MsgInfoReply::kNoShrinkFieldNumber;
#endif  // !_MSC_VER

MsgInfoReply::MsgInfoReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgInfoReply)
}

void MsgInfoReply::InitAsDefaultInstance() {
}

MsgInfoReply::MsgInfoReply(const MsgInfoReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgInfoReply)
}

void MsgInfoReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  size_bytes_ = GOOGLE_ULONGLONG(0);
  used_bytes_ = GOOGLE_ULONGLONG(0);
  pinned_bytes_ = GOOGLE_ULONGLONG(0);
  no_shrink_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgInfoReply::~MsgInfoReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgInfoReply)
  SharedDtor();
}

void MsgInfoReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgInfoReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgInfoReply& MsgInfoReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgInfoReply* MsgInfoReply::default_instance_ = NULL;

MsgInfoReply* MsgInfoReply::New() const {
  return new MsgInfoReply;
}

void MsgInfoReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgInfoReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(req_id_, status_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgInfoReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgInfoReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_size_bytes;
        break;
      }

      // required uint64 size_bytes = 3;
      case 3: {
        if (tag == 24) {
         parse_size_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_bytes_)));
          set_has_size_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_used_bytes;
        break;
      }

      // required uint64 used_bytes = 4;
      case 4: {
        if (tag == 32) {
         parse_used_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &used_bytes_)));
          set_has_used_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_pinned_bytes;
        break;
      }

      // required uint64 pinned_bytes = 5;
      case 5: {
        if (tag == 40) {
         parse_pinned_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pinned_bytes_)));
          set_has_pinned_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_no_shrink;
        break;
      }

      // required int64 no_shrink = 6;
      case 6: {
        if (tag == 48) {
         parse_no_shrink:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &no_shrink_)));
          set_has_no_shrink();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgInfoReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgInfoReply)
  return false;
#undef DO_
}

void MsgInfoReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgInfoReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // required uint64 size_bytes = 3;
  if (has_size_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->size_bytes(), output);
  }

  // required uint64 used_bytes = 4;
  if (has_used_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->used_bytes(), output);
  }

  // required uint64 pinned_bytes = 5;
  if (has_pinned_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->pinned_bytes(), output);
  }

  // required int64 no_shrink = 6;
  if (has_no_shrink()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->no_shrink(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgInfoReply)
}

int MsgInfoReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // required uint64 size_bytes = 3;
    if (has_size_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size_bytes());
    }

    // required uint64 used_bytes = 4;
    if (has_used_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->used_bytes());
    }

    // required uint64 pinned_bytes = 5;
    if (has_pinned_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pinned_bytes());
    }

    // required int64 no_shrink = 6;
    if (has_no_shrink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->no_shrink());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgInfoReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgInfoReply*>(&from));
}

void MsgInfoReply::MergeFrom(const MsgInfoReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_size_bytes()) {
      set_size_bytes(from.size_bytes());
    }
    if (from.has_used_bytes()) {
      set_used_bytes(from.used_bytes());
    }
    if (from.has_pinned_bytes()) {
      set_pinned_bytes(from.pinned_bytes());
    }
    if (from.has_no_shrink()) {
      set_no_shrink(from.no_shrink());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgInfoReply::CopyFrom(const MsgInfoReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfoReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void MsgInfoReply::Swap(MsgInfoReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(size_bytes_, other->size_bytes_);
    std::swap(used_bytes_, other->used_bytes_);
    std::swap(pinned_bytes_, other->pinned_bytes_);
    std::swap(no_shrink_, other->no_shrink_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgInfoReply::GetTypeName() const {
  return "cvmfs.MsgInfoReply";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgObjectInfoReq::kSessionIdFieldNumber;
const int MsgObjectInfoReq::kReqIdFieldNumber;
const int MsgObjectInfoReq::kObjectIdFieldNumber;
#endif  // !_MSC_VER

MsgObjectInfoReq::MsgObjectInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgObjectInfoReq)
}

void MsgObjectInfoReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  object_id_ = const_cast< ::cvmfs::MsgHash*>(
      ::cvmfs::MsgHash::internal_default_instance());
#else
  object_id_ = const_cast< ::cvmfs::MsgHash*>(&::cvmfs::MsgHash::default_instance());
#endif
}

MsgObjectInfoReq::MsgObjectInfoReq(const MsgObjectInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgObjectInfoReq)
}

void MsgObjectInfoReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  object_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgObjectInfoReq::~MsgObjectInfoReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgObjectInfoReq)
  SharedDtor();
}

void MsgObjectInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete object_id_;
  }
}

void MsgObjectInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgObjectInfoReq& MsgObjectInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgObjectInfoReq* MsgObjectInfoReq::default_instance_ = NULL;

MsgObjectInfoReq* MsgObjectInfoReq::New() const {
  return new MsgObjectInfoReq;
}

void MsgObjectInfoReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgObjectInfoReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(session_id_, req_id_);
    if (has_object_id()) {
      if (object_id_ != NULL) object_id_->::cvmfs::MsgHash::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgObjectInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgObjectInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_object_id;
        break;
      }

      // required .cvmfs.MsgHash object_id = 3;
      case 3: {
        if (tag == 26) {
         parse_object_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgObjectInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgObjectInfoReq)
  return false;
#undef DO_
}

void MsgObjectInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgObjectInfoReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required .cvmfs.MsgHash object_id = 3;
  if (has_object_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->object_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgObjectInfoReq)
}

int MsgObjectInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.MsgHash object_id = 3;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->object_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgObjectInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgObjectInfoReq*>(&from));
}

void MsgObjectInfoReq::MergeFrom(const MsgObjectInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_object_id()) {
      mutable_object_id()->::cvmfs::MsgHash::MergeFrom(from.object_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgObjectInfoReq::CopyFrom(const MsgObjectInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgObjectInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_object_id()) {
    if (!this->object_id().IsInitialized()) return false;
  }
  return true;
}

void MsgObjectInfoReq::Swap(MsgObjectInfoReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(object_id_, other->object_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgObjectInfoReq::GetTypeName() const {
  return "cvmfs.MsgObjectInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgObjectInfoReply::kReqIdFieldNumber;
const int MsgObjectInfoReply::kStatusFieldNumber;
const int MsgObjectInfoReply::kObjectTypeFieldNumber;
const int MsgObjectInfoReply::kSizeFieldNumber;
#endif  // !_MSC_VER

MsgObjectInfoReply::MsgObjectInfoReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgObjectInfoReply)
}

void MsgObjectInfoReply::InitAsDefaultInstance() {
}

MsgObjectInfoReply::MsgObjectInfoReply(const MsgObjectInfoReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgObjectInfoReply)
}

void MsgObjectInfoReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  object_type_ = 0;
  size_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgObjectInfoReply::~MsgObjectInfoReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgObjectInfoReply)
  SharedDtor();
}

void MsgObjectInfoReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgObjectInfoReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgObjectInfoReply& MsgObjectInfoReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgObjectInfoReply* MsgObjectInfoReply::default_instance_ = NULL;

MsgObjectInfoReply* MsgObjectInfoReply::New() const {
  return new MsgObjectInfoReply;
}

void MsgObjectInfoReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgObjectInfoReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_id_, size_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgObjectInfoReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgObjectInfoReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_object_type;
        break;
      }

      // optional .cvmfs.EnumObjectType object_type = 3;
      case 3: {
        if (tag == 24) {
         parse_object_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumObjectType_IsValid(value)) {
            set_object_type(static_cast< ::cvmfs::EnumObjectType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_size;
        break;
      }

      // optional uint64 size = 4;
      case 4: {
        if (tag == 32) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgObjectInfoReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgObjectInfoReply)
  return false;
#undef DO_
}

void MsgObjectInfoReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgObjectInfoReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional .cvmfs.EnumObjectType object_type = 3;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->object_type(), output);
  }

  // optional uint64 size = 4;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->size(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgObjectInfoReply)
}

int MsgObjectInfoReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional .cvmfs.EnumObjectType object_type = 3;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
    }

    // optional uint64 size = 4;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgObjectInfoReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgObjectInfoReply*>(&from));
}

void MsgObjectInfoReply::MergeFrom(const MsgObjectInfoReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgObjectInfoReply::CopyFrom(const MsgObjectInfoReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgObjectInfoReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MsgObjectInfoReply::Swap(MsgObjectInfoReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(object_type_, other->object_type_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgObjectInfoReply::GetTypeName() const {
  return "cvmfs.MsgObjectInfoReply";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgListReq::kSessionIdFieldNumber;
const int MsgListReq::kReqIdFieldNumber;
const int MsgListReq::kListingIdFieldNumber;
const int MsgListReq::kObjectTypeFieldNumber;
#endif  // !_MSC_VER

MsgListReq::MsgListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgListReq)
}

void MsgListReq::InitAsDefaultInstance() {
}

MsgListReq::MsgListReq(const MsgListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgListReq)
}

void MsgListReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  listing_id_ = GOOGLE_ULONGLONG(0);
  object_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgListReq::~MsgListReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgListReq)
  SharedDtor();
}

void MsgListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgListReq& MsgListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgListReq* MsgListReq::default_instance_ = NULL;

MsgListReq* MsgListReq::New() const {
  return new MsgListReq;
}

void MsgListReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgListReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(session_id_, object_type_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_listing_id;
        break;
      }

      // required uint64 listing_id = 3;
      case 3: {
        if (tag == 24) {
         parse_listing_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &listing_id_)));
          set_has_listing_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_object_type;
        break;
      }

      // required .cvmfs.EnumObjectType object_type = 4;
      case 4: {
        if (tag == 32) {
         parse_object_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumObjectType_IsValid(value)) {
            set_object_type(static_cast< ::cvmfs::EnumObjectType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgListReq)
  return false;
#undef DO_
}

void MsgListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgListReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required uint64 listing_id = 3;
  if (has_listing_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->listing_id(), output);
  }

  // required .cvmfs.EnumObjectType object_type = 4;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->object_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgListReq)
}

int MsgListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required uint64 listing_id = 3;
    if (has_listing_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->listing_id());
    }

    // required .cvmfs.EnumObjectType object_type = 4;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgListReq*>(&from));
}

void MsgListReq::MergeFrom(const MsgListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_listing_id()) {
      set_listing_id(from.listing_id());
    }
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgListReq::CopyFrom(const MsgListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void MsgListReq::Swap(MsgListReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(listing_id_, other->listing_id_);
    std::swap(object_type_, other->object_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgListReq::GetTypeName() const {
  return "cvmfs.MsgListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgListReply::kReqIdFieldNumber;
const int MsgListReply::kStatusFieldNumber;
const int MsgListReply::kListingIdFieldNumber;
const int MsgListReply::kIsLastPartFieldNumber;
const int MsgListReply::kListRecordFieldNumber;
#endif  // !_MSC_VER

MsgListReply::MsgListReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgListReply)
}

void MsgListReply::InitAsDefaultInstance() {
}

MsgListReply::MsgListReply(const MsgListReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgListReply)
}

void MsgListReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  listing_id_ = GOOGLE_ULONGLONG(0);
  is_last_part_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgListReply::~MsgListReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgListReply)
  SharedDtor();
}

void MsgListReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgListReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgListReply& MsgListReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgListReply* MsgListReply::default_instance_ = NULL;

MsgListReply* MsgListReply::New() const {
  return new MsgListReply;
}

void MsgListReply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgListReply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_id_, is_last_part_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  list_record_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgListReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgListReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_listing_id;
        break;
      }

      // required uint64 listing_id = 3;
      case 3: {
        if (tag == 24) {
         parse_listing_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &listing_id_)));
          set_has_listing_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_is_last_part;
        break;
      }

      // required bool is_last_part = 4;
      case 4: {
        if (tag == 32) {
         parse_is_last_part:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_last_part_)));
          set_has_is_last_part();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_list_record;
        break;
      }

      // repeated .cvmfs.MsgListRecord list_record = 5;
      case 5: {
        if (tag == 42) {
         parse_list_record:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list_record()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_list_record;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgListReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgListReply)
  return false;
#undef DO_
}

void MsgListReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgListReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // required uint64 listing_id = 3;
  if (has_listing_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->listing_id(), output);
  }

  // required bool is_last_part = 4;
  if (has_is_last_part()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_last_part(), output);
  }

  // repeated .cvmfs.MsgListRecord list_record = 5;
  for (int i = 0; i < this->list_record_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->list_record(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgListReply)
}

int MsgListReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // required uint64 listing_id = 3;
    if (has_listing_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->listing_id());
    }

    // required bool is_last_part = 4;
    if (has_is_last_part()) {
      total_size += 1 + 1;
    }

  }
  // repeated .cvmfs.MsgListRecord list_record = 5;
  total_size += 1 * this->list_record_size();
  for (int i = 0; i < this->list_record_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list_record(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgListReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgListReply*>(&from));
}

void MsgListReply::MergeFrom(const MsgListReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_record_.MergeFrom(from.list_record_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_listing_id()) {
      set_listing_id(from.listing_id());
    }
    if (from.has_is_last_part()) {
      set_is_last_part(from.is_last_part());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgListReply::CopyFrom(const MsgListReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgListReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->list_record())) return false;
  return true;
}

void MsgListReply::Swap(MsgListReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(listing_id_, other->listing_id_);
    std::swap(is_last_part_, other->is_last_part_);
    list_record_.Swap(&other->list_record_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgListReply::GetTypeName() const {
  return "cvmfs.MsgListReply";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgBreadcrumbStoreReq::kSessionIdFieldNumber;
const int MsgBreadcrumbStoreReq::kReqIdFieldNumber;
const int MsgBreadcrumbStoreReq::kBreadcrumbFieldNumber;
#endif  // !_MSC_VER

MsgBreadcrumbStoreReq::MsgBreadcrumbStoreReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgBreadcrumbStoreReq)
}

void MsgBreadcrumbStoreReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  breadcrumb_ = const_cast< ::cvmfs::MsgBreadcrumb*>(
      ::cvmfs::MsgBreadcrumb::internal_default_instance());
#else
  breadcrumb_ = const_cast< ::cvmfs::MsgBreadcrumb*>(&::cvmfs::MsgBreadcrumb::default_instance());
#endif
}

MsgBreadcrumbStoreReq::MsgBreadcrumbStoreReq(const MsgBreadcrumbStoreReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgBreadcrumbStoreReq)
}

void MsgBreadcrumbStoreReq::SharedCtor() {
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  breadcrumb_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgBreadcrumbStoreReq::~MsgBreadcrumbStoreReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgBreadcrumbStoreReq)
  SharedDtor();
}

void MsgBreadcrumbStoreReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete breadcrumb_;
  }
}

void MsgBreadcrumbStoreReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgBreadcrumbStoreReq& MsgBreadcrumbStoreReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgBreadcrumbStoreReq* MsgBreadcrumbStoreReq::default_instance_ = NULL;

MsgBreadcrumbStoreReq* MsgBreadcrumbStoreReq::New() const {
  return new MsgBreadcrumbStoreReq;
}

void MsgBreadcrumbStoreReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgBreadcrumbStoreReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(session_id_, req_id_);
    if (has_breadcrumb()) {
      if (breadcrumb_ != NULL) breadcrumb_->::cvmfs::MsgBreadcrumb::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgBreadcrumbStoreReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgBreadcrumbStoreReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_breadcrumb;
        break;
      }

      // required .cvmfs.MsgBreadcrumb breadcrumb = 3;
      case 3: {
        if (tag == 26) {
         parse_breadcrumb:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_breadcrumb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgBreadcrumbStoreReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgBreadcrumbStoreReq)
  return false;
#undef DO_
}

void MsgBreadcrumbStoreReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgBreadcrumbStoreReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required .cvmfs.MsgBreadcrumb breadcrumb = 3;
  if (has_breadcrumb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->breadcrumb(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgBreadcrumbStoreReq)
}

int MsgBreadcrumbStoreReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.MsgBreadcrumb breadcrumb = 3;
    if (has_breadcrumb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->breadcrumb());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgBreadcrumbStoreReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgBreadcrumbStoreReq*>(&from));
}

void MsgBreadcrumbStoreReq::MergeFrom(const MsgBreadcrumbStoreReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_breadcrumb()) {
      mutable_breadcrumb()->::cvmfs::MsgBreadcrumb::MergeFrom(from.breadcrumb());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgBreadcrumbStoreReq::CopyFrom(const MsgBreadcrumbStoreReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgBreadcrumbStoreReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_breadcrumb()) {
    if (!this->breadcrumb().IsInitialized()) return false;
  }
  return true;
}

void MsgBreadcrumbStoreReq::Swap(MsgBreadcrumbStoreReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(breadcrumb_, other->breadcrumb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgBreadcrumbStoreReq::GetTypeName() const {
  return "cvmfs.MsgBreadcrumbStoreReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgBreadcrumbLoadReq::kSessionIdFieldNumber;
const int MsgBreadcrumbLoadReq::kReqIdFieldNumber;
const int MsgBreadcrumbLoadReq::kFqrnFieldNumber;
#endif  // !_MSC_VER

MsgBreadcrumbLoadReq::MsgBreadcrumbLoadReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgBreadcrumbLoadReq)
}

void MsgBreadcrumbLoadReq::InitAsDefaultInstance() {
}

MsgBreadcrumbLoadReq::MsgBreadcrumbLoadReq(const MsgBreadcrumbLoadReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgBreadcrumbLoadReq)
}

void MsgBreadcrumbLoadReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  session_id_ = GOOGLE_ULONGLONG(0);
  req_id_ = GOOGLE_ULONGLONG(0);
  fqrn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgBreadcrumbLoadReq::~MsgBreadcrumbLoadReq() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgBreadcrumbLoadReq)
  SharedDtor();
}

void MsgBreadcrumbLoadReq::SharedDtor() {
  if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fqrn_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgBreadcrumbLoadReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgBreadcrumbLoadReq& MsgBreadcrumbLoadReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgBreadcrumbLoadReq* MsgBreadcrumbLoadReq::default_instance_ = NULL;

MsgBreadcrumbLoadReq* MsgBreadcrumbLoadReq::New() const {
  return new MsgBreadcrumbLoadReq;
}

void MsgBreadcrumbLoadReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgBreadcrumbLoadReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(session_id_, req_id_);
    if (has_fqrn()) {
      if (fqrn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        fqrn_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgBreadcrumbLoadReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgBreadcrumbLoadReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_id;
        break;
      }

      // required uint64 req_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_fqrn;
        break;
      }

      // required string fqrn = 3;
      case 3: {
        if (tag == 26) {
         parse_fqrn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fqrn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgBreadcrumbLoadReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgBreadcrumbLoadReq)
  return false;
#undef DO_
}

void MsgBreadcrumbLoadReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgBreadcrumbLoadReq)
  // required uint64 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session_id(), output);
  }

  // required uint64 req_id = 2;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->req_id(), output);
  }

  // required string fqrn = 3;
  if (has_fqrn()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->fqrn(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgBreadcrumbLoadReq)
}

int MsgBreadcrumbLoadReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session_id());
    }

    // required uint64 req_id = 2;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required string fqrn = 3;
    if (has_fqrn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fqrn());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgBreadcrumbLoadReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgBreadcrumbLoadReq*>(&from));
}

void MsgBreadcrumbLoadReq::MergeFrom(const MsgBreadcrumbLoadReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_fqrn()) {
      set_fqrn(from.fqrn());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgBreadcrumbLoadReq::CopyFrom(const MsgBreadcrumbLoadReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgBreadcrumbLoadReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MsgBreadcrumbLoadReq::Swap(MsgBreadcrumbLoadReq* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(req_id_, other->req_id_);
    std::swap(fqrn_, other->fqrn_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgBreadcrumbLoadReq::GetTypeName() const {
  return "cvmfs.MsgBreadcrumbLoadReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgBreadcrumbReply::kReqIdFieldNumber;
const int MsgBreadcrumbReply::kStatusFieldNumber;
const int MsgBreadcrumbReply::kBreadcrumbFieldNumber;
#endif  // !_MSC_VER

MsgBreadcrumbReply::MsgBreadcrumbReply()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgBreadcrumbReply)
}

void MsgBreadcrumbReply::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  breadcrumb_ = const_cast< ::cvmfs::MsgBreadcrumb*>(
      ::cvmfs::MsgBreadcrumb::internal_default_instance());
#else
  breadcrumb_ = const_cast< ::cvmfs::MsgBreadcrumb*>(&::cvmfs::MsgBreadcrumb::default_instance());
#endif
}

MsgBreadcrumbReply::MsgBreadcrumbReply(const MsgBreadcrumbReply& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgBreadcrumbReply)
}

void MsgBreadcrumbReply::SharedCtor() {
  _cached_size_ = 0;
  req_id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  breadcrumb_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgBreadcrumbReply::~MsgBreadcrumbReply() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgBreadcrumbReply)
  SharedDtor();
}

void MsgBreadcrumbReply::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete breadcrumb_;
  }
}

void MsgBreadcrumbReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgBreadcrumbReply& MsgBreadcrumbReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgBreadcrumbReply* MsgBreadcrumbReply::default_instance_ = NULL;

MsgBreadcrumbReply* MsgBreadcrumbReply::New() const {
  return new MsgBreadcrumbReply;
}

void MsgBreadcrumbReply::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    req_id_ = GOOGLE_ULONGLONG(0);
    status_ = 0;
    if (has_breadcrumb()) {
      if (breadcrumb_ != NULL) breadcrumb_->::cvmfs::MsgBreadcrumb::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgBreadcrumbReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgBreadcrumbReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 req_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_id_)));
          set_has_req_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cvmfs.EnumStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cvmfs::EnumStatus_IsValid(value)) {
            set_status(static_cast< ::cvmfs::EnumStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_breadcrumb;
        break;
      }

      // optional .cvmfs.MsgBreadcrumb breadcrumb = 3;
      case 3: {
        if (tag == 26) {
         parse_breadcrumb:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_breadcrumb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgBreadcrumbReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgBreadcrumbReply)
  return false;
#undef DO_
}

void MsgBreadcrumbReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgBreadcrumbReply)
  // required uint64 req_id = 1;
  if (has_req_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->req_id(), output);
  }

  // required .cvmfs.EnumStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional .cvmfs.MsgBreadcrumb breadcrumb = 3;
  if (has_breadcrumb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->breadcrumb(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgBreadcrumbReply)
}

int MsgBreadcrumbReply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 req_id = 1;
    if (has_req_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_id());
    }

    // required .cvmfs.EnumStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional .cvmfs.MsgBreadcrumb breadcrumb = 3;
    if (has_breadcrumb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->breadcrumb());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgBreadcrumbReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgBreadcrumbReply*>(&from));
}

void MsgBreadcrumbReply::MergeFrom(const MsgBreadcrumbReply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_id()) {
      set_req_id(from.req_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_breadcrumb()) {
      mutable_breadcrumb()->::cvmfs::MsgBreadcrumb::MergeFrom(from.breadcrumb());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgBreadcrumbReply::CopyFrom(const MsgBreadcrumbReply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgBreadcrumbReply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_breadcrumb()) {
    if (!this->breadcrumb().IsInitialized()) return false;
  }
  return true;
}

void MsgBreadcrumbReply::Swap(MsgBreadcrumbReply* other) {
  if (other != this) {
    std::swap(req_id_, other->req_id_);
    std::swap(status_, other->status_);
    std::swap(breadcrumb_, other->breadcrumb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgBreadcrumbReply::GetTypeName() const {
  return "cvmfs.MsgBreadcrumbReply";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRpc::kMsgRefcountReqFieldNumber;
const int MsgRpc::kMsgRefcountReplyFieldNumber;
const int MsgRpc::kMsgReadReqFieldNumber;
const int MsgRpc::kMsgReadReplyFieldNumber;
const int MsgRpc::kMsgObjectInfoReqFieldNumber;
const int MsgRpc::kMsgObjectInfoReplyFieldNumber;
const int MsgRpc::kMsgStoreReqFieldNumber;
const int MsgRpc::kMsgStoreAbortReqFieldNumber;
const int MsgRpc::kMsgStoreReplyFieldNumber;
const int MsgRpc::kMsgHandshakeFieldNumber;
const int MsgRpc::kMsgHandshakeAckFieldNumber;
const int MsgRpc::kMsgQuitFieldNumber;
const int MsgRpc::kMsgInfoReqFieldNumber;
const int MsgRpc::kMsgInfoReplyFieldNumber;
const int MsgRpc::kMsgShrinkReqFieldNumber;
const int MsgRpc::kMsgShrinkReplyFieldNumber;
const int MsgRpc::kMsgListReqFieldNumber;
const int MsgRpc::kMsgListReplyFieldNumber;
const int MsgRpc::kMsgDetachFieldNumber;
const int MsgRpc::kMsgIoctlFieldNumber;
const int MsgRpc::kMsgBreadcrumbStoreReqFieldNumber;
const int MsgRpc::kMsgBreadcrumbLoadReqFieldNumber;
const int MsgRpc::kMsgBreadcrumbReplyFieldNumber;
#endif  // !_MSC_VER

MsgRpc::MsgRpc()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cvmfs.MsgRpc)
}

void MsgRpc::InitAsDefaultInstance() {
}

MsgRpc::MsgRpc(const MsgRpc& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cvmfs.MsgRpc)
}

void MsgRpc::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_message_type();
}

MsgRpc::~MsgRpc() {
  // @@protoc_insertion_point(destructor:cvmfs.MsgRpc)
  SharedDtor();
}

void MsgRpc::SharedDtor() {
  if (has_message_type()) {
    clear_message_type();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgRpc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgRpc& MsgRpc::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cache_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cache_2eproto();
#endif
  return *default_instance_;
}

MsgRpc* MsgRpc::default_instance_ = NULL;

MsgRpc* MsgRpc::New() const {
  return new MsgRpc;
}

void MsgRpc::clear_message_type() {
  switch(message_type_case()) {
    case kMsgRefcountReq: {
      delete message_type_.msg_refcount_req_;
      break;
    }
    case kMsgRefcountReply: {
      delete message_type_.msg_refcount_reply_;
      break;
    }
    case kMsgReadReq: {
      delete message_type_.msg_read_req_;
      break;
    }
    case kMsgReadReply: {
      delete message_type_.msg_read_reply_;
      break;
    }
    case kMsgObjectInfoReq: {
      delete message_type_.msg_object_info_req_;
      break;
    }
    case kMsgObjectInfoReply: {
      delete message_type_.msg_object_info_reply_;
      break;
    }
    case kMsgStoreReq: {
      delete message_type_.msg_store_req_;
      break;
    }
    case kMsgStoreAbortReq: {
      delete message_type_.msg_store_abort_req_;
      break;
    }
    case kMsgStoreReply: {
      delete message_type_.msg_store_reply_;
      break;
    }
    case kMsgHandshake: {
      delete message_type_.msg_handshake_;
      break;
    }
    case kMsgHandshakeAck: {
      delete message_type_.msg_handshake_ack_;
      break;
    }
    case kMsgQuit: {
      delete message_type_.msg_quit_;
      break;
    }
    case kMsgInfoReq: {
      delete message_type_.msg_info_req_;
      break;
    }
    case kMsgInfoReply: {
      delete message_type_.msg_info_reply_;
      break;
    }
    case kMsgShrinkReq: {
      delete message_type_.msg_shrink_req_;
      break;
    }
    case kMsgShrinkReply: {
      delete message_type_.msg_shrink_reply_;
      break;
    }
    case kMsgListReq: {
      delete message_type_.msg_list_req_;
      break;
    }
    case kMsgListReply: {
      delete message_type_.msg_list_reply_;
      break;
    }
    case kMsgDetach: {
      delete message_type_.msg_detach_;
      break;
    }
    case kMsgIoctl: {
      delete message_type_.msg_ioctl_;
      break;
    }
    case kMsgBreadcrumbStoreReq: {
      delete message_type_.msg_breadcrumb_store_req_;
      break;
    }
    case kMsgBreadcrumbLoadReq: {
      delete message_type_.msg_breadcrumb_load_req_;
      break;
    }
    case kMsgBreadcrumbReply: {
      delete message_type_.msg_breadcrumb_reply_;
      break;
    }
    case MESSAGE_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MESSAGE_TYPE_NOT_SET;
}


void MsgRpc::Clear() {
  clear_message_type();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgRpc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:cvmfs.MsgRpc)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cvmfs.MsgRefcountReq msg_refcount_req = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_refcount_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg_refcount_reply;
        break;
      }

      // optional .cvmfs.MsgRefcountReply msg_refcount_reply = 2;
      case 2: {
        if (tag == 18) {
         parse_msg_refcount_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_refcount_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_msg_read_req;
        break;
      }

      // optional .cvmfs.MsgReadReq msg_read_req = 3;
      case 3: {
        if (tag == 26) {
         parse_msg_read_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_read_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_msg_read_reply;
        break;
      }

      // optional .cvmfs.MsgReadReply msg_read_reply = 4;
      case 4: {
        if (tag == 34) {
         parse_msg_read_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_read_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_msg_object_info_req;
        break;
      }

      // optional .cvmfs.MsgObjectInfoReq msg_object_info_req = 5;
      case 5: {
        if (tag == 42) {
         parse_msg_object_info_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_object_info_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_msg_object_info_reply;
        break;
      }

      // optional .cvmfs.MsgObjectInfoReply msg_object_info_reply = 6;
      case 6: {
        if (tag == 50) {
         parse_msg_object_info_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_object_info_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_msg_store_req;
        break;
      }

      // optional .cvmfs.MsgStoreReq msg_store_req = 7;
      case 7: {
        if (tag == 58) {
         parse_msg_store_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_store_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_msg_store_abort_req;
        break;
      }

      // optional .cvmfs.MsgStoreAbortReq msg_store_abort_req = 8;
      case 8: {
        if (tag == 66) {
         parse_msg_store_abort_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_store_abort_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_msg_store_reply;
        break;
      }

      // optional .cvmfs.MsgStoreReply msg_store_reply = 9;
      case 9: {
        if (tag == 74) {
         parse_msg_store_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_store_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_msg_handshake;
        break;
      }

      // optional .cvmfs.MsgHandshake msg_handshake = 16;
      case 16: {
        if (tag == 130) {
         parse_msg_handshake:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_handshake()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_msg_handshake_ack;
        break;
      }

      // optional .cvmfs.MsgHandshakeAck msg_handshake_ack = 17;
      case 17: {
        if (tag == 138) {
         parse_msg_handshake_ack:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_handshake_ack()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_msg_quit;
        break;
      }

      // optional .cvmfs.MsgQuit msg_quit = 18;
      case 18: {
        if (tag == 146) {
         parse_msg_quit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_quit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_msg_info_req;
        break;
      }

      // optional .cvmfs.MsgInfoReq msg_info_req = 19;
      case 19: {
        if (tag == 154) {
         parse_msg_info_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_info_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_msg_info_reply;
        break;
      }

      // optional .cvmfs.MsgInfoReply msg_info_reply = 20;
      case 20: {
        if (tag == 162) {
         parse_msg_info_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_info_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_msg_shrink_req;
        break;
      }

      // optional .cvmfs.MsgShrinkReq msg_shrink_req = 21;
      case 21: {
        if (tag == 170) {
         parse_msg_shrink_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_shrink_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_msg_shrink_reply;
        break;
      }

      // optional .cvmfs.MsgShrinkReply msg_shrink_reply = 22;
      case 22: {
        if (tag == 178) {
         parse_msg_shrink_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_shrink_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(186)) goto parse_msg_list_req;
        break;
      }

      // optional .cvmfs.MsgListReq msg_list_req = 23;
      case 23: {
        if (tag == 186) {
         parse_msg_list_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_list_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(194)) goto parse_msg_list_reply;
        break;
      }

      // optional .cvmfs.MsgListReply msg_list_reply = 24;
      case 24: {
        if (tag == 194) {
         parse_msg_list_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_list_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_msg_detach;
        break;
      }

      // optional .cvmfs.MsgDetach msg_detach = 25;
      case 25: {
        if (tag == 202) {
         parse_msg_detach:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_detach()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(210)) goto parse_msg_ioctl;
        break;
      }

      // optional .cvmfs.MsgIoctl msg_ioctl = 26;
      case 26: {
        if (tag == 210) {
         parse_msg_ioctl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_ioctl()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(218)) goto parse_msg_breadcrumb_store_req;
        break;
      }

      // optional .cvmfs.MsgBreadcrumbStoreReq msg_breadcrumb_store_req = 27;
      case 27: {
        if (tag == 218) {
         parse_msg_breadcrumb_store_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_breadcrumb_store_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(226)) goto parse_msg_breadcrumb_load_req;
        break;
      }

      // optional .cvmfs.MsgBreadcrumbLoadReq msg_breadcrumb_load_req = 28;
      case 28: {
        if (tag == 226) {
         parse_msg_breadcrumb_load_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_breadcrumb_load_req()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(234)) goto parse_msg_breadcrumb_reply;
        break;
      }

      // optional .cvmfs.MsgBreadcrumbReply msg_breadcrumb_reply = 29;
      case 29: {
        if (tag == 234) {
         parse_msg_breadcrumb_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_breadcrumb_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cvmfs.MsgRpc)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cvmfs.MsgRpc)
  return false;
#undef DO_
}

void MsgRpc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cvmfs.MsgRpc)
  // optional .cvmfs.MsgRefcountReq msg_refcount_req = 1;
  if (has_msg_refcount_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->msg_refcount_req(), output);
  }

  // optional .cvmfs.MsgRefcountReply msg_refcount_reply = 2;
  if (has_msg_refcount_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->msg_refcount_reply(), output);
  }

  // optional .cvmfs.MsgReadReq msg_read_req = 3;
  if (has_msg_read_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->msg_read_req(), output);
  }

  // optional .cvmfs.MsgReadReply msg_read_reply = 4;
  if (has_msg_read_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->msg_read_reply(), output);
  }

  // optional .cvmfs.MsgObjectInfoReq msg_object_info_req = 5;
  if (has_msg_object_info_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->msg_object_info_req(), output);
  }

  // optional .cvmfs.MsgObjectInfoReply msg_object_info_reply = 6;
  if (has_msg_object_info_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->msg_object_info_reply(), output);
  }

  // optional .cvmfs.MsgStoreReq msg_store_req = 7;
  if (has_msg_store_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->msg_store_req(), output);
  }

  // optional .cvmfs.MsgStoreAbortReq msg_store_abort_req = 8;
  if (has_msg_store_abort_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->msg_store_abort_req(), output);
  }

  // optional .cvmfs.MsgStoreReply msg_store_reply = 9;
  if (has_msg_store_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->msg_store_reply(), output);
  }

  // optional .cvmfs.MsgHandshake msg_handshake = 16;
  if (has_msg_handshake()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      16, this->msg_handshake(), output);
  }

  // optional .cvmfs.MsgHandshakeAck msg_handshake_ack = 17;
  if (has_msg_handshake_ack()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      17, this->msg_handshake_ack(), output);
  }

  // optional .cvmfs.MsgQuit msg_quit = 18;
  if (has_msg_quit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      18, this->msg_quit(), output);
  }

  // optional .cvmfs.MsgInfoReq msg_info_req = 19;
  if (has_msg_info_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      19, this->msg_info_req(), output);
  }

  // optional .cvmfs.MsgInfoReply msg_info_reply = 20;
  if (has_msg_info_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, this->msg_info_reply(), output);
  }

  // optional .cvmfs.MsgShrinkReq msg_shrink_req = 21;
  if (has_msg_shrink_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      21, this->msg_shrink_req(), output);
  }

  // optional .cvmfs.MsgShrinkReply msg_shrink_reply = 22;
  if (has_msg_shrink_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      22, this->msg_shrink_reply(), output);
  }

  // optional .cvmfs.MsgListReq msg_list_req = 23;
  if (has_msg_list_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      23, this->msg_list_req(), output);
  }

  // optional .cvmfs.MsgListReply msg_list_reply = 24;
  if (has_msg_list_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      24, this->msg_list_reply(), output);
  }

  // optional .cvmfs.MsgDetach msg_detach = 25;
  if (has_msg_detach()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      25, this->msg_detach(), output);
  }

  // optional .cvmfs.MsgIoctl msg_ioctl = 26;
  if (has_msg_ioctl()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      26, this->msg_ioctl(), output);
  }

  // optional .cvmfs.MsgBreadcrumbStoreReq msg_breadcrumb_store_req = 27;
  if (has_msg_breadcrumb_store_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      27, this->msg_breadcrumb_store_req(), output);
  }

  // optional .cvmfs.MsgBreadcrumbLoadReq msg_breadcrumb_load_req = 28;
  if (has_msg_breadcrumb_load_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      28, this->msg_breadcrumb_load_req(), output);
  }

  // optional .cvmfs.MsgBreadcrumbReply msg_breadcrumb_reply = 29;
  if (has_msg_breadcrumb_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      29, this->msg_breadcrumb_reply(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:cvmfs.MsgRpc)
}

int MsgRpc::ByteSize() const {
  int total_size = 0;

  switch (message_type_case()) {
    // optional .cvmfs.MsgRefcountReq msg_refcount_req = 1;
    case kMsgRefcountReq: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_refcount_req());
      break;
    }
    // optional .cvmfs.MsgRefcountReply msg_refcount_reply = 2;
    case kMsgRefcountReply: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_refcount_reply());
      break;
    }
    // optional .cvmfs.MsgReadReq msg_read_req = 3;
    case kMsgReadReq: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_read_req());
      break;
    }
    // optional .cvmfs.MsgReadReply msg_read_reply = 4;
    case kMsgReadReply: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_read_reply());
      break;
    }
    // optional .cvmfs.MsgObjectInfoReq msg_object_info_req = 5;
    case kMsgObjectInfoReq: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_object_info_req());
      break;
    }
    // optional .cvmfs.MsgObjectInfoReply msg_object_info_reply = 6;
    case kMsgObjectInfoReply: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_object_info_reply());
      break;
    }
    // optional .cvmfs.MsgStoreReq msg_store_req = 7;
    case kMsgStoreReq: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_store_req());
      break;
    }
    // optional .cvmfs.MsgStoreAbortReq msg_store_abort_req = 8;
    case kMsgStoreAbortReq: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_store_abort_req());
      break;
    }
    // optional .cvmfs.MsgStoreReply msg_store_reply = 9;
    case kMsgStoreReply: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_store_reply());
      break;
    }
    // optional .cvmfs.MsgHandshake msg_handshake = 16;
    case kMsgHandshake: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_handshake());
      break;
    }
    // optional .cvmfs.MsgHandshakeAck msg_handshake_ack = 17;
    case kMsgHandshakeAck: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_handshake_ack());
      break;
    }
    // optional .cvmfs.MsgQuit msg_quit = 18;
    case kMsgQuit: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_quit());
      break;
    }
    // optional .cvmfs.MsgInfoReq msg_info_req = 19;
    case kMsgInfoReq: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_info_req());
      break;
    }
    // optional .cvmfs.MsgInfoReply msg_info_reply = 20;
    case kMsgInfoReply: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_info_reply());
      break;
    }
    // optional .cvmfs.MsgShrinkReq msg_shrink_req = 21;
    case kMsgShrinkReq: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_shrink_req());
      break;
    }
    // optional .cvmfs.MsgShrinkReply msg_shrink_reply = 22;
    case kMsgShrinkReply: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_shrink_reply());
      break;
    }
    // optional .cvmfs.MsgListReq msg_list_req = 23;
    case kMsgListReq: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_list_req());
      break;
    }
    // optional .cvmfs.MsgListReply msg_list_reply = 24;
    case kMsgListReply: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_list_reply());
      break;
    }
    // optional .cvmfs.MsgDetach msg_detach = 25;
    case kMsgDetach: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_detach());
      break;
    }
    // optional .cvmfs.MsgIoctl msg_ioctl = 26;
    case kMsgIoctl: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_ioctl());
      break;
    }
    // optional .cvmfs.MsgBreadcrumbStoreReq msg_breadcrumb_store_req = 27;
    case kMsgBreadcrumbStoreReq: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_breadcrumb_store_req());
      break;
    }
    // optional .cvmfs.MsgBreadcrumbLoadReq msg_breadcrumb_load_req = 28;
    case kMsgBreadcrumbLoadReq: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_breadcrumb_load_req());
      break;
    }
    // optional .cvmfs.MsgBreadcrumbReply msg_breadcrumb_reply = 29;
    case kMsgBreadcrumbReply: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_breadcrumb_reply());
      break;
    }
    case MESSAGE_TYPE_NOT_SET: {
      break;
    }
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRpc::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgRpc*>(&from));
}

void MsgRpc::MergeFrom(const MsgRpc& from) {
  GOOGLE_CHECK_NE(&from, this);
  switch (from.message_type_case()) {
    case kMsgRefcountReq: {
      mutable_msg_refcount_req()->::cvmfs::MsgRefcountReq::MergeFrom(from.msg_refcount_req());
      break;
    }
    case kMsgRefcountReply: {
      mutable_msg_refcount_reply()->::cvmfs::MsgRefcountReply::MergeFrom(from.msg_refcount_reply());
      break;
    }
    case kMsgReadReq: {
      mutable_msg_read_req()->::cvmfs::MsgReadReq::MergeFrom(from.msg_read_req());
      break;
    }
    case kMsgReadReply: {
      mutable_msg_read_reply()->::cvmfs::MsgReadReply::MergeFrom(from.msg_read_reply());
      break;
    }
    case kMsgObjectInfoReq: {
      mutable_msg_object_info_req()->::cvmfs::MsgObjectInfoReq::MergeFrom(from.msg_object_info_req());
      break;
    }
    case kMsgObjectInfoReply: {
      mutable_msg_object_info_reply()->::cvmfs::MsgObjectInfoReply::MergeFrom(from.msg_object_info_reply());
      break;
    }
    case kMsgStoreReq: {
      mutable_msg_store_req()->::cvmfs::MsgStoreReq::MergeFrom(from.msg_store_req());
      break;
    }
    case kMsgStoreAbortReq: {
      mutable_msg_store_abort_req()->::cvmfs::MsgStoreAbortReq::MergeFrom(from.msg_store_abort_req());
      break;
    }
    case kMsgStoreReply: {
      mutable_msg_store_reply()->::cvmfs::MsgStoreReply::MergeFrom(from.msg_store_reply());
      break;
    }
    case kMsgHandshake: {
      mutable_msg_handshake()->::cvmfs::MsgHandshake::MergeFrom(from.msg_handshake());
      break;
    }
    case kMsgHandshakeAck: {
      mutable_msg_handshake_ack()->::cvmfs::MsgHandshakeAck::MergeFrom(from.msg_handshake_ack());
      break;
    }
    case kMsgQuit: {
      mutable_msg_quit()->::cvmfs::MsgQuit::MergeFrom(from.msg_quit());
      break;
    }
    case kMsgInfoReq: {
      mutable_msg_info_req()->::cvmfs::MsgInfoReq::MergeFrom(from.msg_info_req());
      break;
    }
    case kMsgInfoReply: {
      mutable_msg_info_reply()->::cvmfs::MsgInfoReply::MergeFrom(from.msg_info_reply());
      break;
    }
    case kMsgShrinkReq: {
      mutable_msg_shrink_req()->::cvmfs::MsgShrinkReq::MergeFrom(from.msg_shrink_req());
      break;
    }
    case kMsgShrinkReply: {
      mutable_msg_shrink_reply()->::cvmfs::MsgShrinkReply::MergeFrom(from.msg_shrink_reply());
      break;
    }
    case kMsgListReq: {
      mutable_msg_list_req()->::cvmfs::MsgListReq::MergeFrom(from.msg_list_req());
      break;
    }
    case kMsgListReply: {
      mutable_msg_list_reply()->::cvmfs::MsgListReply::MergeFrom(from.msg_list_reply());
      break;
    }
    case kMsgDetach: {
      mutable_msg_detach()->::cvmfs::MsgDetach::MergeFrom(from.msg_detach());
      break;
    }
    case kMsgIoctl: {
      mutable_msg_ioctl()->::cvmfs::MsgIoctl::MergeFrom(from.msg_ioctl());
      break;
    }
    case kMsgBreadcrumbStoreReq: {
      mutable_msg_breadcrumb_store_req()->::cvmfs::MsgBreadcrumbStoreReq::MergeFrom(from.msg_breadcrumb_store_req());
      break;
    }
    case kMsgBreadcrumbLoadReq: {
      mutable_msg_breadcrumb_load_req()->::cvmfs::MsgBreadcrumbLoadReq::MergeFrom(from.msg_breadcrumb_load_req());
      break;
    }
    case kMsgBreadcrumbReply: {
      mutable_msg_breadcrumb_reply()->::cvmfs::MsgBreadcrumbReply::MergeFrom(from.msg_breadcrumb_reply());
      break;
    }
    case MESSAGE_TYPE_NOT_SET: {
      break;
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgRpc::CopyFrom(const MsgRpc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRpc::IsInitialized() const {

  if (has_msg_refcount_req()) {
    if (!this->msg_refcount_req().IsInitialized()) return false;
  }
  if (has_msg_refcount_reply()) {
    if (!this->msg_refcount_reply().IsInitialized()) return false;
  }
  if (has_msg_read_req()) {
    if (!this->msg_read_req().IsInitialized()) return false;
  }
  if (has_msg_read_reply()) {
    if (!this->msg_read_reply().IsInitialized()) return false;
  }
  if (has_msg_object_info_req()) {
    if (!this->msg_object_info_req().IsInitialized()) return false;
  }
  if (has_msg_object_info_reply()) {
    if (!this->msg_object_info_reply().IsInitialized()) return false;
  }
  if (has_msg_store_req()) {
    if (!this->msg_store_req().IsInitialized()) return false;
  }
  if (has_msg_store_abort_req()) {
    if (!this->msg_store_abort_req().IsInitialized()) return false;
  }
  if (has_msg_store_reply()) {
    if (!this->msg_store_reply().IsInitialized()) return false;
  }
  if (has_msg_handshake()) {
    if (!this->msg_handshake().IsInitialized()) return false;
  }
  if (has_msg_handshake_ack()) {
    if (!this->msg_handshake_ack().IsInitialized()) return false;
  }
  if (has_msg_quit()) {
    if (!this->msg_quit().IsInitialized()) return false;
  }
  if (has_msg_info_req()) {
    if (!this->msg_info_req().IsInitialized()) return false;
  }
  if (has_msg_info_reply()) {
    if (!this->msg_info_reply().IsInitialized()) return false;
  }
  if (has_msg_shrink_req()) {
    if (!this->msg_shrink_req().IsInitialized()) return false;
  }
  if (has_msg_shrink_reply()) {
    if (!this->msg_shrink_reply().IsInitialized()) return false;
  }
  if (has_msg_list_req()) {
    if (!this->msg_list_req().IsInitialized()) return false;
  }
  if (has_msg_list_reply()) {
    if (!this->msg_list_reply().IsInitialized()) return false;
  }
  if (has_msg_ioctl()) {
    if (!this->msg_ioctl().IsInitialized()) return false;
  }
  if (has_msg_breadcrumb_store_req()) {
    if (!this->msg_breadcrumb_store_req().IsInitialized()) return false;
  }
  if (has_msg_breadcrumb_load_req()) {
    if (!this->msg_breadcrumb_load_req().IsInitialized()) return false;
  }
  if (has_msg_breadcrumb_reply()) {
    if (!this->msg_breadcrumb_reply().IsInitialized()) return false;
  }
  return true;
}

void MsgRpc::Swap(MsgRpc* other) {
  if (other != this) {
    std::swap(message_type_, other->message_type_);
    std::swap(_oneof_case_[0], other->_oneof_case_[0]);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgRpc::GetTypeName() const {
  return "cvmfs.MsgRpc";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cvmfs

// @@protoc_insertion_point(global_scope)
